{"version":3,"sources":["~lib/internal/allocator.ts","~lib/allocator/tlsf.ts","~lib/memory.ts","~lib/map.ts","~lib/arraybuffer.ts","~lib/internal/arraybuffer.ts","~lib/internal/memory.ts","assembly/primitives/TextureMap.ts","assembly/primitives/Image.ts","~lib/internal/hash.ts","~lib/internal/string.ts","~lib/string.ts","assembly/primitives/index.ts","assembly/renderer/CanvasPattern.ts","assembly/renderer/CanvasGradient.ts","assembly/renderer/Serializer.ts","~lib/internal/typedarray.ts","assembly/renderer/CanvasRenderingContext2DSerializer.ts","assembly/renderer/OptimizedCanvasRenderingContext2D.ts","~lib/array.ts","assembly/example.ts","src/shared/Direction.ts","assembly/primitives/FillStrokeWhichValue.ts","src/shared/GlobalCompositeOperation.ts","src/shared/ImageSmoothingQuality.ts","src/shared/LineCap.ts","src/shared/LineJoin.ts","src/shared/TextAlign.ts","src/shared/TextBaseline.ts","assembly/primitives/Path2DElement.ts","assembly/util/TypedArray.ts"],"names":[],"mappings":"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","sourceRoot":"assemblyscript:///","sourceContents":["/** Number of alignment bits. */\r\nexport const AL_BITS: u32 = 3;\r\n/** Number of possible alignment values. */\r\nexport const AL_SIZE: usize = 1 << <usize>AL_BITS;\r\n/** Mask to obtain just the alignment bits. */\r\nexport const AL_MASK: usize = AL_SIZE - 1;\r\n/** Maximum 32-bit allocation size. */\r\nexport const MAX_SIZE_32: usize = 1 << 30; // 1GB\r\n","/**\r\n * Two-Level Segregate Fit Memory Allocator.\r\n *\r\n * A general purpose dynamic memory allocator specifically designed to meet real-time requirements.\r\n * Always aligns to 8 bytes.\r\n *\r\n * @module std/assembly/allocator/tlsf\r\n *//***/\r\n\r\n// ╒══════════════ Block size interpretation (32-bit) ═════════════╕\r\n//    3                   2                   1\r\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\r\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┼─┴─┴─┴─┴─╫─┴─┴─┤\r\n// │ |                    FL                       │ SB = SL + AL  │ ◄─ usize\r\n// └───────────────────────────────────────────────┴─────────╨─────┘\r\n// FL: first level, SL: second level, AL: alignment, SB: small block\r\n\r\nimport {\r\n  AL_BITS,\r\n  AL_SIZE,\r\n  AL_MASK\r\n} from \"../internal/allocator\";\r\n\r\nconst SL_BITS: u32 = 5;\r\nconst SL_SIZE: usize = 1 << <usize>SL_BITS;\r\n\r\nconst SB_BITS: usize = <usize>(SL_BITS + AL_BITS);\r\nconst SB_SIZE: usize = 1 << <usize>SB_BITS;\r\n\r\nconst FL_BITS: u32 = (sizeof<usize>() == sizeof<u32>()\r\n  ? 30 // ^= up to 1GB per block\r\n  : 32 // ^= up to 4GB per block\r\n) - SB_BITS;\r\n\r\n// ╒════════════════ Block structure layout (32-bit) ══════════════╕\r\n//    3                   2                   1\r\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\r\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┼─┼─┤\r\n// │                          size                             │L│F│ ◄─┐ info\r\n// ╞═══════════════════════════════════════════════════════════╧═╧═╡   │      ┐\r\n// │                        if free: ◄ prev                        │ ◄─┤ usize\r\n// ├───────────────────────────────────────────────────────────────┤   │\r\n// │                        if free: next ►                        │ ◄─┤\r\n// ├───────────────────────────────────────────────────────────────┤   │\r\n// │                ... unused free space >= 0 ...                 │   │    = 0\r\n// ├ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┤   │\r\n// │                        if free: jump ▲                        │ ◄─┘\r\n// └───────────────────────────────────────────────────────────────┘ MIN SIZE ┘\r\n// F: FREE, L: LEFT_FREE\r\n\r\n/** Tag indicating that this block is free. */\r\nconst FREE: usize = 1 << 0;\r\n/** Tag indicating that this block's left block is free. */\r\nconst LEFT_FREE: usize = 1 << 1;\r\n/** Mask to obtain all tags. */\r\nconst TAGS: usize = FREE | LEFT_FREE;\r\n\r\n/** Block structure. */\r\n@unmanaged\r\nclass Block {\r\n\r\n  /** Info field holding this block's size and tags. */\r\n  info: usize;\r\n\r\n  /** End offset of the {@link Block#info} field. User data starts here. */\r\n  static readonly INFO: usize = (sizeof<usize>() + AL_MASK) & ~AL_MASK;\r\n\r\n  /** Previous free block, if any. Only valid if free. */\r\n  prev: Block | null;\r\n  /** Next free block, if any. Only valid if free. */\r\n  next: Block | null;\r\n\r\n  /** Minimum size of a block, excluding {@link Block#info}. */\r\n  static readonly MIN_SIZE: usize = (3 * sizeof<usize>() + AL_MASK) & ~AL_MASK;// prev + next + jump\r\n\r\n  /** Maximum size of a used block, excluding {@link Block#info}. */\r\n  static readonly MAX_SIZE: usize = 1 << (FL_BITS + SB_BITS);\r\n\r\n  /** Gets this block's left (free) block in memory. */\r\n  get left(): Block {\r\n    assert(this.info & LEFT_FREE); // must be free to contain a jump\r\n    return assert(\r\n      load<Block>(changetype<usize>(this) - sizeof<usize>())\r\n    ); // can't be null\r\n  }\r\n\r\n  /** Gets this block's right block in memory. */\r\n  get right(): Block {\r\n    assert(this.info & ~TAGS); // can't skip beyond the tail block\r\n    return assert(\r\n      changetype<Block>(\r\n        changetype<usize>(this) + Block.INFO + (this.info & ~TAGS)\r\n      )\r\n    ); // can't be null\r\n  }\r\n}\r\n\r\n// ╒════════════════ Root structure layout (32-bit) ═══════════════╕\r\n//    3                   2                   1\r\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\r\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤          ┐\r\n// │        0        |           flMap                            S│ ◄────┐\r\n// ╞═══════════════════════════════════════════════════════════════╡      │\r\n// │                           slMap[0] S                          │ ◄─┐  │\r\n// ├───────────────────────────────────────────────────────────────┤   │  │\r\n// │                           slMap[1]                            │ ◄─┤  │\r\n// ├───────────────────────────────────────────────────────────────┤  u32 │\r\n// │                              ...                              │ ◄─┤  │\r\n// ├───────────────────────────────────────────────────────────────┤   │  │\r\n// │                           slMap[22] P                         │ ◄─┘  │\r\n// ╞═══════════════════════════════════════════════════════════════╡    usize\r\n// │                            head[0]                            │ ◄────┤\r\n// ├───────────────────────────────────────────────────────────────┤      │\r\n// │                              ...                              │ ◄────┤\r\n// ├───────────────────────────────────────────────────────────────┤      │\r\n// │                           head[736]                           │ ◄────┤\r\n// ╞═══════════════════════════════════════════════════════════════╡      │\r\n// │                            tailRef                            │ ◄────┘\r\n// └───────────────────────────────────────────────────────────────┘   SIZE   ┘\r\n// S: Small blocks map, P: Possibly padded if 64-bit\r\n\r\nassert((1 << SL_BITS) <= 32); // second level must fit into 32 bits\r\n\r\n/** Root structure. */\r\n@unmanaged\r\nclass Root {\r\n\r\n  /** First level bitmap. */\r\n  flMap: usize = 0;\r\n\r\n  /** Start offset of second level maps. */\r\n  private static readonly SL_START: usize = sizeof<usize>();\r\n\r\n  // Using *one* SL map per *FL bit*\r\n\r\n  /** Gets the second level map for the specified first level. */\r\n  getSLMap(fl: usize): u32 {\r\n    assert(fl < FL_BITS); // fl out of range\r\n    return load<u32>(changetype<usize>(this) + fl * 4, Root.SL_START);\r\n  }\r\n\r\n  /** Sets the second level map for the specified first level. */\r\n  setSLMap(fl: usize, value: u32): void {\r\n    assert(fl < FL_BITS); // fl out of range\r\n    store<u32>(changetype<usize>(this) + fl * 4, value, Root.SL_START);\r\n  }\r\n\r\n  /** End offset of second level maps. */\r\n  private static readonly SL_END: usize = Root.SL_START + FL_BITS * 4;\r\n\r\n  // Using *number bits per SL* heads per *FL bit*\r\n\r\n  /** Start offset of FL/SL heads. */\r\n  private static readonly HL_START: usize = (Root.SL_END + AL_MASK) & ~AL_MASK;\r\n\r\n  /** Gets the head of the specified first and second level index. */\r\n  getHead(fl: usize, sl: u32): Block | null {\r\n    assert(fl < FL_BITS); // fl out of range\r\n    assert(sl < SL_SIZE); // sl out of range\r\n    return changetype<Block>(load<usize>(\r\n      changetype<usize>(this) + (fl * SL_SIZE + <usize>sl) * sizeof<usize>()\r\n    , Root.HL_START));\r\n  }\r\n\r\n  /** Sets the head of the specified first and second level index. */\r\n  setHead(fl: usize, sl: u32, value: Block | null): void {\r\n    assert(fl < FL_BITS); // fl out of range\r\n    assert(sl < SL_SIZE); // sl out of range\r\n    store<usize>(\r\n      changetype<usize>(this) + (fl * SL_SIZE + <usize>sl) * sizeof<usize>()\r\n    , changetype<usize>(value)\r\n    , Root.HL_START);\r\n  }\r\n\r\n  /** End offset of FL/SL heads. */\r\n  private static readonly HL_END: usize = (\r\n    Root.HL_START + FL_BITS * SL_SIZE * sizeof<usize>()\r\n  );\r\n\r\n  get tailRef(): usize { return load<usize>(0, Root.HL_END); }\r\n  set tailRef(value: usize) { store<usize>(0, value, Root.HL_END); }\r\n\r\n  /** Total size of the {@link Root} structure. */\r\n  static readonly SIZE: usize = Root.HL_END + sizeof<usize>();\r\n\r\n  /** Inserts a previously used block back into the free list. */\r\n  insert(block: Block): void {\r\n    // check as much as possible here to prevent invalid free blocks\r\n    assert(block); // cannot be null\r\n    var blockInfo = block.info;\r\n    assert(blockInfo & FREE); // must be free\r\n    var size: usize;\r\n    assert(\r\n      (size = block.info & ~TAGS) >= Block.MIN_SIZE && size < Block.MAX_SIZE\r\n    ); // must be valid, not necessary to compute yet if noAssert=true\r\n\r\n    var right: Block = assert(block.right); // can't be null\r\n    var rightInfo = right.info;\r\n\r\n    // merge with right block if also free\r\n    if (rightInfo & FREE) {\r\n      this.remove(right);\r\n      block.info = (blockInfo += Block.INFO + (rightInfo & ~TAGS));\r\n      right = block.right;\r\n      rightInfo = right.info;\r\n      // jump is set below\r\n    }\r\n\r\n    // merge with left block if also free\r\n    if (blockInfo & LEFT_FREE) {\r\n      let left: Block = assert(block.left); // can't be null\r\n      let leftInfo = left.info;\r\n      assert(leftInfo & FREE); // must be free according to tags\r\n      this.remove(left);\r\n      left.info = (leftInfo += Block.INFO + (blockInfo & ~TAGS));\r\n      block = left;\r\n      blockInfo = leftInfo;\r\n      // jump is set below\r\n    }\r\n\r\n    right.info = rightInfo | LEFT_FREE;\r\n    this.setJump(block, right);\r\n    // right is no longer used now, hence rightInfo is not synced\r\n\r\n    size = blockInfo & ~TAGS;\r\n    assert(size >= Block.MIN_SIZE && size < Block.MAX_SIZE); // must be valid\r\n\r\n    // mapping_insert\r\n    var fl: usize, sl: u32;\r\n    if (size < SB_SIZE) {\r\n      fl = 0;\r\n      sl = <u32>(size / AL_SIZE);\r\n    } else {\r\n      fl = fls<usize>(size);\r\n      sl = <u32>((size >> (fl - SL_BITS)) ^ (1 << SL_BITS));\r\n      fl -= SB_BITS - 1;\r\n    }\r\n\r\n    // perform insertion\r\n    var head = this.getHead(fl, sl);\r\n    block.prev = null;\r\n    block.next = head;\r\n    if (head) head.prev = block;\r\n    this.setHead(fl, sl, block);\r\n\r\n    // update first and second level maps\r\n    this.flMap |= (1 << fl);\r\n    this.setSLMap(fl, this.getSLMap(fl) | (1 << sl));\r\n  }\r\n\r\n  /**\r\n   * Removes a free block from FL/SL maps. Does not alter left/jump because it\r\n   * is likely that splitting is performed afterwards, invalidating any changes\r\n   * again.\r\n   */\r\n  private remove(block: Block): void {\r\n    var blockInfo = block.info;\r\n    assert(blockInfo & FREE); // must be free\r\n    var size = blockInfo & ~TAGS;\r\n    assert(size >= Block.MIN_SIZE && size < Block.MAX_SIZE); // must be valid\r\n\r\n    // mapping_insert\r\n    var fl: usize, sl: u32;\r\n    if (size < SB_SIZE) {\r\n      fl = 0;\r\n      sl = <u32>(size / AL_SIZE);\r\n    } else {\r\n      fl = fls<usize>(size);\r\n      sl = <u32>((size >> (fl - SL_BITS)) ^ (1 << SL_BITS));\r\n      fl -= SB_BITS - 1;\r\n    }\r\n\r\n    // link previous and next free block\r\n    var prev = block.prev;\r\n    var next = block.next;\r\n    if (prev) prev.next = next;\r\n    if (next) next.prev = prev;\r\n\r\n    // update head if we are removing it\r\n    if (block == this.getHead(fl, sl)) {\r\n      this.setHead(fl, sl, next);\r\n\r\n      // clear second level map if head is empty now\r\n      if (!next) {\r\n        let slMap = this.getSLMap(fl);\r\n        this.setSLMap(fl, slMap &= ~(1 << sl));\r\n\r\n        // clear first level map if second level is empty now\r\n        if (!slMap) this.flMap &= ~(1 << fl);\r\n      }\r\n    }\r\n  }\r\n\r\n  /** Searches for a free block of at least the specified size. */\r\n  search(size: usize): Block | null {\r\n    assert(size >= Block.MIN_SIZE && size < Block.MAX_SIZE);\r\n\r\n    // mapping_search\r\n    var fl: usize, sl: u32;\r\n    if (size < SB_SIZE) {\r\n      fl = 0;\r\n      sl = <u32>(size / AL_SIZE);\r\n    } else {\r\n      // (*) size += (1 << (fls<usize>(size) - SL_BITS)) - 1;\r\n      fl = fls<usize>(size);\r\n      sl = <u32>((size >> (fl - SL_BITS)) ^ (1 << SL_BITS));\r\n      fl -= SB_BITS - 1;\r\n      // (*) instead of rounding up, use next second level list for better fit\r\n      if (sl < SL_SIZE - 1) ++sl;\r\n      else ++fl, sl = 0;\r\n    }\r\n\r\n    // search second level\r\n    var slMap = this.getSLMap(fl) & (~0 << sl);\r\n    var head: Block | null;\r\n    if (!slMap) {\r\n      // search next larger first level\r\n      let flMap = this.flMap & (~0 << (fl + 1));\r\n      if (!flMap) {\r\n        head = null;\r\n      } else {\r\n        fl = ffs<usize>(flMap);\r\n        slMap = assert(this.getSLMap(fl)); // can't be zero if fl points here\r\n        head = this.getHead(fl, ffs<u32>(slMap));\r\n      }\r\n    } else {\r\n      head = this.getHead(fl, ffs<u32>(slMap));\r\n    }\r\n    return head;\r\n  }\r\n\r\n  /** Links a free left with its right block in memory. */\r\n  private setJump(left: Block, right: Block): void {\r\n    assert(left.info & FREE);       // must be free\r\n    assert(left.right == right);    // right block must match\r\n    assert(right.info & LEFT_FREE); // right block must be tagged as LEFT_FREE\r\n    store<Block>(\r\n      changetype<usize>(right) - sizeof<usize>()\r\n    , left); // last word in left block's (free) data region\r\n  }\r\n\r\n  /**\r\n   * Uses the specified free block, removing it from internal maps and\r\n   * splitting it if possible, and returns its data pointer.\r\n   */\r\n  use(block: Block, size: usize): usize {\r\n    var blockInfo = block.info;\r\n    assert(blockInfo & FREE); // must be free so we can use it\r\n    assert(size >= Block.MIN_SIZE && size < Block.MAX_SIZE); // must be valid\r\n    assert(!(size & AL_MASK)); // size must be aligned so the new block is\r\n\r\n    this.remove(block);\r\n\r\n    // split if the block can hold another MIN_SIZE block\r\n    var remaining = (blockInfo & ~TAGS) - size;\r\n    if (remaining >= Block.INFO + Block.MIN_SIZE) {\r\n      block.info = size | (blockInfo & LEFT_FREE); // also discards FREE\r\n\r\n      let spare = changetype<Block>(\r\n        changetype<usize>(block) + Block.INFO + size\r\n      );\r\n      spare.info = (remaining - Block.INFO) | FREE; // not LEFT_FREE\r\n      this.insert(spare); // also sets jump\r\n\r\n    // otherwise tag block as no longer FREE and right as no longer LEFT_FREE\r\n    } else {\r\n      block.info = blockInfo & ~FREE;\r\n      let right: Block = assert(block.right); // can't be null (tail)\r\n      right.info &= ~LEFT_FREE;\r\n    }\r\n\r\n    return changetype<usize>(block) + Block.INFO;\r\n  }\r\n\r\n  /** Adds more memory to the pool. */\r\n  addMemory(start: usize, end: usize): bool {\r\n    assert(start <= end);\r\n    assert(!(start & AL_MASK)); // must be aligned\r\n    assert(!(end & AL_MASK)); // must be aligned\r\n\r\n    var tailRef = this.tailRef;\r\n    var tailInfo: usize = 0;\r\n    if (tailRef) {\r\n      assert(start >= tailRef + sizeof<usize>()); // starts after tail\r\n\r\n      // merge with current tail if adjacent\r\n      if (start - Block.INFO == tailRef) {\r\n        start -= Block.INFO;\r\n        tailInfo = changetype<Block>(tailRef).info;\r\n      }\r\n\r\n    } else {\r\n      assert(start >= changetype<usize>(this) + Root.SIZE); // starts after root\r\n    }\r\n\r\n    // check if size is large enough for a free block and the tail block\r\n    var size = end - start;\r\n    if (size < Block.INFO + Block.MIN_SIZE + Block.INFO) {\r\n      return false;\r\n    }\r\n\r\n    // left size is total minus its own and the zero-length tail's header\r\n    var leftSize = size - 2 * Block.INFO;\r\n    var left = changetype<Block>(start);\r\n    left.info = leftSize | FREE | (tailInfo & LEFT_FREE);\r\n    left.prev = null;\r\n    left.next = null;\r\n\r\n    // tail is a zero-length used block\r\n    var tail = changetype<Block>(start + size - Block.INFO);\r\n    tail.info = 0 | LEFT_FREE;\r\n    this.tailRef = changetype<usize>(tail);\r\n\r\n    this.insert(left); // also merges with free left before tail / sets jump\r\n\r\n    return true;\r\n  }\r\n}\r\n\r\n/** Determines the first (LSB to MSB) set bit's index of a word. */\r\nfunction ffs<T>(word: T): T {\r\n  assert(word != 0); // word cannot be 0\r\n  return ctz<T>(word);  // differs from ffs only for 0\r\n}\r\n\r\n/** Determines the last (LSB to MSB) set bit's index of a word. */\r\nfunction fls<T>(word: T): T {\r\n  assert(word != 0); // word cannot be 0\r\n  const inv: T = (sizeof<T>() << 3) - 1;\r\n  return inv - clz<T>(word);\r\n}\r\n\r\n/** Reference to the initialized {@link Root} structure, once initialized. */\r\nvar ROOT: Root = changetype<Root>(0);\r\n\r\n// Memory allocator interface\r\n\r\n/** Allocates a chunk of memory. */\r\n@global export function __memory_allocate(size: usize): usize {\r\n\r\n  // initialize if necessary\r\n  var root = ROOT;\r\n  if (!root) {\r\n    let rootOffset = (HEAP_BASE + AL_MASK) & ~AL_MASK;\r\n    let pagesBefore = memory.size();\r\n    let pagesNeeded = <i32>((((rootOffset + Root.SIZE) + 0xffff) & ~0xffff) >>> 16);\r\n    if (pagesNeeded > pagesBefore && memory.grow(pagesNeeded - pagesBefore) < 0) unreachable();\r\n    ROOT = root = changetype<Root>(rootOffset);\r\n    root.tailRef = 0;\r\n    root.flMap = 0;\r\n    for (let fl: usize = 0; fl < FL_BITS; ++fl) {\r\n      root.setSLMap(fl, 0);\r\n      for (let sl: u32 = 0; sl < SL_SIZE; ++sl) {\r\n        root.setHead(fl, sl, null);\r\n      }\r\n    }\r\n    root.addMemory((rootOffset + Root.SIZE + AL_MASK) & ~AL_MASK, memory.size() << 16);\r\n  }\r\n\r\n  // search for a suitable block\r\n  if (size > Block.MAX_SIZE) unreachable();\r\n\r\n  // 32-bit MAX_SIZE is 1 << 30 and itself aligned, hence the following can't overflow MAX_SIZE\r\n  size = max<usize>((size + AL_MASK) & ~AL_MASK, Block.MIN_SIZE);\r\n\r\n  var block = root.search(size);\r\n  if (!block) {\r\n\r\n    // request more memory\r\n    let pagesBefore = memory.size();\r\n    let pagesNeeded = <i32>(((size + 0xffff) & ~0xffff) >>> 16);\r\n    let pagesWanted = max(pagesBefore, pagesNeeded); // double memory\r\n    if (memory.grow(pagesWanted) < 0) {\r\n      if (memory.grow(pagesNeeded) < 0) {\r\n        unreachable(); // out of memory\r\n      }\r\n    }\r\n    let pagesAfter = memory.size();\r\n    root.addMemory(<usize>pagesBefore << 16, <usize>pagesAfter << 16);\r\n    block = assert(root.search(size)); // must be found now\r\n  }\r\n\r\n  assert((block.info & ~TAGS) >= size);\r\n  return root.use(<Block>block, size);\r\n}\r\n\r\n/** Frees the chunk of memory at the specified address. */\r\n@global export function __memory_free(data: usize): void {\r\n  if (data) {\r\n    let root = ROOT;\r\n    if (root) {\r\n      let block = changetype<Block>(data - Block.INFO);\r\n      let blockInfo = block.info;\r\n      assert(!(blockInfo & FREE)); // must be used\r\n      block.info = blockInfo | FREE;\r\n      root.insert(changetype<Block>(data - Block.INFO));\r\n    }\r\n  }\r\n}\r\n\r\n@global export function __memory_reset(): void {\r\n  unreachable();\r\n}\r\n","import { memcmp, memmove, memset } from \"./internal/memory\";\r\n\r\n@builtin export declare const HEAP_BASE: usize; // tslint:disable-line\r\n\r\n/* tslint:disable */\r\n\r\nexport namespace memory {\r\n\r\n  @builtin export declare function size(): i32;\r\n\r\n  @builtin export declare function grow(pages: i32): i32;\r\n\r\n  @inline export function fill(dest: usize, c: u8, n: usize): void { // see: musl/src/string/memset\r\n    if (isDefined(__memory_fill)) { __memory_fill(dest, c, n); return; }\r\n    memset(dest, c, n);\r\n  }\r\n\r\n  @inline export function copy(dest: usize, src: usize, n: usize): void { // see: musl/src/string/memmove.c\r\n    if (isDefined(__memory_copy)) { __memory_copy(dest, src, n); return; }\r\n    memmove(dest, src, n);\r\n  }\r\n\r\n  @inline export function compare(vl: usize, vr: usize, n: usize): i32 { // see: musl/src/string/memcmp.c\r\n    if (isDefined(__memory_compare)) return __memory_compare(vl, vr, n);\r\n    return memcmp(vl, vr, n);\r\n  }\r\n\r\n  // Passive segments\r\n\r\n  // export function init(segmentIndex: u32, srcOffset: usize, dstOffset: usize, n: usize): void {\r\n  //   __memory_init(segmentIndex, srcOffset, dstOffset);\r\n  // }\r\n\r\n  // export function drop(segmentIndex: u32): void {\r\n  //   __memory_drop(segmentIndex);\r\n  // }\r\n\r\n  // Allocator\r\n\r\n  @inline export function allocate(size: usize): usize {\r\n    if (isDefined(__memory_allocate)) return __memory_allocate(size);\r\n    WARNING(\"Calling 'memory.allocate' requires a memory manager to be present.\");\r\n    return <usize>unreachable();\r\n  }\r\n\r\n  @inline export function free(ptr: usize): void {\r\n    if (isDefined(__memory_free)) { __memory_free(ptr); return; }\r\n    WARNING(\"Calling 'memory.free' requires a memory manager to be present.\");\r\n    unreachable();\r\n  }\r\n\r\n  @inline export function reset(): void {\r\n    if (isDefined(__memory_reset)) { __memory_reset(); return; }\r\n    unreachable();\r\n  }\r\n}\r\n","import {\r\n  HEADER_SIZE as HEADER_SIZE_AB\r\n} from \"./internal/arraybuffer\";\r\n\r\nimport {\r\n  HASH\r\n} from \"./internal/hash\";\r\n\r\n// A deterministic hash map based on CloseTable from https://github.com/jorendorff/dht\r\n\r\nconst INITIAL_CAPACITY = 4;\r\nconst FILL_FACTOR: f64 = 8 / 3;\r\nconst FREE_FACTOR: f64 = 3 / 4;\r\n\r\n/** Structure of a map entry. */\r\n@unmanaged class MapEntry<K,V> {\r\n  key: K;\r\n  value: V;\r\n  taggedNext: usize; // LSB=1 indicates EMPTY\r\n}\r\n\r\n/** Empty bit. */\r\nconst EMPTY: usize = 1 << 0;\r\n\r\n/** Size of a bucket. */\r\nconst BUCKET_SIZE = sizeof<usize>();\r\n\r\n/** Computes the alignment of an entry. */\r\n@inline function ENTRY_ALIGN<K,V>(): usize {\r\n  // can align to 4 instead of 8 if 32-bit and K/V is <= 32-bits\r\n  const maxkv = sizeof<K>() > sizeof<V>() ? sizeof<K>() : sizeof<V>();\r\n  const align = (maxkv > sizeof<usize>() ? maxkv : sizeof<usize>()) - 1;\r\n  return align;\r\n}\r\n\r\n/** Computes the aligned size of an entry. */\r\n@inline function ENTRY_SIZE<K,V>(): usize {\r\n  const align = ENTRY_ALIGN<K,V>();\r\n  const size = (offsetof<MapEntry<K,V>>() + align) & ~align;\r\n  return size;\r\n}\r\n\r\nexport class Map<K,V> {\r\n\r\n  // buckets holding references to the respective first entry within\r\n  private buckets: ArrayBuffer; // usize[bucketsMask + 1]\r\n  private bucketsMask: u32;\r\n\r\n  // entries in insertion order\r\n  private entries: ArrayBuffer; // MapEntry<K,V>[entriesCapacity]\r\n  private entriesCapacity: i32;\r\n  private entriesOffset: i32;\r\n  private entriesCount: i32;\r\n\r\n  get size(): i32 { return this.entriesCount; }\r\n\r\n  constructor() { this.clear(); }\r\n\r\n  clear(): void {\r\n    const bucketsSize = INITIAL_CAPACITY * <i32>BUCKET_SIZE;\r\n    this.buckets = new ArrayBuffer(bucketsSize);\r\n    this.bucketsMask = INITIAL_CAPACITY - 1;\r\n    const entriesSize = INITIAL_CAPACITY * <i32>ENTRY_SIZE<K,V>();\r\n    this.entries = new ArrayBuffer(entriesSize, true);\r\n    this.entriesCapacity = INITIAL_CAPACITY;\r\n    this.entriesOffset = 0;\r\n    this.entriesCount = 0;\r\n  }\r\n\r\n  private find(key: K, hashCode: u32): MapEntry<K,V> | null {\r\n    var entry = load<MapEntry<K,V>>(\r\n      changetype<usize>(this.buckets) + <usize>(hashCode & this.bucketsMask) * BUCKET_SIZE,\r\n      HEADER_SIZE_AB\r\n    );\r\n    while (entry) {\r\n      if (!(entry.taggedNext & EMPTY) && entry.key == key) return entry;\r\n      entry = changetype<MapEntry<K,V>>(entry.taggedNext & ~EMPTY);\r\n    }\r\n    return null;\r\n  }\r\n\r\n  has(key: K): bool {\r\n    return this.find(key, HASH<K>(key)) !== null;\r\n  }\r\n\r\n  get(key: K): V {\r\n    var entry = this.find(key, HASH<K>(key));\r\n    return entry ? entry.value : <V>unreachable();\r\n  }\r\n\r\n  set(key: K, value: V): void {\r\n    var hashCode = HASH<K>(key);\r\n    var entry = this.find(key, hashCode);\r\n    if (entry) {\r\n      entry.value = value;\r\n    } else {\r\n      // check if rehashing is necessary\r\n      if (this.entriesOffset == this.entriesCapacity) {\r\n        this.rehash(\r\n          this.entriesCount < <i32>(this.entriesCapacity * FREE_FACTOR)\r\n            ?  this.bucketsMask           // just rehash if 1/4+ entries are empty\r\n            : (this.bucketsMask << 1) | 1 // grow capacity to next 2^N\r\n        );\r\n      }\r\n      // append new entry\r\n      let entries = this.entries;\r\n      entry = changetype<MapEntry<K,V>>(\r\n        changetype<usize>(entries) + HEADER_SIZE_AB + this.entriesOffset++ * ENTRY_SIZE<K,V>()\r\n      );\r\n      entry.key = key;\r\n      entry.value = value;\r\n      ++this.entriesCount;\r\n      // link with previous entry in bucket\r\n      let bucketPtrBase = changetype<usize>(this.buckets) + <usize>(hashCode & this.bucketsMask) * BUCKET_SIZE;\r\n      entry.taggedNext = load<usize>(bucketPtrBase, HEADER_SIZE_AB);\r\n      store<usize>(bucketPtrBase, changetype<usize>(entry), HEADER_SIZE_AB);\r\n      if (isManaged<K>()) __gc_link(changetype<usize>(this), changetype<usize>(key)); // tslint:disable-line\r\n      if (isManaged<V>()) __gc_link(changetype<usize>(this), changetype<usize>(value)); // tslint:disable-line\r\n    }\r\n  }\r\n\r\n  delete(key: K): bool {\r\n    var entry = this.find(key, HASH<K>(key));\r\n    if (!entry) return false;\r\n    entry.taggedNext |= EMPTY;\r\n    --this.entriesCount;\r\n    // check if rehashing is appropriate\r\n    var halfBucketsMask = this.bucketsMask >> 1;\r\n    if (\r\n      halfBucketsMask + 1 >= max<u32>(INITIAL_CAPACITY, this.entriesCount) &&\r\n      this.entriesCount < <i32>(this.entriesCapacity * FREE_FACTOR)\r\n    ) this.rehash(halfBucketsMask);\r\n    return true;\r\n  }\r\n\r\n  private rehash(newBucketsMask: u32): void {\r\n    var newBucketsCapacity = <i32>(newBucketsMask + 1);\r\n    var newBuckets = new ArrayBuffer(newBucketsCapacity * <i32>BUCKET_SIZE);\r\n    var newEntriesCapacity = <i32>(newBucketsCapacity * FILL_FACTOR);\r\n    var newEntries = new ArrayBuffer(newEntriesCapacity * <i32>ENTRY_SIZE<K,V>(), true);\r\n\r\n    // copy old entries to new entries\r\n    var oldPtr = changetype<usize>(this.entries) + HEADER_SIZE_AB;\r\n    var oldEnd = oldPtr + <usize>this.entriesOffset * ENTRY_SIZE<K,V>();\r\n    var newPtr = changetype<usize>(newEntries) + HEADER_SIZE_AB;\r\n    while (oldPtr != oldEnd) {\r\n      let oldEntry = changetype<MapEntry<K,V>>(oldPtr);\r\n      if (!(oldEntry.taggedNext & EMPTY)) {\r\n        let newEntry = changetype<MapEntry<K,V>>(newPtr);\r\n        newEntry.key = oldEntry.key;\r\n        newEntry.value = oldEntry.value;\r\n        let newBucketIndex = HASH<K>(oldEntry.key) & newBucketsMask;\r\n        let newBucketPtrBase = changetype<usize>(newBuckets) + <usize>newBucketIndex * BUCKET_SIZE;\r\n        newEntry.taggedNext = load<usize>(newBucketPtrBase, HEADER_SIZE_AB);\r\n        store<usize>(newBucketPtrBase, newPtr, HEADER_SIZE_AB);\r\n        newPtr += ENTRY_SIZE<K,V>();\r\n      }\r\n      oldPtr += ENTRY_SIZE<K,V>();\r\n    }\r\n\r\n    this.buckets = newBuckets;\r\n    this.bucketsMask = newBucketsMask;\r\n    this.entries = newEntries;\r\n    this.entriesCapacity = newEntriesCapacity;\r\n    this.entriesOffset = this.entriesCount;\r\n  }\r\n\r\n  toString(): string {\r\n    return \"[object Map]\";\r\n  }\r\n\r\n  private __gc(): void {\r\n    __gc_mark(changetype<usize>(this.buckets)); // tslint:disable-line\r\n    var entries = this.entries;\r\n    __gc_mark(changetype<usize>(entries)); // tslint:disable-line\r\n    if (isManaged<K>() || isManaged<V>()) {\r\n      let offset: usize = 0;\r\n      let end: usize = this.entriesOffset * ENTRY_SIZE<K,V>();\r\n      while (offset < end) {\r\n        let entry = changetype<MapEntry<K,V>>(\r\n          changetype<usize>(entries) + HEADER_SIZE_AB + offset * ENTRY_SIZE<K,V>()\r\n        );\r\n        if (!(entry.taggedNext & EMPTY)) {\r\n          if (isManaged<K>()) __gc_mark(changetype<usize>(entry.key)); // tslint:disable-line\r\n          if (isManaged<V>()) __gc_mark(changetype<usize>(entry.value)); // tslint:disable-line\r\n        }\r\n        offset += ENTRY_SIZE<K,V>();\r\n      }\r\n    }\r\n  }\r\n}\r\n","import {\r\n  HEADER_SIZE,\r\n  MAX_BLENGTH,\r\n  allocateUnsafe\r\n} from \"./internal/arraybuffer\";\r\n\r\n@sealed\r\nexport class ArrayBuffer {\r\n\r\n  readonly byteLength: i32; // capped to [0, MAX_LENGTH]\r\n\r\n  // @unsafe\r\n  get data(): usize { return changetype<usize>(this) + HEADER_SIZE; }\r\n\r\n  constructor(length: i32, unsafe: bool = false) {\r\n    if (<u32>length > <u32>MAX_BLENGTH) throw new RangeError(\"Invalid array buffer length\");\r\n    var buffer = allocateUnsafe(length);\r\n    if (!unsafe) memory.fill(changetype<usize>(buffer) + HEADER_SIZE, 0, <usize>length);\r\n    return buffer;\r\n  }\r\n\r\n  slice(begin: i32 = 0, end: i32 = MAX_BLENGTH): ArrayBuffer {\r\n    var len = this.byteLength;\r\n    if (begin < 0) begin = max(len + begin, 0);\r\n    else begin = min(begin, len);\r\n    if (end < 0) end = max(len + end, 0);\r\n    else end = min(end, len);\r\n    var newLen = max(end - begin, 0);\r\n    var buffer = allocateUnsafe(newLen);\r\n    memory.copy(changetype<usize>(buffer) + HEADER_SIZE, changetype<usize>(this) + HEADER_SIZE + begin, newLen);\r\n    return buffer;\r\n  }\r\n\r\n  toString(): string {\r\n    return \"[object ArrayBuffer]\";\r\n  }\r\n}\r\n","import {\r\n  AL_MASK,\r\n  MAX_SIZE_32\r\n } from \"./allocator\";\r\n\r\n/** Size of an ArrayBuffer header. */\r\nexport const HEADER_SIZE: usize = (offsetof<ArrayBuffer>() + AL_MASK) & ~AL_MASK;\r\n/** Maximum byte length of an ArrayBuffer. */\r\nexport const MAX_BLENGTH: i32 = <i32>MAX_SIZE_32 - HEADER_SIZE;\r\n\r\nfunction computeSize(byteLength: i32): usize {\r\n  // round up to power of 2, with HEADER_SIZE=8:\r\n  // 0            -> 2^3  = 8\r\n  // 1..8         -> 2^4  = 16\r\n  // 9..24        -> 2^5  = 32\r\n  // ...\r\n  // MAX_LENGTH   -> 2^30 = 0x40000000 (MAX_SIZE_32)\r\n  return <usize>1 << <usize>(<u32>32 - clz<u32>(byteLength + HEADER_SIZE - 1));\r\n}\r\n\r\n// Low-level utility\r\n\r\nfunction __gc(ref: usize): void {}\r\n\r\nexport function allocateUnsafe(byteLength: i32): ArrayBuffer {\r\n  assert(<u32>byteLength <= <u32>MAX_BLENGTH);\r\n  var buffer: usize;\r\n  if (isManaged<ArrayBuffer>()) {\r\n    buffer = __gc_allocate(computeSize(byteLength), __gc); // tslint:disable-line\r\n  } else {\r\n    buffer = memory.allocate(computeSize(byteLength));\r\n  }\r\n  store<i32>(buffer, byteLength, offsetof<ArrayBuffer>(\"byteLength\"));\r\n  return changetype<ArrayBuffer>(buffer);\r\n}\r\n\r\nexport function reallocateUnsafe(buffer: ArrayBuffer, newByteLength: i32): ArrayBuffer {\r\n  var oldByteLength = buffer.byteLength;\r\n  if (newByteLength > oldByteLength) {\r\n    assert(newByteLength <= MAX_BLENGTH);\r\n    if (newByteLength <= <i32>(computeSize(oldByteLength) - HEADER_SIZE)) { // fast path: zero out additional space\r\n      store<i32>(changetype<usize>(buffer), newByteLength, offsetof<ArrayBuffer>(\"byteLength\"));\r\n    } else { // slow path: copy to new buffer\r\n      let newBuffer = allocateUnsafe(newByteLength);\r\n      memory.copy(\r\n        changetype<usize>(newBuffer) + HEADER_SIZE,\r\n        changetype<usize>(buffer) + HEADER_SIZE,\r\n        <usize>oldByteLength\r\n      );\r\n      if (!isManaged<ArrayBuffer>()) {\r\n        memory.free(changetype<usize>(buffer));\r\n      }\r\n      buffer = newBuffer;\r\n    }\r\n    memory.fill(\r\n      changetype<usize>(buffer) + HEADER_SIZE + <usize>oldByteLength,\r\n      0,\r\n      <usize>(newByteLength - oldByteLength)\r\n    );\r\n  } else if (newByteLength < oldByteLength) { // fast path: override size\r\n    // TBD: worth to copy and release if size is significantly less than before?\r\n    assert(newByteLength >= 0);\r\n    store<i32>(changetype<usize>(buffer), newByteLength, offsetof<ArrayBuffer>(\"byteLength\"));\r\n  }\r\n  return buffer;\r\n}\r\n\r\n// The helpers below use two different types in order to emit loads and stores that load respectively\r\n// store one type to/from memory while returning/taking the desired output/input type. This allows to\r\n// emit instructions like\r\n//\r\n// * `i32.load8` ^= `<i32>load<i8>(...)` that reads an i8 but returns an i32, or\r\n// * `i64.load32_s` ^= `<i64>load<i32>(...)`) that reads a 32-bit as a 64-bit integer\r\n//\r\n// without having to emit an additional instruction for conversion purposes. The second parameter\r\n// can be omitted for references and other loads and stores that simply return the exact type.\r\n\r\n@inline export function LOAD<T,TOut = T>(buffer: ArrayBuffer, index: i32, byteOffset: i32 = 0): TOut {\r\n  return <TOut>load<T>(changetype<usize>(buffer) + (<usize>index << alignof<T>()) + <usize>byteOffset, HEADER_SIZE);\r\n}\r\n\r\n@inline export function STORE<T,TIn = T>(buffer: ArrayBuffer, index: i32, value: TIn, byteOffset: i32 = 0): void {\r\n  store<T>(changetype<usize>(buffer) + (<usize>index << alignof<T>()) + <usize>byteOffset, value, HEADER_SIZE);\r\n}\r\n","// this function will go away once `memory.copy` becomes an intrinsic\r\nexport function memcpy(dest: usize, src: usize, n: usize): void { // see: musl/src/string/memcpy.c\r\n  var w: u32, x: u32;\r\n\r\n  // copy 1 byte each until src is aligned to 4 bytes\r\n  while (n && (src & 3)) {\r\n    store<u8>(dest++, load<u8>(src++));\r\n    n--;\r\n  }\r\n\r\n  // if dst is aligned to 4 bytes as well, copy 4 bytes each\r\n  if ((dest & 3) == 0) {\r\n    while (n >= 16) {\r\n      store<u32>(dest     , load<u32>(src     ));\r\n      store<u32>(dest +  4, load<u32>(src +  4));\r\n      store<u32>(dest +  8, load<u32>(src +  8));\r\n      store<u32>(dest + 12, load<u32>(src + 12));\r\n      src += 16; dest += 16; n -= 16;\r\n    }\r\n    if (n & 8) {\r\n      store<u32>(dest    , load<u32>(src    ));\r\n      store<u32>(dest + 4, load<u32>(src + 4));\r\n      dest += 8; src += 8;\r\n    }\r\n    if (n & 4) {\r\n      store<u32>(dest, load<u32>(src));\r\n      dest += 4; src += 4;\r\n    }\r\n    if (n & 2) { // drop to 2 bytes each\r\n      store<u16>(dest, load<u16>(src));\r\n      dest += 2; src += 2;\r\n    }\r\n    if (n & 1) { // drop to 1 byte\r\n      store<u8>(dest++, load<u8>(src++));\r\n    }\r\n    return;\r\n  }\r\n\r\n  // if dst is not aligned to 4 bytes, use alternating shifts to copy 4 bytes each\r\n  // doing shifts if faster when copying enough bytes (here: 32 or more)\r\n  if (n >= 32) {\r\n    switch (dest & 3) {\r\n      // known to be != 0\r\n      case 1: {\r\n        w = load<u32>(src);\r\n        store<u8>(dest++, load<u8>(src++));\r\n        store<u8>(dest++, load<u8>(src++));\r\n        store<u8>(dest++, load<u8>(src++));\r\n        n -= 3;\r\n        while (n >= 17) {\r\n          x = load<u32>(src + 1);\r\n          store<u32>(dest, w >> 24 | x << 8);\r\n          w = load<u32>(src + 5);\r\n          store<u32>(dest + 4, x >> 24 | w << 8);\r\n          x = load<u32>(src + 9);\r\n          store<u32>(dest + 8, w >> 24 | x << 8);\r\n          w = load<u32>(src + 13);\r\n          store<u32>(dest + 12, x >> 24 | w << 8);\r\n          src += 16; dest += 16; n -= 16;\r\n        }\r\n        break;\r\n      }\r\n      case 2: {\r\n        w = load<u32>(src);\r\n        store<u8>(dest++, load<u8>(src++));\r\n        store<u8>(dest++, load<u8>(src++));\r\n        n -= 2;\r\n        while (n >= 18) {\r\n          x = load<u32>(src + 2);\r\n          store<u32>(dest, w >> 16 | x << 16);\r\n          w = load<u32>(src + 6);\r\n          store<u32>(dest + 4, x >> 16 | w << 16);\r\n          x = load<u32>(src + 10);\r\n          store<u32>(dest + 8, w >> 16 | x << 16);\r\n          w = load<u32>(src + 14);\r\n          store<u32>(dest + 12, x >> 16 | w << 16);\r\n          src += 16; dest += 16; n -= 16;\r\n        }\r\n        break;\r\n      }\r\n      case 3: {\r\n        w = load<u32>(src);\r\n        store<u8>(dest++, load<u8>(src++));\r\n        n -= 1;\r\n        while (n >= 19) {\r\n          x = load<u32>(src + 3);\r\n          store<u32>(dest, w >> 8 | x << 24);\r\n          w = load<u32>(src + 7);\r\n          store<u32>(dest + 4, x >> 8 | w << 24);\r\n          x = load<u32>(src + 11);\r\n          store<u32>(dest + 8, w >> 8 | x << 24);\r\n          w = load<u32>(src + 15);\r\n          store<u32>(dest + 12, x >> 8 | w << 24);\r\n          src += 16; dest += 16; n -= 16;\r\n        }\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  // copy remaining bytes one by one\r\n  if (n & 16) {\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n  }\r\n  if (n & 8) {\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n  }\r\n  if (n & 4) {\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n  }\r\n  if (n & 2) {\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n  }\r\n  if (n & 1) {\r\n    store<u8>(dest++, load<u8>(src++));\r\n  }\r\n}\r\n\r\n// this function will go away once `memory.copy` becomes an intrinsic\r\nexport function memmove(dest: usize, src: usize, n: usize): void { // see: musl/src/string/memmove.c\r\n  if (dest === src) return;\r\n  if (src + n <= dest || dest + n <= src) {\r\n    memcpy(dest, src, n);\r\n    return;\r\n  }\r\n  if (dest < src) {\r\n    if ((src & 7) == (dest & 7)) {\r\n      while (dest & 7) {\r\n        if (!n) return;\r\n        --n;\r\n        store<u8>(dest++, load<u8>(src++));\r\n      }\r\n      while (n >= 8) {\r\n        store<u64>(dest, load<u64>(src));\r\n        n    -= 8;\r\n        dest += 8;\r\n        src  += 8;\r\n      }\r\n    }\r\n    while (n) {\r\n      store<u8>(dest++, load<u8>(src++));\r\n      --n;\r\n    }\r\n  } else {\r\n    if ((src & 7) == (dest & 7)) {\r\n      while ((dest + n) & 7) {\r\n        if (!n) return;\r\n        store<u8>(dest + --n, load<u8>(src + n));\r\n      }\r\n      while (n >= 8) {\r\n        n -= 8;\r\n        store<u64>(dest + n, load<u64>(src + n));\r\n      }\r\n    }\r\n    while (n) {\r\n      store<u8>(dest + --n, load<u8>(src + n));\r\n    }\r\n  }\r\n}\r\n\r\n// this function will go away once `memory.fill` becomes an intrinsic\r\nexport function memset(dest: usize, c: u8, n: usize): void { // see: musl/src/string/memset\r\n\r\n  // fill head and tail with minimal branching\r\n  if (!n) return;\r\n  store<u8>(dest, c);\r\n  store<u8>(dest + n - 1, c);\r\n  if (n <= 2) return;\r\n\r\n  store<u8>(dest + 1, c);\r\n  store<u8>(dest + 2, c);\r\n  store<u8>(dest + n - 2, c);\r\n  store<u8>(dest + n - 3, c);\r\n  if (n <= 6) return;\r\n  store<u8>(dest + 3, c);\r\n  store<u8>(dest + n - 4, c);\r\n  if (n <= 8) return;\r\n\r\n  // advance pointer to align it at 4-byte boundary\r\n  var k: usize = -dest & 3;\r\n  dest += k;\r\n  n -= k;\r\n  n &= -4;\r\n\r\n  var c32: u32 = <u32>-1 / 255 * c;\r\n\r\n  // fill head/tail up to 28 bytes each in preparation\r\n  store<u32>(dest, c32);\r\n  store<u32>(dest + n - 4, c32);\r\n  if (n <= 8) return;\r\n  store<u32>(dest + 4, c32);\r\n  store<u32>(dest + 8, c32);\r\n  store<u32>(dest + n - 12, c32);\r\n  store<u32>(dest + n - 8, c32);\r\n  if (n <= 24) return;\r\n  store<u32>(dest + 12, c32);\r\n  store<u32>(dest + 16, c32);\r\n  store<u32>(dest + 20, c32);\r\n  store<u32>(dest + 24, c32);\r\n  store<u32>(dest + n - 28, c32);\r\n  store<u32>(dest + n - 24, c32);\r\n  store<u32>(dest + n - 20, c32);\r\n  store<u32>(dest + n - 16, c32);\r\n\r\n  // align to a multiple of 8\r\n  k = 24 + (dest & 4);\r\n  dest += k;\r\n  n -= k;\r\n\r\n  // copy 32 bytes each\r\n  var c64: u64 = <u64>c32 | (<u64>c32 << 32);\r\n  while (n >= 32) {\r\n    store<u64>(dest, c64);\r\n    store<u64>(dest + 8, c64);\r\n    store<u64>(dest + 16, c64);\r\n    store<u64>(dest + 24, c64);\r\n    n -= 32;\r\n    dest += 32;\r\n  }\r\n}\r\n\r\nexport function memcmp(vl: usize, vr: usize, n: usize): i32 { // see: musl/src/string/memcmp.c\r\n  if (vl == vr) return 0;\r\n  while (n != 0 && load<u8>(vl) == load<u8>(vr)) {\r\n    n--; vl++; vr++;\r\n  }\r\n  return n ? <i32>load<u8>(vl) - <i32>load<u8>(vr) : 0;\r\n}\r\n","import { Image } from \"./Image\";\r\n\r\nexport var TextureMap: Map<string, Image> = new Map<string, Image>();\r\n\r\nexport function injectImage(name: string): Image {\r\n  var image: Image = new Image();\r\n  image._index = Image.index++;\r\n  TextureMap.set(name, image);\r\n  return image;\r\n}\r\n\r\nexport function imageLoaded(img: Image, width: i32, height: i32): void {\r\n  img._loaded = 1;\r\n  img.width = width;\r\n  img.height = height;\r\n}\r\n","import { create_image } from \"../linked\";\r\n\r\nexport class Image {\r\n  public static index: i32 = 0;\r\n  public _index: i32 = 0;\r\n  public _loaded: i32 = 0;\r\n  public width: i32 = 0;\r\n  public height: i32 = 0;\r\n  private _src: string = \"\";\r\n\r\n  public get src(): string {\r\n    return this._src;\r\n  }\r\n\r\n  public set src(value: string) {\r\n    if (this._src == value) return;\r\n    this._index = Image.index++;\r\n    create_image(this, value);\r\n    this._src = value;\r\n  }\r\n\r\n  @inline\r\n  get loaded(): bool {\r\n    return this._loaded == 1;\r\n  }\r\n}\r\n","import {\r\n  HEADER_SIZE\r\n} from \"./string\";\r\n\r\n/** Computes the 32-bit hash of a value of any type. */\r\n@inline\r\nexport function HASH<T>(key: T): u32 {\r\n  // branch-level tree-shaking makes this a `(return (call ...))`\r\n  if (isString(key)) {\r\n    return hashStr(key);\r\n  } else if (isReference<T>()) {\r\n    if (sizeof<T>() == 4) return hash32(changetype<u32>(key));\r\n    if (sizeof<T>() == 8) return hash64(changetype<u64>(key));\r\n  } else if (isFloat<T>()) {\r\n    if (sizeof<T>() == 4) return hash32(reinterpret<u32>(key));\r\n    if (sizeof<T>() == 8) return hash64(reinterpret<u64>(key));\r\n  } else {\r\n    if (sizeof<T>() == 1) return hash8 (<u32>key);\r\n    if (sizeof<T>() == 2) return hash16(<u32>key);\r\n    if (sizeof<T>() == 4) return hash32(<u32>key);\r\n    if (sizeof<T>() == 8) return hash64(<u64>key);\r\n  }\r\n  unreachable();\r\n}\r\n\r\n// FNV-1a 32-bit as a starting point, see: http://isthe.com/chongo/tech/comp/fnv/\r\n\r\nconst FNV_OFFSET: u32 = 2166136261;\r\nconst FNV_PRIME: u32 = 16777619;\r\n\r\nfunction hash8(key: u32): u32 {\r\n  return (FNV_OFFSET ^ key) * FNV_PRIME;\r\n}\r\n\r\nfunction hash16(key: u32): u32 {\r\n  var v = FNV_OFFSET;\r\n  v = (v ^ ( key        & 0xff)) * FNV_PRIME;\r\n  v = (v ^ ( key >>  8        )) * FNV_PRIME;\r\n  return v;\r\n}\r\n\r\nfunction hash32(key: u32): u32 {\r\n  var v = FNV_OFFSET;\r\n  v = (v ^ ( key        & 0xff)) * FNV_PRIME;\r\n  v = (v ^ ((key >>  8) & 0xff)) * FNV_PRIME;\r\n  v = (v ^ ((key >> 16) & 0xff)) * FNV_PRIME;\r\n  v = (v ^ ( key >> 24        )) * FNV_PRIME;\r\n  return v;\r\n}\r\n\r\nfunction hash64(key: u64): u32 {\r\n  var l = <u32> key;\r\n  var h = <u32>(key >>> 32);\r\n  var v = FNV_OFFSET;\r\n  v = (v ^ ( l        & 0xff)) * FNV_PRIME;\r\n  v = (v ^ ((l >>  8) & 0xff)) * FNV_PRIME;\r\n  v = (v ^ ((l >> 16) & 0xff)) * FNV_PRIME;\r\n  v = (v ^ ( l >> 24        )) * FNV_PRIME;\r\n  v = (v ^ ( h        & 0xff)) * FNV_PRIME;\r\n  v = (v ^ ((h >>  8) & 0xff)) * FNV_PRIME;\r\n  v = (v ^ ((h >> 16) & 0xff)) * FNV_PRIME;\r\n  v = (v ^ ( h >> 24        )) * FNV_PRIME;\r\n  return v;\r\n}\r\n\r\nfunction hashStr(key: string): u32 {\r\n  var v = FNV_OFFSET;\r\n  for (let i: usize = 0, k: usize = key.length << 1; i < k; ++i) {\r\n    v = (v ^ <u32>load<u8>(changetype<usize>(key) + i, HEADER_SIZE)) * FNV_PRIME;\r\n  }\r\n  return v;\r\n}\r\n","import { MAX_SIZE_32 } from \"./allocator\";\r\nimport { String } from \"../string\";\r\n\r\n/** Size of a String header. */\r\nexport const HEADER_SIZE = (offsetof<String>() + 1) & ~1; // 2 byte aligned\r\n/** Maximum length of a String. */\r\nexport const MAX_LENGTH = (<i32>MAX_SIZE_32 - HEADER_SIZE) >>> 1;\r\n\r\n// Low-level utility\r\n\r\nfunction __gc(ref: usize): void {}\r\n\r\nexport function allocateUnsafe(length: i32): String {\r\n  assert(length > 0 && length <= MAX_LENGTH);\r\n  var buffer: usize;\r\n  if (isManaged<String>()) {\r\n    buffer = __gc_allocate(HEADER_SIZE + (<usize>length << 1), __gc);  // tslint:disable-line\r\n  } else {\r\n    buffer = memory.allocate(HEADER_SIZE + (<usize>length << 1));\r\n  }\r\n  store<i32>(buffer, length);\r\n  return changetype<String>(buffer);\r\n}\r\n\r\n@inline\r\nexport function freeUnsafe(buffer: String): void {\r\n  if (!isManaged<String>()) {\r\n    assert(buffer);\r\n    memory.free(changetype<usize>(buffer));\r\n  }\r\n}\r\n\r\nexport function copyUnsafe(dest: String, destOffset: usize, src: String, srcOffset: usize, len: usize): void {\r\n  memory.copy(\r\n    changetype<usize>(dest) + (destOffset << 1) + HEADER_SIZE,\r\n    changetype<usize>(src)  + (srcOffset  << 1) + HEADER_SIZE,\r\n    len << 1\r\n  );\r\n}\r\n\r\nexport function compareUnsafe(str1: String, offset1: usize, str2: String, offset2: usize, len: usize): i32 {\r\n  var cmp: i32 = 0;\r\n  var ptr1 = changetype<usize>(str1) + (offset1 << 1);\r\n  var ptr2 = changetype<usize>(str2) + (offset2 << 1);\r\n  while (len && !(cmp = <i32>load<u16>(ptr1, HEADER_SIZE) - <i32>load<u16>(ptr2, HEADER_SIZE))) {\r\n    --len, ptr1 += 2, ptr2 += 2;\r\n  }\r\n  return cmp;\r\n}\r\n\r\nexport function repeatUnsafe(dest: String, destOffset: usize, src: String, count: i32): void {\r\n  var length = src.length;\r\n  if (ASC_SHRINK_LEVEL > 1) {\r\n    let strLen = length << 1;\r\n    let to   = changetype<usize>(dest) + HEADER_SIZE + (destOffset << 1);\r\n    let from = changetype<usize>(src)  + HEADER_SIZE;\r\n    for (let i = 0, len = strLen * count; i < len; i += strLen) {\r\n      memory.copy(to + i, from, strLen);\r\n    }\r\n  } else {\r\n    switch (length) {\r\n      case 0: break;\r\n      case 1: {\r\n        let cc =  load<u16>(changetype<usize>(src), HEADER_SIZE);\r\n        let out = changetype<usize>(dest) + (destOffset << 1);\r\n        for (let i = 0; i < count; ++i) {\r\n          store<u16>(out + (i << 1), cc, HEADER_SIZE);\r\n        }\r\n        break;\r\n      }\r\n      case 2: {\r\n        let cc  = load<u32>(changetype<usize>(src), HEADER_SIZE);\r\n        let out = changetype<usize>(dest) + (destOffset << 1);\r\n        for (let i = 0; i < count; ++i) {\r\n          store<u32>(out + (i << 2), cc, HEADER_SIZE);\r\n        }\r\n        break;\r\n      }\r\n      case 3: {\r\n        let cc1 = load<u32>(changetype<usize>(src), HEADER_SIZE + 0);\r\n        let cc2 = load<u16>(changetype<usize>(src), HEADER_SIZE + 4);\r\n        let out = changetype<usize>(dest) + (destOffset << 1);\r\n        for (let i = 0; i < count; ++i) {\r\n          store<u32>(out + (i << 2), cc1, HEADER_SIZE + 0);\r\n          store<u16>(out + (i << 1), cc2, HEADER_SIZE + 4);\r\n        }\r\n        break;\r\n      }\r\n      case 4: {\r\n        let cc = load<u64>(changetype<usize>(src), HEADER_SIZE);\r\n        let out = changetype<usize>(dest) + (destOffset << 1);\r\n        for (let i = 0; i < count; ++i) {\r\n          store<u64>(out + (i << 3), cc, HEADER_SIZE);\r\n        }\r\n        break;\r\n      }\r\n      default: {\r\n        let strLen = length << 1;\r\n        let to   = changetype<usize>(dest) + HEADER_SIZE + (destOffset << 1);\r\n        let from = changetype<usize>(src)  + HEADER_SIZE;\r\n        for (let i = 0, len = strLen * count; i < len; i += strLen) {\r\n          memory.copy(to + i, from, strLen);\r\n        }\r\n        break;\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n// Helpers\r\n\r\nexport const enum CharCode {\r\n  PLUS = 0x2B,\r\n  MINUS = 0x2D,\r\n  DOT = 0x2E,\r\n  _0 = 0x30,\r\n  _1 = 0x31,\r\n  _2 = 0x32,\r\n  _3 = 0x33,\r\n  _4 = 0x34,\r\n  _5 = 0x35,\r\n  _6 = 0x36,\r\n  _7 = 0x37,\r\n  _8 = 0x38,\r\n  _9 = 0x39,\r\n  A = 0x41,\r\n  B = 0x42,\r\n  E = 0x45,\r\n  N = 0x4E,\r\n  O = 0x4F,\r\n  X = 0x58,\r\n  Z = 0x5a,\r\n  a = 0x61,\r\n  b = 0x62,\r\n  e = 0x65,\r\n  n = 0x6E,\r\n  o = 0x6F,\r\n  x = 0x78,\r\n  z = 0x7A\r\n}\r\n\r\nexport function isWhiteSpaceOrLineTerminator(c: u16): bool {\r\n  switch (c) {\r\n    case 9:    // <TAB>\r\n    case 10:   // <LF>\r\n    case 13:   // <CR>\r\n    case 11:   // <VT>\r\n    case 12:   // <FF>\r\n    case 32:   // <SP>\r\n    case 160:  // <NBSP>\r\n    case 8232: // <LS>\r\n    case 8233: // <PS>\r\n    case 65279: return true; // <ZWNBSP>\r\n    default: return false;\r\n  }\r\n}\r\n\r\n/** Parses a string to an integer (usually), using the specified radix. */\r\nexport function parse<T>(str: String, radix: i32 = 0): T {\r\n  var len: i32 = str.length;\r\n  if (!len) return <T>NaN;\r\n\r\n  var ptr = changetype<usize>(str) /* + HEAD -> offset */;\r\n  var code = <i32>load<u16>(ptr, HEADER_SIZE);\r\n\r\n  // determine sign\r\n  var sign: T;\r\n  if (code == CharCode.MINUS) {\r\n    if (!--len) return <T>NaN;\r\n    code = <i32>load<u16>(ptr += 2, HEADER_SIZE);\r\n    sign = -1;\r\n  } else if (code == CharCode.PLUS) {\r\n    if (!--len) return <T>NaN;\r\n    code = <i32>load<u16>(ptr += 2, HEADER_SIZE);\r\n    sign = 1;\r\n  } else {\r\n    sign = 1;\r\n  }\r\n\r\n  // determine radix\r\n  if (!radix) {\r\n    if (code == CharCode._0 && len > 2) {\r\n      switch (<i32>load<u16>(ptr + 2, HEADER_SIZE)) {\r\n        case CharCode.B:\r\n        case CharCode.b: {\r\n          ptr += 4; len -= 2;\r\n          radix = 2;\r\n          break;\r\n        }\r\n        case CharCode.O:\r\n        case CharCode.o: {\r\n          ptr += 4; len -= 2;\r\n          radix = 8;\r\n          break;\r\n        }\r\n        case CharCode.X:\r\n        case CharCode.x: {\r\n          ptr += 4; len -= 2;\r\n          radix = 16;\r\n          break;\r\n        }\r\n        default: radix = 10;\r\n      }\r\n    } else radix = 10;\r\n  } else if (radix < 2 || radix > 36) {\r\n    return <T>NaN;\r\n  }\r\n\r\n  // calculate value\r\n  var num: T = 0;\r\n  while (len--) {\r\n    code = <i32>load<u16>(ptr, HEADER_SIZE);\r\n    if (code >= CharCode._0 && code <= CharCode._9) {\r\n      code -= CharCode._0;\r\n    } else if (code >= CharCode.A && code <= CharCode.Z) {\r\n      code -= CharCode.A - 10;\r\n    } else if (code >= CharCode.a && code <= CharCode.z) {\r\n      code -= CharCode.a - 10;\r\n    } else break;\r\n    if (code >= radix) break;\r\n    num = (num * radix) + code;\r\n    ptr += 2;\r\n  }\r\n  return sign * num;\r\n}\r\n","import {\r\n  HEADER_SIZE,\r\n  MAX_LENGTH,\r\n  allocateUnsafe,\r\n  compareUnsafe,\r\n  repeatUnsafe,\r\n  copyUnsafe,\r\n  isWhiteSpaceOrLineTerminator,\r\n  CharCode,\r\n  parse\r\n} from \"./internal/string\";\r\n\r\nimport {\r\n  STORE\r\n} from \"./internal/arraybuffer\";\r\n\r\n@sealed\r\nexport class String {\r\n\r\n  readonly length: i32; // capped to [0, MAX_LENGTH]\r\n\r\n  // TODO Add and handle second argument\r\n  static fromCharCode(code: i32): String {\r\n    var out = allocateUnsafe(1);\r\n    store<u16>(\r\n      changetype<usize>(out),\r\n      <u16>code,\r\n      HEADER_SIZE\r\n    );\r\n    return out;\r\n  }\r\n\r\n  static fromCodePoint(code: i32): String {\r\n    assert(<u32>code <= 0x10FFFF);\r\n    var sur = code > 0xFFFF;\r\n    var out = allocateUnsafe(<i32>sur + 1);\r\n    if (!sur) {\r\n      store<u16>(\r\n        changetype<usize>(out),\r\n        <u16>code,\r\n        HEADER_SIZE\r\n      );\r\n    } else {\r\n      code -= 0x10000;\r\n      let hi: u32 = (code >>> 10)  + 0xD800;\r\n      let lo: u32 = (code & 0x3FF) + 0xDC00;\r\n      store<u32>(\r\n        changetype<usize>(out),\r\n        (hi << 16) | lo,\r\n        HEADER_SIZE\r\n      );\r\n    }\r\n    return out;\r\n  }\r\n\r\n  @operator(\"[]\")\r\n  charAt(pos: i32): String {\r\n    assert(this !== null);\r\n\r\n    if (<u32>pos >= <u32>this.length) return changetype<String>(\"\");\r\n\r\n    var out = allocateUnsafe(1);\r\n    store<u16>(\r\n      changetype<usize>(out),\r\n      load<u16>(\r\n        changetype<usize>(this) + (<usize>pos << 1),\r\n        HEADER_SIZE\r\n      ),\r\n      HEADER_SIZE\r\n    );\r\n    return out;\r\n  }\r\n\r\n  charCodeAt(pos: i32): i32 {\r\n    assert(this !== null);\r\n    if (<u32>pos >= <u32>this.length) return -1; // (NaN)\r\n\r\n    return load<u16>(\r\n      changetype<usize>(this) + (<usize>pos << 1),\r\n      HEADER_SIZE\r\n    );\r\n  }\r\n\r\n  codePointAt(pos: i32): i32 {\r\n    assert(this !== null);\r\n    if (<u32>pos >= <u32>this.length) return -1; // (undefined)\r\n\r\n    var first = <i32>load<u16>(\r\n      changetype<usize>(this) + (<usize>pos << 1),\r\n      HEADER_SIZE\r\n    );\r\n    if (first < 0xD800 || first > 0xDBFF || pos + 1 == this.length) {\r\n      return first;\r\n    }\r\n    var second = <i32>load<u16>(\r\n      changetype<usize>(this) + ((<usize>pos + 1) << 1),\r\n      HEADER_SIZE\r\n    );\r\n    if (second < 0xDC00 || second > 0xDFFF) return first;\r\n    return ((first - 0xD800) << 10) + (second - 0xDC00) + 0x10000;\r\n  }\r\n\r\n  @operator(\"+\")\r\n  private static __concat(left: String, right: String): String {\r\n    if (!changetype<usize>(left)) left = changetype<String>(\"null\");\r\n    return left.concat(right);\r\n  }\r\n\r\n  concat(other: String): String {\r\n    assert(this !== null);\r\n    if (other === null) other = changetype<String>(\"null\");\r\n\r\n    var thisLen: isize = this.length;\r\n    var otherLen: isize = other.length;\r\n    var outLen: usize = thisLen + otherLen;\r\n    if (outLen == 0) return changetype<String>(\"\");\r\n    var out = allocateUnsafe(outLen);\r\n    copyUnsafe(out, 0, this, 0, thisLen);\r\n    copyUnsafe(out, thisLen, other, 0, otherLen);\r\n    return out;\r\n  }\r\n\r\n  endsWith(searchString: String, endPosition: i32 = MAX_LENGTH): bool {\r\n    assert(this !== null);\r\n    if (searchString === null) return false;\r\n    var end = min(max(endPosition, 0), this.length);\r\n    var searchLength: isize = searchString.length;\r\n    var start: isize = end - searchLength;\r\n    if (start < 0) return false;\r\n    return !compareUnsafe(this, start, searchString, 0, searchLength);\r\n  }\r\n\r\n  @operator(\"==\")\r\n  private static __eq(left: String, right: String): bool {\r\n    if (left === right) return true;\r\n    if (left === null || right === null) return false;\r\n\r\n    var leftLength = left.length;\r\n    if (leftLength != right.length) return false;\r\n\r\n    return !compareUnsafe(left, 0, right, 0, leftLength);\r\n  }\r\n\r\n  @operator(\"!=\")\r\n  private static __ne(left: String, right: String): bool {\r\n    return !this.__eq(left, right);\r\n  }\r\n\r\n  @operator(\">\")\r\n  private static __gt(left: String, right: String): bool {\r\n    if (left === right || left === null || right === null) return false;\r\n\r\n    var leftLength  = left.length;\r\n    var rightLength = right.length;\r\n\r\n    if (!leftLength)  return false;\r\n    if (!rightLength) return true;\r\n\r\n    var length = <usize>min<i32>(leftLength, rightLength);\r\n    return compareUnsafe(left, 0, right, 0, length) > 0;\r\n  }\r\n\r\n  @operator(\">=\")\r\n  private static __gte(left: String, right: String): bool {\r\n    if (left === right) return true;\r\n    if (left === null || right === null) return false;\r\n\r\n    var leftLength  = left.length;\r\n    var rightLength = right.length;\r\n\r\n    if (!leftLength)  return !rightLength;\r\n    if (!rightLength) return true;\r\n\r\n    var length = <usize>min<i32>(leftLength, rightLength);\r\n    return compareUnsafe(left, 0, right, 0, length) >= 0;\r\n  }\r\n\r\n  @operator(\"<\")\r\n  private static __lt(left: String, right: String): bool {\r\n    if (left === right || left === null || right === null) return false;\r\n\r\n    var leftLength  = left.length;\r\n    var rightLength = right.length;\r\n\r\n    if (!rightLength) return false;\r\n    if (!leftLength)  return true;\r\n\r\n    var length = <usize>min<i32>(leftLength, rightLength);\r\n    return compareUnsafe(left, 0, right, 0, length) < 0;\r\n  }\r\n\r\n  @operator(\"<=\")\r\n  private static __lte(left: String, right: String): bool {\r\n    if (left === right) return true;\r\n    if (left === null || right === null) return false;\r\n\r\n    var leftLength  = left.length;\r\n    var rightLength = right.length;\r\n\r\n    if (!rightLength) return !leftLength;\r\n    if (!leftLength)  return true;\r\n\r\n    var length = <usize>min<i32>(leftLength, rightLength);\r\n    return compareUnsafe(left, 0, right, 0, length) <= 0;\r\n  }\r\n\r\n  @inline\r\n  includes(searchString: String, position: i32 = 0): bool {\r\n    return this.indexOf(searchString, position) != -1;\r\n  }\r\n\r\n  indexOf(searchString: String, fromIndex: i32 = 0): i32 {\r\n    assert(this !== null);\r\n    if (searchString === null) searchString = changetype<String>(\"null\");\r\n\r\n    var searchLen: isize = searchString.length;\r\n    if (!searchLen) return 0;\r\n    var len: isize = this.length;\r\n    if (!len) return -1;\r\n    var start = min<isize>(max<isize>(fromIndex, 0), len);\r\n    len -= searchLen;\r\n    for (let k: isize = start; k <= len; ++k) {\r\n      if (!compareUnsafe(this, k, searchString, 0, searchLen)) return <i32>k;\r\n    }\r\n    return -1;\r\n  }\r\n\r\n  lastIndexOf(searchString: String, fromIndex: i32 = i32.MAX_VALUE): i32 {\r\n    assert(this !== null);\r\n    if (searchString === null) searchString = changetype<String>(\"null\");\r\n\r\n    var len: isize = this.length;\r\n    var searchLen: isize = searchString.length;\r\n    if (!searchLen) return len;\r\n    if (!len) return -1;\r\n    var start = min<isize>(max(fromIndex, 0), len - searchLen);\r\n    for (let k = start; k >= 0; --k) {\r\n      if (!compareUnsafe(this, k, searchString, 0, searchLen)) return <i32>k;\r\n    }\r\n    return -1;\r\n  }\r\n\r\n  startsWith(searchString: String, position: i32 = 0): bool {\r\n    assert(this !== null);\r\n    if (searchString === null) searchString = changetype<String>(\"null\");\r\n\r\n    var pos: isize = position;\r\n    var len: isize = this.length;\r\n    var start = min(max(pos, 0), len);\r\n    var searchLength: isize = searchString.length;\r\n    if (searchLength + start > len) return false;\r\n    return !compareUnsafe(this, start, searchString, 0, searchLength);\r\n  }\r\n\r\n  substr(start: i32, length: i32 = i32.MAX_VALUE): String {\r\n    assert(this !== null);\r\n    var intStart: isize = start;\r\n    var end: isize = length;\r\n    var size: isize = this.length;\r\n    if (intStart < 0) intStart = max(size + intStart, 0);\r\n    var resultLength = min(max(end, 0), size - intStart);\r\n    if (resultLength <= 0) return changetype<String>(\"\");\r\n    var out = allocateUnsafe(resultLength);\r\n    copyUnsafe(out, 0, this, intStart, resultLength);\r\n    return out;\r\n  }\r\n\r\n  substring(start: i32, end: i32 = i32.MAX_VALUE): String {\r\n    assert(this !== null);\r\n    var len = this.length;\r\n    var finalStart = min(max(start, 0), len);\r\n    var finalEnd = min(max(end, 0), len);\r\n    var from = min<i32>(finalStart, finalEnd);\r\n    var to = max<i32>(finalStart, finalEnd);\r\n    len = to - from;\r\n    if (!len) return changetype<String>(\"\");\r\n    if (!from && to == this.length) return this;\r\n    var out = allocateUnsafe(len);\r\n    copyUnsafe(out, 0, this, from, len);\r\n    return out;\r\n  }\r\n\r\n  trim(): String {\r\n    assert(this !== null);\r\n    var length: usize = this.length;\r\n\r\n    while (\r\n      length &&\r\n      isWhiteSpaceOrLineTerminator(\r\n        load<u16>(changetype<usize>(this) + (length << 1), HEADER_SIZE)\r\n      )\r\n    ) {\r\n      --length;\r\n    }\r\n    var start: usize = 0;\r\n    while (\r\n      start < length &&\r\n      isWhiteSpaceOrLineTerminator(\r\n        load<u16>(changetype<usize>(this) + (start << 1), HEADER_SIZE)\r\n      )\r\n    ) {\r\n      ++start, --length;\r\n    }\r\n    if (!length) return changetype<String>(\"\");\r\n    if (!start && length == this.length) return this;\r\n    var out = allocateUnsafe(length);\r\n    copyUnsafe(out, 0, this, start, length);\r\n    return out;\r\n  }\r\n\r\n  @inline\r\n  trimLeft(): String {\r\n    return this.trimStart();\r\n  }\r\n\r\n  @inline\r\n  trimRight(): String {\r\n    return this.trimEnd();\r\n  }\r\n\r\n  trimStart(): String {\r\n    assert(this !== null);\r\n    var start: isize = 0;\r\n    var len: isize = this.length;\r\n    while (\r\n      start < len &&\r\n      isWhiteSpaceOrLineTerminator(\r\n        load<u16>(changetype<usize>(this) + (start << 1), HEADER_SIZE)\r\n      )\r\n    ) {\r\n      ++start;\r\n    }\r\n    if (!start) return this;\r\n    var outLen = len - start;\r\n    if (!outLen) return changetype<String>(\"\");\r\n    var out = allocateUnsafe(outLen);\r\n    copyUnsafe(out, 0, this, start, outLen);\r\n    return out;\r\n  }\r\n\r\n  trimEnd(): String {\r\n    assert(this !== null);\r\n    var len: isize = this.length;\r\n    while (\r\n      len > 0 &&\r\n      isWhiteSpaceOrLineTerminator(\r\n        load<u16>(changetype<usize>(this) + (len << 1), HEADER_SIZE)\r\n      )\r\n    ) {\r\n      --len;\r\n    }\r\n    if (len <= 0) return changetype<String>(\"\");\r\n    if (<i32>len == this.length) return this;\r\n    var out = allocateUnsafe(len);\r\n    copyUnsafe(out, 0, this, 0, len);\r\n    return out;\r\n  }\r\n\r\n  padStart(targetLength: i32, padString: String = changetype<String>(\" \")): String {\r\n    assert(this !== null);\r\n    var length = this.length;\r\n    var padLen = padString.length;\r\n    if (targetLength < length || !padLen) return this;\r\n    var len = targetLength - length;\r\n    var out = allocateUnsafe(targetLength);\r\n    if (len > padLen) {\r\n      let count = (len - 1) / padLen;\r\n      let base  = count * padLen;\r\n      let rest  = len - base;\r\n      repeatUnsafe(out, 0, padString, count);\r\n      if (rest) copyUnsafe(out, base, padString, 0, rest);\r\n    } else {\r\n      copyUnsafe(out, 0, padString, 0, len);\r\n    }\r\n    if (length) copyUnsafe(out, len, this, 0, length);\r\n    return out;\r\n  }\r\n\r\n  padEnd(targetLength: i32, padString: String = changetype<String>(\" \")): String {\r\n    assert(this !== null);\r\n    var length = this.length;\r\n    var padLen = padString.length;\r\n    if (targetLength < length || !padLen) return this;\r\n    var len = targetLength - length;\r\n    var out = allocateUnsafe(targetLength);\r\n    if (length) copyUnsafe(out, 0, this, 0, length);\r\n    if (len > padLen) {\r\n      let count = (len - 1) / padLen;\r\n      let base = count * padLen;\r\n      let rest = len - base;\r\n      repeatUnsafe(out, length, padString, count);\r\n      if (rest) copyUnsafe(out, base + length, padString, 0, rest);\r\n    } else {\r\n      copyUnsafe(out, length, padString, 0, len);\r\n    }\r\n    return out;\r\n  }\r\n\r\n  repeat(count: i32 = 0): String {\r\n    assert(this !== null);\r\n    var length = this.length;\r\n\r\n    // Most browsers can't handle strings 1 << 28 chars or longer\r\n    if (count < 0 || length * count > (1 << 28)) {\r\n      throw new RangeError(\"Invalid count value\");\r\n    }\r\n\r\n    if (count == 0 || !length) return changetype<String>(\"\");\r\n    if (count == 1) return this;\r\n\r\n    var result = allocateUnsafe(length * count);\r\n    repeatUnsafe(result, 0, this, count);\r\n    return result;\r\n  }\r\n\r\n  split(separator: String = null, limit: i32 = i32.MAX_VALUE): String[] {\r\n    assert(this !== null);\r\n    if (!limit) return new Array<String>();\r\n    if (separator === null) return <String[]>[this];\r\n    var length: isize = this.length;\r\n    var sepLen: isize = separator.length;\r\n    if (limit < 0) limit = i32.MAX_VALUE;\r\n    if (!sepLen) {\r\n      if (!length) return new Array<String>();\r\n      // split by chars\r\n      length = min<isize>(length, <isize>limit);\r\n      let result = new Array<String>(length);\r\n      let buffer = <ArrayBuffer>result.buffer_;\r\n      for (let i: isize = 0; i < length; ++i) {\r\n        let char = allocateUnsafe(1);\r\n        store<u16>(\r\n          changetype<usize>(char),\r\n          load<u16>(\r\n            changetype<usize>(this) + (<usize>i << 1),\r\n            HEADER_SIZE\r\n          ),\r\n          HEADER_SIZE\r\n        );\r\n        STORE<String>(buffer, i, char);\r\n      }\r\n      return result;\r\n    } else if (!length) {\r\n      return <String[]>[changetype<String>(\"\")];\r\n    }\r\n    var result = new Array<String>();\r\n    var end = 0, start = 0, i = 0;\r\n    while ((end = this.indexOf(separator, start)) != -1) {\r\n      let len = end - start;\r\n      if (len > 0) {\r\n        let out = allocateUnsafe(len);\r\n        copyUnsafe(out, 0, this, start, len);\r\n        result.push(out);\r\n      } else {\r\n        result.push(changetype<String>(\"\"));\r\n      }\r\n      if (++i == limit) return result;\r\n      start = end + sepLen;\r\n    }\r\n    if (!start) return <String[]>[this];\r\n    var len = length - start;\r\n    if (len > 0) {\r\n      let out = allocateUnsafe(len);\r\n      copyUnsafe(out, 0, this, start, len);\r\n      result.push(out);\r\n    } else {\r\n      result.push(changetype<String>(\"\"));\r\n    }\r\n    return result;\r\n  }\r\n\r\n  toString(): String {\r\n    return this;\r\n  }\r\n\r\n  get lengthUTF8(): i32 {\r\n    var len = 1; // null terminated\r\n    var pos: usize = 0;\r\n    var end = <usize>this.length;\r\n    while (pos < end) {\r\n      let c = <u32>load<u16>(changetype<usize>(this) + (pos << 1), HEADER_SIZE);\r\n      if (c < 128) {\r\n        len += 1; ++pos;\r\n      } else if (c < 2048) {\r\n        len += 2; ++pos;\r\n      } else {\r\n        if (\r\n          (c & 0xFC00) == 0xD800 && pos + 1 < end &&\r\n          (<u32>load<u16>(changetype<usize>(this) + ((pos + 1) << 1), HEADER_SIZE) & 0xFC00) == 0xDC00\r\n        ) {\r\n          len += 4; pos += 2;\r\n        } else {\r\n          len += 3; ++pos;\r\n        }\r\n      }\r\n    }\r\n    return len;\r\n  }\r\n\r\n  static fromUTF8(ptr: usize, len: usize): String {\r\n    if (len < 1) return changetype<String>(\"\");\r\n    var ptrPos = <usize>0;\r\n    var buf = memory.allocate(<usize>len << 1);\r\n    var bufPos = <usize>0;\r\n    while (ptrPos < len) {\r\n      let cp = <u32>load<u8>(ptr + ptrPos++);\r\n      if (cp < 128) {\r\n        store<u16>(buf + bufPos, cp);\r\n        bufPos += 2;\r\n      } else if (cp > 191 && cp < 224) {\r\n        assert(ptrPos + 1 <= len);\r\n        store<u16>(buf + bufPos, (cp & 31) << 6 | load<u8>(ptr + ptrPos++) & 63);\r\n        bufPos += 2;\r\n      } else if (cp > 239 && cp < 365) {\r\n        assert(ptrPos + 3 <= len);\r\n        cp = (\r\n          (cp                       &  7) << 18 |\r\n          (load<u8>(ptr + ptrPos++) & 63) << 12 |\r\n          (load<u8>(ptr + ptrPos++) & 63) << 6  |\r\n           load<u8>(ptr + ptrPos++) & 63\r\n        ) - 0x10000;\r\n        store<u16>(buf + bufPos, 0xD800 + (cp >> 10));\r\n        bufPos += 2;\r\n        store<u16>(buf + bufPos, 0xDC00 + (cp & 1023));\r\n        bufPos += 2;\r\n      } else {\r\n        assert(ptrPos + 2 <= len);\r\n        store<u16>(buf + bufPos,\r\n          (cp                       & 15) << 12 |\r\n          (load<u8>(ptr + ptrPos++) & 63) << 6  |\r\n           load<u8>(ptr + ptrPos++) & 63\r\n        );\r\n        bufPos += 2;\r\n      }\r\n    }\r\n    assert(ptrPos == len);\r\n    var str = allocateUnsafe(<u32>(bufPos >> 1));\r\n    memory.copy(changetype<usize>(str) + HEADER_SIZE, buf, bufPos);\r\n    memory.free(buf);\r\n    return str;\r\n  }\r\n\r\n  toUTF8(): usize {\r\n    var buf = memory.allocate(<usize>this.lengthUTF8);\r\n    var pos: usize = 0;\r\n    var end = <usize>this.length;\r\n    var off: usize = 0;\r\n    while (pos < end) {\r\n      let c1 = <u32>load<u16>(changetype<usize>(this) + (pos << 1), HEADER_SIZE);\r\n      if (c1 < 128) {\r\n        store<u8>(buf + off, c1);\r\n        ++off; ++pos;\r\n      } else if (c1 < 2048) {\r\n        let ptr = buf + off;\r\n        store<u8>(ptr, c1 >> 6      | 192);\r\n        store<u8>(ptr, c1      & 63 | 128, 1);\r\n        off += 2; ++pos;\r\n      } else {\r\n        let ptr = buf + off;\r\n        if ((c1 & 0xFC00) == 0xD800 && pos + 1 < end) {\r\n          let c2 = <u32>load<u16>(changetype<usize>(this) + ((pos + 1) << 1), HEADER_SIZE);\r\n          if ((c2 & 0xFC00) == 0xDC00) {\r\n            c1 = 0x10000 + ((c1 & 0x03FF) << 10) + (c2 & 0x03FF);\r\n            store<u8>(ptr, c1 >> 18      | 240);\r\n            store<u8>(ptr, c1 >> 12 & 63 | 128, 1);\r\n            store<u8>(ptr, c1 >> 6  & 63 | 128, 2);\r\n            store<u8>(ptr, c1       & 63 | 128, 3);\r\n            off += 4; pos += 2;\r\n            continue;\r\n          }\r\n        }\r\n        store<u8>(ptr, c1 >> 12      | 224);\r\n        store<u8>(ptr, c1 >> 6  & 63 | 128, 1);\r\n        store<u8>(ptr, c1       & 63 | 128, 2);\r\n        off += 3; ++pos;\r\n      }\r\n    }\r\n    store<u8>(buf + off, 0);\r\n    return buf;\r\n  }\r\n}\r\n\r\nexport function parseInt(str: String, radix: i32 = 0): f64 {\r\n  return parse<f64>(str, radix);\r\n}\r\n\r\nexport function parseI32(str: String, radix: i32 = 0): i32 {\r\n  return parse<i32>(str, radix);\r\n}\r\n\r\nexport function parseI64(str: String, radix: i32 = 0): i64 {\r\n  return parse<i64>(str, radix);\r\n}\r\n\r\n// FIXME: naive implementation\r\nexport function parseFloat(str: String): f64 {\r\n  var len: i32 = str.length;\r\n  if (!len) return NaN;\r\n\r\n  var ptr = changetype<usize>(str) /* + HEAD -> offset */;\r\n  var code = <i32>load<u16>(ptr, HEADER_SIZE);\r\n\r\n  // determine sign\r\n  var sign: f64;\r\n  if (code == CharCode.MINUS) {\r\n    if (!--len) return NaN;\r\n    code = <i32>load<u16>(ptr += 2, HEADER_SIZE);\r\n    sign = -1;\r\n  } else if (code == CharCode.PLUS) {\r\n    if (!--len) return NaN;\r\n    code = <i32>load<u16>(ptr += 2, HEADER_SIZE);\r\n    sign = 1;\r\n  } else {\r\n    sign = 1;\r\n  }\r\n\r\n  // calculate value\r\n  var num: f64 = 0;\r\n  while (len--) {\r\n    code = <i32>load<u16>(ptr, HEADER_SIZE);\r\n    if (code == CharCode.DOT) {\r\n      ptr += 2;\r\n      let fac: f64 = 0.1; // precision :(\r\n      while (len--) {\r\n        code = <i32>load<u16>(ptr, HEADER_SIZE);\r\n        if (code == CharCode.E || code == CharCode.e) {\r\n          assert(false); // TODO\r\n        }\r\n        code -= CharCode._0;\r\n        if (<u32>code > 9) break;\r\n        num += <f64>code * fac;\r\n        fac *= 0.1;\r\n        ptr += 2;\r\n      }\r\n      break;\r\n    }\r\n    code -= CharCode._0;\r\n    if (<u32>code >= 10) break;\r\n    num = (num * 10) + code;\r\n    ptr += 2;\r\n  }\r\n  return sign * num;\r\n}\r\n","import { TextureMap, injectImage, imageLoaded } from \"./TextureMap\";\r\nimport { report_inject_functions } from \"../linked\";\r\n\r\nreport_inject_functions(injectImage, imageLoaded);\r\n\r\nexport { Image } from \"./Image\";\r\nexport { Matrix } from \"./Matrix\";\r\nexport { Path2DElement } from \"./Path2DElement\";\r\nexport { FillStrokeWhichValue, FillStrokeWhich } from \"./FillStrokeWhichValue\";\r\nexport { TextureMap, injectImage, imageLoaded }\r\n","var id: i32 = 0;\r\nexport class CanvasPattern {\r\n  public _id: i32 = id++;\r\n}\r\n","import { add_color_stop } from \"../linked\";\r\nvar id: i32 = 0;\r\n\r\nexport class CanvasGradient {\r\n  _id: i32 = id++;\r\n\r\n  public addColorStop(point: f64, color: string): void {\r\n    add_color_stop(this._id, point, color);\r\n  }\r\n\r\n  public dispose(): void {\r\n    remove_gradient(this._id);\r\n  }\r\n}","export class Serializer<T> {\r\n  index: i32 = 0;\r\n  data: Float64Array = new Float64Array(8000);\r\n\r\n  public init(): void {\r\n    this.index = 0;\r\n  }\r\n\r\n  @inline\r\n  protected write_zero(instruction: T): void {\r\n    if (this.data.length <= (this.index + 2)) this.grow();\r\n    this.data[this.index++] = <f64>instruction;\r\n    this.data[this.index++] = 2.0; // stride\r\n  }\r\n\r\n  @inline\r\n  protected write_one(instruction: T, value: f64): void {\r\n    if (this.data.length <= (this.index + 3)) this.grow();\r\n    this.data[this.index++] = <f64>instruction;\r\n    this.data[this.index++] = 3.0; // stride\r\n    this.data[this.index++] = value;\r\n  }\r\n\r\n\r\n  @inline\r\n  protected write_two(instruction: T, a: f64, b: f64): void {\r\n    if (this.data.length <= (this.index + 4)) this.grow();\r\n    this.data[this.index++] = <f64>instruction;\r\n    this.data[this.index++] = 4.0; // stride\r\n    this.data[this.index++] = a;\r\n    this.data[this.index++] = b;\r\n  }\r\n\r\n  @inline\r\n  protected write_four(instruction: T, a: f64, b: f64, c: f64, d: f64): void {\r\n    if (this.data.length <= (this.index + 6)) this.grow();\r\n    this.data[this.index++] = <f64>instruction;\r\n    this.data[this.index++] = 6.0; // stride\r\n    this.data[this.index++] = a;\r\n    this.data[this.index++] = b;\r\n    this.data[this.index++] = c;\r\n    this.data[this.index++] = d;\r\n  }\r\n\r\n  @inline\r\n  protected write_five(instruction: T, a: f64, b: f64, c: f64, d: f64, e: f64): void {\r\n    if (this.data.length <= (this.index + 7)) this.grow();\r\n    this.data[this.index++] = <f64>instruction;\r\n    this.data[this.index++] = 7.0; // stride\r\n    this.data[this.index++] = a;\r\n    this.data[this.index++] = b;\r\n    this.data[this.index++] = c;\r\n    this.data[this.index++] = d;\r\n    this.data[this.index++] = e;\r\n  }\r\n\r\n  @inline\r\n  protected write_six(instruction: T, a: f64, b: f64, c: f64, d: f64, e: f64, f: f64): void {\r\n    if (this.data.length <= (this.index + 8)) this.grow();\r\n    this.data[this.index++] = <f64>instruction;\r\n    this.data[this.index++] = 8.0; // stride\r\n    this.data[this.index++] = a;\r\n    this.data[this.index++] = b;\r\n    this.data[this.index++] = c;\r\n    this.data[this.index++] = d;\r\n    this.data[this.index++] = e;\r\n    this.data[this.index++] = f;\r\n  }\r\n\r\n  @inline\r\n  protected write_eight(instruction: T, a: f64, b: f64, c: f64, d: f64, e: f64, f: f64, g: f64, h: f64): void {\r\n    if (this.data.length <= (this.index + 11)) this.grow();\r\n    this.data[this.index++] = <f64>instruction;\r\n    this.data[this.index++] = 10.0; // stride\r\n    this.data[this.index++] = a;\r\n    this.data[this.index++] = b;\r\n    this.data[this.index++] = c;\r\n    this.data[this.index++] = d;\r\n    this.data[this.index++] = e;\r\n    this.data[this.index++] = f;\r\n    this.data[this.index++] = g;\r\n    this.data[this.index++] = h;\r\n  }\r\n\r\n  @inline\r\n  protected write_nine(instruction: T, a: f64, b: f64, c: f64, d: f64, e: f64, f: f64, g: f64, h: f64, i: f64): void {\r\n    if (this.data.length <= (this.index + 11)) this.grow();\r\n    this.data[this.index++] = <f64>instruction;\r\n    this.data[this.index++] = 11.0; // stride\r\n    this.data[this.index++] = a;\r\n    this.data[this.index++] = b;\r\n    this.data[this.index++] = c;\r\n    this.data[this.index++] = d;\r\n    this.data[this.index++] = e;\r\n    this.data[this.index++] = f;\r\n    this.data[this.index++] = g;\r\n    this.data[this.index++] = h;\r\n    this.data[this.index++] = i;\r\n  }\r\n\r\n  @inline\r\n  protected grow(): void {\r\n    var data: Float64Array = new Float64Array(this.data.length + 8000);\r\n    var length: i32 = this.data.length;\r\n    var i: i32 = 0;\r\n    while (i < length) {\r\n      data[i] = this.data[i];\r\n      ++i;\r\n    }\r\n    this.data = data;\r\n  }\r\n}\r\n","import {\r\n  HEADER_SIZE as AB_HEADER_SIZE,\r\n  MAX_BLENGTH as AB_MAX_BLENGTH,\r\n  allocateUnsafe,\r\n  LOAD,\r\n  STORE\r\n} from \"./arraybuffer\";\r\n\r\nimport {\r\n  SORT as SORT_IMPL\r\n} from \"./sort\";\r\n\r\n/** Typed array base class. Not a global object. */\r\nexport abstract class TypedArray<T> {\r\n  [key: number]: T; // compatibility only\r\n\r\n  readonly buffer: ArrayBuffer;\r\n  readonly byteOffset: i32;\r\n  readonly byteLength: i32;\r\n\r\n  constructor(length: i32) {\r\n    const MAX_LENGTH = <u32>AB_MAX_BLENGTH / sizeof<T>();\r\n    if (<u32>length > MAX_LENGTH) throw new RangeError(\"Invalid typed array length\");\r\n    var byteLength = length << alignof<T>();\r\n    var buffer = allocateUnsafe(byteLength);\r\n    memory.fill(changetype<usize>(buffer) + AB_HEADER_SIZE, 0, <usize>byteLength);\r\n    this.buffer = buffer;\r\n    this.byteOffset = 0;\r\n    this.byteLength = byteLength;\r\n  }\r\n\r\n  @inline\r\n  get length(): i32 {\r\n    return this.byteLength >>> alignof<T>();\r\n  }\r\n\r\n  @operator(\"[]\")\r\n  protected __get(index: i32): T {\r\n    if (<u32>index >= <u32>(this.byteLength >>> alignof<T>())) throw new Error(\"Index out of bounds\");\r\n    return LOAD<T>(this.buffer, index, this.byteOffset);\r\n  }\r\n\r\n  @inline @operator(\"{}\")\r\n  protected __unchecked_get(index: i32): T {\r\n    return LOAD<T>(this.buffer, index, this.byteOffset);\r\n  }\r\n\r\n  @operator(\"[]=\")\r\n  protected __set(index: i32, value: NATIVE<T>): void {\r\n    if (<u32>index >= <u32>(this.byteLength >>> alignof<T>())) throw new Error(\"Index out of bounds\");\r\n    STORE<T,NATIVE<T>>(this.buffer, index, value, this.byteOffset);\r\n  }\r\n\r\n  @inline @operator(\"{}=\")\r\n  protected __unchecked_set(index: i32, value: NATIVE<T>): void {\r\n    STORE<T,NATIVE<T>>(this.buffer, index, value, this.byteOffset);\r\n  }\r\n\r\n  // copyWithin(target: i32, start: i32, end: i32 = this.length): this\r\n}\r\n\r\n@inline\r\nexport function FILL<TArray extends TypedArray<T>, T>(\r\n  array: TArray,\r\n  value: NATIVE<T>,\r\n  start: i32,\r\n  end: i32\r\n): TArray {\r\n  var buffer = array.buffer;\r\n  var byteOffset = array.byteOffset;\r\n  var len = array.length;\r\n  start = start < 0 ? max(len + start, 0) : min(start, len);\r\n  end   = end   < 0 ? max(len + end,   0) : min(end,   len);\r\n  if (sizeof<T>() == 1) {\r\n    if (start < end) {\r\n      memory.fill(\r\n        changetype<usize>(buffer) + start + byteOffset + AB_HEADER_SIZE,\r\n        <u8>value,\r\n        <usize>(end - start)\r\n      );\r\n    }\r\n  } else {\r\n    for (; start < end; ++start) {\r\n      STORE<T,NATIVE<T>>(buffer, start, value, byteOffset);\r\n    }\r\n  }\r\n  return array;\r\n}\r\n\r\n@inline\r\nexport function SORT<TArray extends TypedArray<T>, T>(\r\n  array: TArray,\r\n  comparator: (a: T, b: T) => i32\r\n): TArray {\r\n  var byteOffset = array.byteOffset;\r\n  var length = array.length;\r\n  if (length <= 1) return array;\r\n  var buffer = array.buffer;\r\n  if (length == 2) {\r\n    let a = LOAD<T>(buffer, 1, byteOffset);\r\n    let b = LOAD<T>(buffer, 0, byteOffset);\r\n    if (comparator(a, b) < 0) {\r\n      STORE<T>(buffer, 1, b, byteOffset);\r\n      STORE<T>(buffer, 0, a, byteOffset);\r\n    }\r\n    return array;\r\n  }\r\n  SORT_IMPL<T>(buffer, byteOffset, length, comparator);\r\n  return array;\r\n}\r\n\r\n@inline\r\nexport function SUBARRAY<TArray extends TypedArray<T>, T>(\r\n  array: TArray,\r\n  begin: i32,\r\n  end: i32\r\n): TArray {\r\n  var length = <i32>array.length;\r\n  if (begin < 0) begin = max(length + begin, 0);\r\n  else begin = min(begin, length);\r\n  if (end < 0) end = max(length + end, begin);\r\n  else end = max(min(end, length), begin);\r\n  var slice = memory.allocate(offsetof<TArray>());\r\n  store<usize>(slice, array.buffer, offsetof<TArray>(\"buffer\"));\r\n  store<i32>(slice, <i32>array.byteOffset + (begin << alignof<T>()), offsetof<TArray>(\"byteOffset\"));\r\n  store<i32>(slice, (end - begin) << alignof<T>(), offsetof<TArray>(\"byteLength\"));\r\n  return changetype<TArray>(slice);\r\n}\r\n\r\n@inline\r\nexport function REDUCE<TArray extends TypedArray<T>, T, TRet>(\r\n  array: TArray,\r\n  callbackfn: (accumulator: TRet, value: T, index: i32, array: TArray) => TRet,\r\n  initialValue: TRet\r\n): TRet {\r\n  var index = 0;\r\n  var length = <i32>array.length;\r\n  while (index != length) {\r\n    initialValue = callbackfn(\r\n      initialValue,\r\n      unchecked(array[index]),\r\n      index,\r\n      array,\r\n    );\r\n    ++index;\r\n  }\r\n  return initialValue;\r\n}\r\n\r\n@inline\r\nexport function REDUCE_RIGHT<TArray extends TypedArray<T>, T, TRet>(\r\n  array: TArray,\r\n  callbackfn: (accumulator: TRet, value: T, index: i32, array: TArray) => TRet,\r\n  initialValue: TRet\r\n): TRet {\r\n  var index = <i32>array.length - 1;\r\n  var length = -1;\r\n  while (index != length) {\r\n    initialValue = callbackfn(\r\n      initialValue,\r\n      unchecked(array[index]),\r\n      index,\r\n      array,\r\n    );\r\n    --index;\r\n  }\r\n  return initialValue;\r\n}\r\n\r\n@inline\r\nexport function MAP<TArray extends TypedArray<T>, T>(\r\n  array: TArray,\r\n  callbackfn: (value: T, index: i32, self: TArray) => T,\r\n): TArray {\r\n  var length: i32 = array.length;\r\n  var result = instantiate<TArray>(length);\r\n  var i: i32 = 0;\r\n  while (i < length) {\r\n    unchecked(result[i] = callbackfn(array[i], i, <TArray>array));\r\n    ++i;\r\n  }\r\n  return result;\r\n}\r\n","import {\r\n  CanvasInstruction,\r\n  Direction,\r\n  FillRule,\r\n  GlobalCompositeOperation,\r\n  ImageSmoothingQuality,\r\n  LineCap,\r\n  LineJoin,\r\n  TextAlign,\r\n  TextBaseline,\r\n} from \"../../src/shared\";\r\nimport { Serializer } from \"./Serializer\";\r\nimport { Image } from \"../primitives\";\r\nimport { create_string } from \"../linked\";\r\nimport { CanvasPattern } from \"./CanvasPattern\";\r\nimport { CanvasGradient } from \"./CanvasGradient\";\r\n\r\nexport class CanvasRenderingContext2DSerializer extends Serializer<CanvasInstruction> {\r\n  private _stringMap: Map<string, i32> = new Map<string, i32>();\r\n  private _stringIndex: i32 = -1;\r\n\r\n  public init(): void {\r\n    super.init();\r\n  }\r\n\r\n  @inline\r\n  protected write_arc(x: f64, y: f64, radius: f64, startAngle: f64, endAngle: f64, anticlockwise: bool): void {\r\n    this.write_six(\r\n      CanvasInstruction.Arc,\r\n      x,\r\n      y,\r\n      radius,\r\n      startAngle,\r\n      endAngle,\r\n      anticlockwise ? 1.0 : 0.0,\r\n    );\r\n  }\r\n\r\n  @inline\r\n  protected write_arc_to(x1: f64, y1: f64, x2: f64, y2: f64, radius: f64): void {\r\n    this.write_five(\r\n      CanvasInstruction.ArcTo,\r\n      x1,\r\n      y1,\r\n      x2,\r\n      y2,\r\n      radius,\r\n    );\r\n  }\r\n\r\n  @inline\r\n  protected write_begin_path(): void {\r\n    this.write_zero(CanvasInstruction.BeginPath);\r\n  }\r\n\r\n  @inline\r\n  protected write_bezier_curve_to(cp1x: f64, cp1y: f64, cp2x: f64, cp2y: f64, x: f64, y: f64): void {\r\n    this.write_six(\r\n      CanvasInstruction.BezierCurveTo,\r\n      cp1x,\r\n      cp1y,\r\n      cp2x,\r\n      cp2y,\r\n      x,\r\n      y,\r\n    );\r\n  }\r\n\r\n  @inline\r\n  protected write_clear_rect(x: f64, y: f64, width: f64, height: f64): void {\r\n    this.write_four(\r\n      CanvasInstruction.ClearRect,\r\n      x,\r\n      y,\r\n      width,\r\n      height,\r\n    );\r\n  }\r\n\r\n  @inline\r\n  protected write_clip(fillRule: FillRule): void {\r\n    this.write_one(\r\n      CanvasInstruction.Clip,\r\n      <f64>fillRule,\r\n    );\r\n  }\r\n\r\n  @inline\r\n  protected write_close_path(): void {\r\n    this.write_zero(CanvasInstruction.ClosePath);\r\n  }\r\n\r\n  @inline\r\n  protected write_direction(value: Direction): void {\r\n    this.write_one(\r\n      CanvasInstruction.Direction,\r\n      <f64>value,\r\n    );\r\n  }\r\n\r\n  @inline\r\n  protected write_draw_focus_if_needed(): void {\r\n    this.write_zero(CanvasInstruction.DrawFocusIfNeeded);\r\n  }\r\n\r\n  @inline\r\n  protected write_draw_image(img: Image, sx: f64, sy: f64, swidth: f64, sheight: f64, x: f64, y: f64, width: f64, height: f64): void {\r\n    this.write_nine(\r\n      CanvasInstruction.DrawImage,\r\n      <f64>img._index,\r\n      sx,\r\n      sy,\r\n      swidth,\r\n      sheight,\r\n      x,\r\n      y,\r\n      width,\r\n      height,\r\n    );\r\n  }\r\n\r\n  @inline\r\n  protected write_ellipse(x: f64, y: f64, radiusX: f64, radiusY: f64, rotation: f64, startAngle: f64, endAngle: f64, anticlockwise: bool): void {\r\n    this.write_eight(\r\n      CanvasInstruction.Ellipse,\r\n      x,\r\n      y,\r\n      radiusX,\r\n      radiusY,\r\n      rotation,\r\n      startAngle,\r\n      endAngle,\r\n      anticlockwise ? 1.0 : 0.0,\r\n    );\r\n  }\r\n\r\n  @inline\r\n  protected write_fill(fillRule: FillRule = FillRule.nonzero): void {\r\n    this.write_one(\r\n      CanvasInstruction.Fill,\r\n      <f64>fillRule,\r\n    );\r\n  }\r\n\r\n  @inline\r\n  protected write_fill_gradient(fillGradient: CanvasGradient): void {\r\n    this.write_one(\r\n      CanvasInstruction.FillGradient,\r\n      <f64>fillGradient._id,\r\n    );\r\n  }\r\n\r\n  @inline\r\n  protected write_fill_pattern(fillPattern: CanvasPattern): void {\r\n    this.write_one(\r\n      CanvasInstruction.FillPattern,\r\n      <f64>fillPattern._id,\r\n    );\r\n  }\r\n\r\n  @inline\r\n  protected write_fill_rect(x: f64, y: f64, width: f64, height: f64): void {\r\n    this.write_four(\r\n      CanvasInstruction.FillRect,\r\n      x,\r\n      y,\r\n      width,\r\n      height,\r\n    );\r\n  }\r\n\r\n  @inline\r\n  protected write_fill_style(value: string): void {\r\n    this.write_one(\r\n      CanvasInstruction.FillStyle,\r\n      this.send_string(value),\r\n    );\r\n  }\r\n\r\n  @inline\r\n  protected write_fill_text(text: string, x: f64, y: f64, maxWidth: f64): void {\r\n    this.write_four(\r\n      CanvasInstruction.FillText,\r\n      this.send_string(text),\r\n      x,\r\n      y,\r\n      maxWidth,\r\n    );\r\n  }\r\n\r\n  @inline\r\n  protected write_filter(value: string): void {\r\n    this.write_one(\r\n      CanvasInstruction.Filter,\r\n      this.send_string(value),\r\n    );\r\n  }\r\n\r\n  @inline\r\n  protected write_font(value: string): void {\r\n    this.write_one(\r\n      CanvasInstruction.Font,\r\n      this.send_string(value),\r\n    )\r\n  }\r\n\r\n  @inline\r\n  protected write_global_alpha(value: f64): void {\r\n    this.write_one(\r\n      CanvasInstruction.GlobalAlpha,\r\n      value,\r\n    );\r\n  }\r\n\r\n  @inline\r\n  protected write_global_composite_operation(value: GlobalCompositeOperation): void {\r\n    this.write_one(\r\n      CanvasInstruction.GlobalCompositeOperation,\r\n      <f64>value,\r\n    )\r\n  }\r\n\r\n  @inline\r\n  protected write_image_smoothing_enabled(value: bool): void {\r\n    this.write_one(\r\n      CanvasInstruction.ImageSmoothingEnabled,\r\n      value ? 1.0 : 0.0,\r\n    );\r\n  }\r\n\r\n  @inline\r\n  protected write_image_smoothing_quality(value: ImageSmoothingQuality): void {\r\n    this.write_one(\r\n      CanvasInstruction.ImageSmoothingQuality,\r\n      <f64>value,\r\n    );\r\n  }\r\n\r\n  @inline\r\n  protected write_line_cap(value: LineCap): void {\r\n    this.write_one(\r\n      CanvasInstruction.LineCap,\r\n      <f64>value,\r\n    );\r\n  }\r\n\r\n  @inline\r\n  protected write_line_dash(lineDash: Float64Array): void {\r\n    this.write_one(\r\n      CanvasInstruction.LineDash,\r\n      <f64>changetype<usize>(lineDash),\r\n    );\r\n  }\r\n\r\n  @inline\r\n  protected write_line_dash_offset(value: f64): void {\r\n    this.write_one(\r\n      CanvasInstruction.LineDashOffset,\r\n      <f64>value,\r\n    );\r\n  }\r\n\r\n  @inline\r\n  protected write_line_join(value: LineJoin): void {\r\n    this.write_one(\r\n      CanvasInstruction.LineJoin,\r\n      <f64>value,\r\n    );\r\n  }\r\n\r\n  @inline\r\n  protected write_line_to(x: f64, y: f64): void {\r\n    this.write_two(\r\n      CanvasInstruction.LineTo,\r\n      x,\r\n      y,\r\n    );\r\n  }\r\n\r\n  @inline\r\n  protected write_line_width(value: f64): void {\r\n    this.write_one(\r\n      CanvasInstruction.LineWidth,\r\n      <f64>value,\r\n    );\r\n  }\r\n\r\n  @inline\r\n  protected write_miter_limit(value: f64): void {\r\n    this.write_one(\r\n      CanvasInstruction.MiterLimit,\r\n      value,\r\n    );\r\n  }\r\n\r\n  @inline\r\n  protected write_move_to(x: f64, y: f64): void {\r\n    this.write_two(\r\n      CanvasInstruction.MoveTo,\r\n      x,\r\n      y,\r\n    );\r\n  }\r\n\r\n  @inline\r\n  protected write_quadratic_curve_to(cpx: f64, cpy: f64, x: f64, y: f64): void {\r\n    this.write_four(\r\n      CanvasInstruction.QuadraticCurveTo,\r\n      cpx,\r\n      cpy,\r\n      x,\r\n      y,\r\n    );\r\n  }\r\n\r\n  @inline\r\n  protected write_rect(x: f64, y: f64, width: f64, height: f64): void {\r\n    this.write_four(\r\n      CanvasInstruction.Rect,\r\n      x,\r\n      y,\r\n      width,\r\n      height,\r\n    );\r\n  }\r\n\r\n  @inline\r\n  protected write_restore(): void {\r\n    this.write_zero(CanvasInstruction.Restore);\r\n  }\r\n\r\n  @inline\r\n  protected write_rotate(angle: f64): void {\r\n    this.write_one(\r\n      CanvasInstruction.Rotate,\r\n      angle,\r\n    );\r\n  }\r\n\r\n  @inline\r\n  protected write_save(): void {\r\n    this.write_zero(CanvasInstruction.Save);\r\n  }\r\n\r\n  @inline\r\n  protected write_scale(x: f64, y: f64): void {\r\n    this.write_two(\r\n      CanvasInstruction.Scale,\r\n      x,\r\n      y,\r\n    );\r\n  }\r\n\r\n  @inline\r\n  protected write_set_transform(a: f64, b: f64, c: f64, d: f64, e: f64, f: f64 ): void {\r\n    this.write_six(\r\n      CanvasInstruction.SetTransform,\r\n      a,\r\n      b,\r\n      c,\r\n      d,\r\n      e,\r\n      f,\r\n    );\r\n  }\r\n\r\n  @inline\r\n  protected write_shadow_blur(value: f64): void {\r\n    this.write_one(\r\n      CanvasInstruction.ShadowBlur,\r\n      value,\r\n    );\r\n  }\r\n\r\n  @inline\r\n  protected write_shadow_color(value: string): void {\r\n    this.write_one(\r\n      CanvasInstruction.ShadowColor,\r\n      this.send_string(value),\r\n    );\r\n  }\r\n\r\n  @inline\r\n  protected write_shadow_offset_x(value: f64): void {\r\n    this.write_one(\r\n      CanvasInstruction.ShadowOffsetX,\r\n      value,\r\n    );\r\n  }\r\n\r\n  @inline\r\n  protected write_shadow_offset_y(value: f64): void {\r\n    this.write_one(\r\n      CanvasInstruction.ShadowOffsetY,\r\n      value,\r\n    );\r\n  }\r\n\r\n  @inline\r\n  protected write_stroke(): void {\r\n    this.write_zero(CanvasInstruction.Stroke);\r\n  }\r\n\r\n  @inline\r\n  protected write_stroke_rect(x: f64, y: f64, width: f64, height: f64): void {\r\n    this.write_four(\r\n      CanvasInstruction.StrokeRect,\r\n      x,\r\n      y,\r\n      width,\r\n      height,\r\n    );\r\n  }\r\n\r\n  @inline\r\n  protected write_stroke_gradient(strokeGradient: CanvasGradient): void {\r\n    this.write_one(\r\n      CanvasInstruction.StrokeGradient,\r\n      <f64>strokeGradient._id,\r\n    );\r\n  }\r\n\r\n  @inline\r\n  protected write_stroke_pattern(strokePattern: CanvasPattern): void {\r\n    this.write_one(\r\n      CanvasInstruction.StrokePattern,\r\n      <f64>strokePattern._id,\r\n    );\r\n  }\r\n\r\n  @inline\r\n  protected write_stroke_style(value: string): void {\r\n    this.write_one(\r\n      CanvasInstruction.StrokeStyle,\r\n      this.send_string(value),\r\n    )\r\n  }\r\n\r\n  @inline\r\n  protected write_stroke_text(text: string, x: f64, y: f64, maxWidth: f64): void {\r\n    this.write_four(\r\n      CanvasInstruction.StrokeText,\r\n      this.send_string(text),\r\n      x,\r\n      y,\r\n      maxWidth,\r\n    );\r\n  }\r\n\r\n  @inline\r\n  protected write_text_align(value: TextAlign): void {\r\n    this.write_one(\r\n      CanvasInstruction.TextAlign,\r\n      <f64>value,\r\n    );\r\n  }\r\n\r\n  @inline\r\n  protected write_text_baseline(value: TextBaseline): void {\r\n    this.write_one(\r\n      CanvasInstruction.TextBaseline,\r\n      <f64>value,\r\n    );\r\n  }\r\n\r\n  @inline\r\n  protected write_transform(a: f64, b: f64, c: f64, d: f64, e: f64, f: f64): void {\r\n    this.write_six(\r\n      CanvasInstruction.Transform,\r\n      a,\r\n      b,\r\n      c,\r\n      d,\r\n      e,\r\n      f,\r\n    );\r\n  }\r\n\r\n  @inline\r\n  protected write_translate(x: f64, y: f64): void {\r\n    this.write_two(\r\n      CanvasInstruction.Translate,\r\n      x,\r\n      y,\r\n    );\r\n  }\r\n\r\n  @inline\r\n  protected write_commit(): void {\r\n    this.write_zero(CanvasInstruction.Commit);\r\n    this.index = 0;\r\n    this._stringMap.clear();\r\n    this._stringIndex = 0;\r\n  }\r\n\r\n  @inline\r\n  protected send_string(value: string): f64 {\r\n    if (this._stringMap.has(value)) {\r\n      return <f64>this._stringMap.get(value);\r\n    }\r\n    ++this._stringIndex;\r\n    this._stringMap.set(value, this._stringIndex);\r\n    create_string(this._stringIndex, value);\r\n    return <f64>this._stringIndex;\r\n  }\r\n}\r\n","import { CanvasRenderingContext2DSerializer } from \"./CanvasRenderingContext2DSerializer\";\r\nimport {\r\n  Direction,\r\n  GlobalCompositeOperation,\r\n  ImageSmoothingQuality,\r\n  LineCap,\r\n  LineJoin,\r\n  TextAlign,\r\n  TextBaseline,\r\n  CanvasInstruction,\r\n  CanvasPatternType,\r\n} from \"../../src/shared\";\r\nimport { FillStrokeWhichValue, Path2DElement, Matrix, Image, FillStrokeWhich } from \"../primitives\";\r\nimport { doubleTypedArray, copyTypedArray } from \"../util\";\r\nimport { create_linear_gradient, create_pattern, create_radial_gradient } from \"../linked\";\r\nimport { CanvasGradient } from \"./CanvasGradient\";\r\nimport { CanvasPattern } from \"./CanvasPattern\";\r\n\r\nexport class OptimizedCanvasRenderingContext2D extends CanvasRenderingContext2DSerializer {\r\n  private _direction: Direction[] = new Array<Direction>(0);\r\n  private _directionCurrent: Direction;\r\n  private _fillStyle: FillStrokeWhichValue[] = new Array<FillStrokeWhichValue>(0);\r\n  private _fillStyleCurrent: FillStrokeWhichValue;\r\n  private _filter: string[] = new Array<string>(0);\r\n  private _filterCurrent: string;\r\n  private _font: string[] = new Array<string>(0);\r\n  private _fontCurrent: string;\r\n  private _globalAlpha: f64[] = new Array<f64>(0);\r\n  private _globalAlphaCurrent: f64;\r\n  private _globalCompositeOperation: GlobalCompositeOperation[] = new Array<GlobalCompositeOperation>(0);\r\n  private _globalCompositeOperationCurrent: GlobalCompositeOperation;\r\n  private _imageSmoothingEnabled: bool[] = new Array<bool>(0);\r\n  private _imageSmoothingEnabledCurrent: bool;\r\n  private _imageSmoothingQuality: ImageSmoothingQuality[] = new Array<ImageSmoothingQuality>(0);\r\n  private _imageSmoothingQualityCurrent: ImageSmoothingQuality;\r\n  private _lineCap: LineCap[] = new Array<LineCap>(0);\r\n  private _lineCapCurrent: LineCap;\r\n  private _lineDash: Float64Array[] = new Array<Float64Array>(0);\r\n  private _lineDashCurrent: Float64Array = new Float64Array(0);\r\n  private _lineDashOffset: f64[] = new Array<f64>(0);\r\n  private _lineDashOffsetCurrent: f64;\r\n  private _lineJoin: LineJoin[] = new Array<LineJoin>(0);\r\n  private _lineJoinCurrent: LineJoin;\r\n  private _lineWidth: f64[] = new Array<f64>(0);\r\n  private _lineWidthCurrent: f64;\r\n  private _miterLimit: f64[] = new Array<f64>(0);\r\n  private _miterLimitCurrent: f64;\r\n  private _transformA: f64[] = new Array<f64>(0);\r\n  private _transformACurrent: f64;\r\n  private _transformB: f64[] = new Array<f64>(0);\r\n  private _transformBCurrent: f64;\r\n  private _transformC: f64[] = new Array<f64>(0);\r\n  private _transformCCurrent: f64;\r\n  private _transformD: f64[] = new Array<f64>(0);\r\n  private _transformDCurrent: f64;\r\n  private _transformE: f64[] = new Array<f64>(0);\r\n  private _transformECurrent: f64;\r\n  private _transformF: f64[] = new Array<f64>(0);\r\n  private _transformFCurrent: f64;\r\n  private _shadowBlur: f64[] = new Array<f64>(0);\r\n  private _shadowBlurCurrent: f64;\r\n  private _shadowColor: string[] = new Array<string>(0);\r\n  private _shadowColorCurrent: string;\r\n  private _shadowOffsetX: f64[] = new Array<f64>(0);\r\n  private _shadowOffsetXCurrent: f64;\r\n  private _shadowOffsetY: f64[] = new Array<f64>(0);\r\n  private _shadowOffsetYCurrent: f64;\r\n  private _strokeStyle: FillStrokeWhichValue[] = new Array<FillStrokeWhichValue>(0);\r\n  private _strokeStyleCurrent: FillStrokeWhichValue;\r\n  private _textAlign: TextAlign[] = new Array<TextAlign>(0);\r\n  private _textAlignCurrent: TextAlign;\r\n  private _textBaseline: TextBaseline[] = new Array<TextBaseline>(0);\r\n  private _textBaselineCurrent: TextBaseline;\r\n  private _stackIndex: i32 = 0;\r\n\r\n  // path variables\r\n  private _path: Path2DElement[] = new Array<Path2DElement>(1000);\r\n  private _pathIndex: i32 = 0;\r\n\r\n  private _hardSave: bool[] = new Array<bool>(0);\r\n\r\n  init(): void {\r\n    var i: i32 = 0;\r\n    while (i < 100) {\r\n      this._direction.push(Direction.inherit);\r\n      this._fillStyle.push(new FillStrokeWhichValue());\r\n      this._filter.push(\"none\");\r\n      this._font.push(\"none\");\r\n      this._globalAlpha.push(1.0);\r\n      this._globalCompositeOperation.push(GlobalCompositeOperation.source_over);\r\n      this._imageSmoothingEnabled.push(true);\r\n      this._imageSmoothingQuality.push(ImageSmoothingQuality.low);\r\n      this._lineCap.push(LineCap.butt);\r\n      this._lineDash.push(new Float64Array(0));\r\n      this._lineDashOffset.push(0.0);\r\n      this._lineJoin.push(LineJoin.miter);\r\n      this._lineWidth.push(1.0);\r\n      this._miterLimit.push(10.0);\r\n      this._transformA.push(1.0);\r\n      this._transformB.push(0.0);\r\n      this._transformC.push(0.0);\r\n      this._transformD.push(1.0);\r\n      this._transformE.push(0.0);\r\n      this._transformF.push(0.0);\r\n      this._shadowBlur.push(0.0);\r\n      this._shadowColor.push(\"#000\");\r\n      this._shadowOffsetX.push(0.0);\r\n      this._shadowOffsetY.push(0.0);\r\n      this._strokeStyle.push(new FillStrokeWhichValue());\r\n      this._textAlign.push(TextAlign.start);\r\n      this._textBaseline.push(TextBaseline.alphabetic);\r\n      this._hardSave.push(false);\r\n      this._path.push(new Path2DElement());\r\n      ++i;\r\n    }\r\n    this._directionCurrent = Direction.inherit;\r\n    this._fillStyleCurrent = new FillStrokeWhichValue();\r\n    this._filterCurrent = \"none\";\r\n    this._fontCurrent = \"none\";\r\n    this._globalAlphaCurrent = 1.0;\r\n    this._globalCompositeOperationCurrent = GlobalCompositeOperation.source_over;\r\n    this._imageSmoothingEnabledCurrent = true;\r\n    this._imageSmoothingQualityCurrent = ImageSmoothingQuality.low;\r\n    this._lineCapCurrent = LineCap.butt;\r\n    this._lineDashCurrent = new Float64Array(0);\r\n    this._lineDashOffsetCurrent = 0.0;\r\n    this._lineJoinCurrent = LineJoin.miter;\r\n    this._lineWidthCurrent = 1.0;\r\n    this._miterLimitCurrent = 10.0;\r\n    this._transformACurrent = 1.0;\r\n    this._transformBCurrent = 0.0;\r\n    this._transformCCurrent = 0.0;\r\n    this._transformDCurrent = 1.0;\r\n    this._transformECurrent = 0.0;\r\n    this._transformFCurrent = 0.0;\r\n    this._shadowBlurCurrent = 0.0;\r\n    this._shadowColorCurrent = \"#000\";\r\n    this._shadowOffsetXCurrent = 0.0;\r\n    this._shadowOffsetYCurrent = 0.0;\r\n    this._strokeStyleCurrent = new FillStrokeWhichValue();\r\n    this._textAlignCurrent = TextAlign.start;\r\n    this._textBaselineCurrent = TextBaseline.alphabetic;\r\n    this.write_path_zero(CanvasInstruction.BeginPath, true);\r\n    super.init();\r\n  }\r\n\r\n  public save(): void {\r\n    var current: i32 = this._stackIndex;\r\n    var next: i32 = current + 1;\r\n    this._direction[next] = this.direction;\r\n    this._fillStyle[this._stackIndex].set(this._fillStyle[next]);\r\n    this._filter[next] = this.filter;\r\n    this._font[next] = this.font;\r\n    this._globalAlpha[next] = this.globalAlpha;\r\n    this._globalCompositeOperation[next] = this.globalCompositeOperation;\r\n    this._imageSmoothingEnabled[next] = this.imageSmoothingEnabled;\r\n    this._imageSmoothingQuality[next] = this.imageSmoothingQuality;\r\n    this._lineCap[next] = this.lineCap;\r\n    this._lineDash[next] = this.getLineDash();\r\n    this._lineDashOffset[next] = this.lineDashOffset;\r\n    this._lineJoin[next] = this.lineJoin;\r\n    this._lineWidth[next] = this.lineWidth;\r\n    this._miterLimit[next] = this.miterLimit;\r\n    this._transformA[next] = this._transformA[current];\r\n    this._transformB[next] = this._transformB[current];\r\n    this._transformC[next] = this._transformC[current];\r\n    this._transformD[next] = this._transformD[current];\r\n    this._transformE[next] = this._transformE[current];\r\n    this._transformF[next] = this._transformF[current];\r\n    this._shadowBlur[next] = this.shadowBlur;\r\n    this._shadowColor[next] = this.shadowColor;\r\n    this._shadowOffsetX[next] = this.shadowOffsetX;\r\n    this._shadowOffsetY[next] = this.shadowOffsetY;\r\n    this._strokeStyle[this._stackIndex].set(this._strokeStyle[next]);\r\n    this._textAlign[next] = this.textAlign;\r\n    this._textBaseline[next] = this.textBaseline;\r\n    this._hardSave[next] = false;\r\n    if (this._hardSave[current]) {\r\n      this.write_save();\r\n    }\r\n    this._stackIndex = next;\r\n  }\r\n\r\n  public restore(): void {\r\n    if (this._stackIndex == 0) return;\r\n    if (this._hardSave[this._stackIndex]) {\r\n      --this._stackIndex;\r\n      this._directionCurrent = this.direction;\r\n      this._fillStyle[this._stackIndex].set(this._fillStyleCurrent);\r\n      this._filterCurrent = this.filter;\r\n      this._fontCurrent = this.font;\r\n      this._globalAlphaCurrent = this.globalAlpha;\r\n      this._globalCompositeOperationCurrent = this.globalCompositeOperation;\r\n      this._imageSmoothingEnabledCurrent = this.imageSmoothingEnabled;\r\n      this._imageSmoothingQualityCurrent = this.imageSmoothingQuality;\r\n      this._lineCapCurrent = this.lineCap;\r\n      this._lineDashCurrent = this.getLineDash();\r\n      this._lineDashOffsetCurrent = this.lineDashOffset;\r\n      this._lineJoinCurrent = this.lineJoin;\r\n      this._lineWidthCurrent = this.lineWidth;\r\n      this._miterLimitCurrent = this.miterLimit;\r\n      this._transformACurrent = this._transformA[this._stackIndex];\r\n      this._transformBCurrent = this._transformB[this._stackIndex];\r\n      this._transformCCurrent = this._transformC[this._stackIndex];\r\n      this._transformDCurrent = this._transformD[this._stackIndex];\r\n      this._transformECurrent = this._transformE[this._stackIndex];\r\n      this._transformFCurrent = this._transformF[this._stackIndex];\r\n      this._shadowBlurCurrent = this.shadowBlur;\r\n      this._shadowColorCurrent = this.shadowColor;\r\n      this._shadowOffsetXCurrent = this.shadowOffsetX;\r\n      this._shadowOffsetYCurrent = this.shadowOffsetY;\r\n      this._fillStyle[this._stackIndex].set(this._fillStyleCurrent);\r\n      this._textAlignCurrent = this.textAlign;\r\n      this._textBaselineCurrent = this.textBaseline;\r\n      this.write_restore();\r\n    } else {\r\n      --this._stackIndex;\r\n    }\r\n  }\r\n\r\n  public commit(): Float64Array {\r\n    super.write_commit();\r\n    super.index = 0;\r\n    return super.data;\r\n  }\r\n\r\n  public arc(x: f64, y: f64, radius: f64, startAngle: f64, endAngle: f64, anticlockwise: bool = false): void {\r\n    this.write_path_six(\r\n      CanvasInstruction.Arc,\r\n      true,\r\n      x,\r\n      y,\r\n      radius,\r\n      startAngle,\r\n      endAngle,\r\n      anticlockwise ? 1.0 : 0.0,\r\n    );\r\n  }\r\n\r\n  public arcTo(x1: f64, y1: f64, x2: f64, y2: f64, radius: f64): void {\r\n    this.write_path_five(\r\n      CanvasInstruction.ArcTo,\r\n      true,\r\n      x1,\r\n      y1,\r\n      x2,\r\n      y2,\r\n      radius,\r\n    );\r\n  }\r\n\r\n  public beginPath(): void {\r\n    this._pathIndex = 1;\r\n  }\r\n\r\n  public bezierCurveTo(cp1x: f64, cp1y: f64, cp2x: f64, cp2y: f64, x: f64, y: f64): void {\r\n    this.write_path_six(\r\n      CanvasInstruction.BezierCurveTo,\r\n      true,\r\n      cp1x,\r\n      cp1y,\r\n      cp2x,\r\n      cp2y,\r\n      x,\r\n      y,\r\n    );\r\n  }\r\n\r\n  public clearRect(x: f64, y: f64, width: f64, height: f64): void {\r\n    this.update_transform();\r\n    this.write_clear_rect(x, y, width, height);\r\n  }\r\n\r\n  public clip(): void {\r\n    if (this._pathIndex == 1) return;\r\n    this._hardSave[this._stackIndex] = true;\r\n    this.write_path_zero(CanvasInstruction.Clip, false);\r\n    this.update_path();\r\n  }\r\n\r\n  public closePath(): void {\r\n    if (this._pathIndex == 1) return;\r\n    this.write_path_zero(CanvasInstruction.ClosePath, false);\r\n  }\r\n\r\n  public createLinearGradient(x0: f64, y0: f64, x1: f64, y1: f64): CanvasGradient {\r\n    var result: CanvasGradient = new CanvasGradient();\r\n    create_linear_gradient(result._id, x0, y0, x1, y1);\r\n    return result;\r\n  }\r\n\r\n  public createPattern(image: Image, type: CanvasPatternType): CanvasPattern {\r\n    var pattern = new CanvasPattern();\r\n    create_pattern(pattern._id, image._index, type);\r\n    return pattern;\r\n  }\r\n\r\n  public createRadialGradient(x0: f64, y0: f64, r0: f64, x1: f64, y1: f64, r1: f64): CanvasGradient {\r\n    var result: CanvasGradient = new CanvasGradient();\r\n    create_radial_gradient(result._id, x0, y0, r0, x1, y1, r1);\r\n    return result;\r\n  }\r\n\r\n\r\n  get currentTransform(): Matrix {\r\n    return Matrix.create(\r\n      this._transformA[this._stackIndex],\r\n      this._transformB[this._stackIndex],\r\n      this._transformC[this._stackIndex],\r\n      this._transformD[this._stackIndex],\r\n      this._transformE[this._stackIndex],\r\n      this._transformF[this._stackIndex],\r\n    );\r\n  }\r\n\r\n  set currentTransform(value: Matrix) {\r\n    this._transformA[this._stackIndex] = value.a;\r\n    this._transformB[this._stackIndex] = value.b;\r\n    this._transformC[this._stackIndex] = value.c;\r\n    this._transformD[this._stackIndex] = value.d;\r\n    this._transformE[this._stackIndex] = value.e;\r\n    this._transformF[this._stackIndex] = value.f;\r\n  }\r\n\r\n  get direction(): Direction {\r\n    return this._direction[this._stackIndex];\r\n  }\r\n\r\n  set direction(value: Direction) {\r\n    this._direction[this._stackIndex] = value;\r\n  }\r\n\r\n  public drawImage(img: Image, sx: f64, sy: f64, swidth: f64, sheight: f64, x: f64, y: f64, width: f64, height: f64): void {\r\n    if (!img._loaded) return;\r\n    if (this.globalAlpha == 0.0) return;\r\n    this.update_filter();\r\n    this.update_global_alpha();\r\n    this.update_global_composite_operation();\r\n    this.update_image_smoothing_enabled();\r\n    this.update_image_smoothing_quality();\r\n    this.update_shadow_blur();\r\n    this.update_shadow_color();\r\n    this.update_shadow_offset_x();\r\n    this.update_shadow_offset_y();\r\n    this.update_transform();\r\n    super.write_draw_image(img, sx, sy, swidth, sheight, x, y, width, height);\r\n  }\r\n\r\n  public drawImagePosition(img: Image, x: f64, y: f64): void {\r\n    if (!img._loaded) return;\r\n    if (this.globalAlpha == 0.0) return;\r\n    this.update_filter();\r\n    this.update_global_alpha();\r\n    this.update_global_composite_operation();\r\n    this.update_image_smoothing_enabled();\r\n    this.update_image_smoothing_quality();\r\n    this.update_shadow_blur();\r\n    this.update_shadow_color();\r\n    this.update_shadow_offset_x();\r\n    this.update_shadow_offset_y();\r\n    this.update_transform();\r\n    super.write_draw_image(img, 0.0, 0.0, img.width, img.height, x, y, img.width, img.height);\r\n  }\r\n\r\n  public drawImageSize(img: Image, x: f64, y: f64, width: f64, height: f64): void {\r\n    if (!img._loaded) return;\r\n    if (this.globalAlpha == 0.0) return;\r\n    this.update_filter();\r\n    this.update_global_alpha();\r\n    this.update_global_composite_operation();\r\n    this.update_image_smoothing_enabled();\r\n    this.update_image_smoothing_quality();\r\n    this.update_shadow_blur();\r\n    this.update_shadow_color();\r\n    this.update_shadow_offset_x();\r\n    this.update_shadow_offset_y();\r\n    this.update_transform();\r\n    super.write_draw_image(img, 0.0, 0.0, img.width, img.heigh, x, y, width, height);\r\n  }\r\n\r\n  public ellipse(x: f64, y: f64, radiusX: f64, radiusY: f64, rotation: f64, startAngle: f64, endAngle: f64, anticlockwise: bool = false): void {\r\n    this.write_path_eight(\r\n      CanvasInstruction.Ellipse,\r\n      true,\r\n      x,\r\n      y,\r\n      radiusX,\r\n      radiusY,\r\n      rotation,\r\n      startAngle,\r\n      endAngle,\r\n      anticlockwise ? 1.0 : 0.0,\r\n    );\r\n  }\r\n\r\n  get filter(): string {\r\n    return this._filter[this._stackIndex];\r\n  }\r\n\r\n  set filter(value: string) {\r\n    this._filter[this._stackIndex] = value;\r\n  }\r\n\r\n  public fill(): void {\r\n    if (this.globalAlpha == 0.0) return;\r\n    this.update_fill_style();\r\n    this.update_filter();\r\n    this.update_global_alpha();\r\n    this.update_global_composite_operation();\r\n    this.update_image_smoothing_enabled();\r\n    this.update_image_smoothing_quality();\r\n    this.update_path();\r\n    this.update_shadow_blur();\r\n    this.update_shadow_color();\r\n    this.update_shadow_offset_x();\r\n    this.update_shadow_offset_y();\r\n    this.update_transform();\r\n    super.write_fill();\r\n  }\r\n\r\n  get fillGradient(): CanvasGradient | null {\r\n    if (this._fillStyle[this._stackIndex].which != FillStrokeWhich.Gradient) return null;\r\n    return this._fillStyle[this._stackIndex].gradient;\r\n  }\r\n\r\n  set fillGradient(value: CanvasGradient | null)  {\r\n    if (value == null) return;\r\n    this._fillStyle[this._stackIndex].gradient = value;\r\n    this._fillStyle[this._stackIndex].which = FillStrokeWhich.Gradient;\r\n  }\r\n\r\n  get fillPattern(): CanvasPattern | null {\r\n    if (this._fillStyle[this._stackIndex].which != FillStrokeWhich.Pattern) return null;\r\n    return this._fillStyle[this._stackIndex].pattern;\r\n  }\r\n\r\n  set fillPattern(value: CanvasPattern | null)  {\r\n    if (value == null) return;\r\n    this._fillStyle[this._stackIndex].pattern = value;\r\n    this._fillStyle[this._stackIndex].which = FillStrokeWhich.Pattern;\r\n  }\r\n\r\n  get fillStyle(): string | null {\r\n    if (this._fillStyle[this._stackIndex].which != FillStrokeWhich.Style) return null;\r\n    return this._fillStyle[this._stackIndex].style;\r\n  }\r\n\r\n  set fillStyle(value: string | null) {\r\n    var result: string = value === null ? \"#000\" : value;\r\n    this._fillStyle[this._stackIndex].style = result;\r\n    this._fillStyle[this._stackIndex].which = FillStrokeWhich.Style;\r\n  }\r\n\r\n  public fillRect(x: f64, y: f64, width: f64, height: f64): void {\r\n    if (width == 0) return;\r\n    if (height == 0) return;\r\n    if (this.globalAlpha == 0.0) return;\r\n    this.update_fill_style();\r\n    this.update_filter();\r\n    this.update_global_alpha();\r\n    this.update_global_composite_operation();\r\n    this.update_image_smoothing_enabled();\r\n    this.update_image_smoothing_quality();\r\n    this.update_shadow_blur();\r\n    this.update_shadow_color();\r\n    this.update_shadow_offset_x();\r\n    this.update_shadow_offset_y();\r\n    this.update_transform();\r\n    super.write_fill_rect(x, y, width, height);\r\n  }\r\n\r\n  public fillText(text: string, x: f64, y: f64, maxWidth: f64 = -1.0): void {\r\n    if (text.length == 0) return;\r\n    if (this.globalAlpha == 0.0) return;\r\n    if (maxWidth == 0.0) return;\r\n    this.update_direction();\r\n    this.update_fill_style();\r\n    this.update_filter();\r\n    this.update_font();\r\n    this.update_global_alpha();\r\n    this.update_global_composite_operation();\r\n    this.update_image_smoothing_enabled();\r\n    this.update_image_smoothing_quality();\r\n    this.update_shadow_blur();\r\n    this.update_shadow_color();\r\n    this.update_shadow_offset_x();\r\n    this.update_shadow_offset_y();\r\n    this.update_text_align();\r\n    this.update_text_baseline();\r\n    this.update_transform();\r\n    super.write_fill_text(text, x, y, maxWidth);\r\n  }\r\n\r\n  get font(): string {\r\n    return this._font[this._stackIndex];\r\n  }\r\n\r\n  set font(value: string) {\r\n    this._font[this._stackIndex] = value;\r\n  }\r\n\r\n  get globalAlpha(): f64 {\r\n    return this._globalAlpha[this._stackIndex];\r\n  }\r\n\r\n  set globalAlpha(value: f64) {\r\n    this._globalAlpha[this._stackIndex] = value;\r\n  }\r\n\r\n  public getLineDash(): Float64Array {\r\n    return copyTypedArray(this._lineDash[this._stackIndex]);\r\n  }\r\n\r\n  public setLineDash(value: Float64Array): void {\r\n    this._lineDash[this._stackIndex] =\r\n      ((value.length & 1) == 1)\r\n        ? doubleTypedArray(value)\r\n        : copyTypedArray(value);\r\n  }\r\n\r\n  get globalCompositeOperation(): GlobalCompositeOperation {\r\n    return this._globalCompositeOperation[this._stackIndex];\r\n  }\r\n  set globalCompositeOperation(value: GlobalCompositeOperation) {\r\n    this._globalCompositeOperation[this._stackIndex] = value;\r\n    super.write_global_composite_operation(value);\r\n  }\r\n\r\n  get imageSmoothingEnabled(): bool {\r\n    return this._imageSmoothingEnabled[this._stackIndex];\r\n  }\r\n\r\n  set imageSmoothingEnabled(value: bool) {\r\n    this._imageSmoothingEnabled[this._stackIndex] = value;\r\n  }\r\n\r\n  get imageSmoothingQuality(): ImageSmoothingQuality {\r\n    return this._imageSmoothingQuality[this._stackIndex];\r\n  }\r\n\r\n  set imageSmoothingQuality(value: ImageSmoothingQuality) {\r\n    this._imageSmoothingQuality[this._stackIndex] = value;\r\n  }\r\n\r\n  get lineCap(): LineCap {\r\n    return this._lineCap[this._stackIndex];\r\n  }\r\n\r\n  set lineCap(value: LineCap) {\r\n    this._lineCap[this._stackIndex] = value;\r\n  }\r\n\r\n  get lineDashOffset(): f64 {\r\n    return this._lineDashOffset[this._stackIndex];\r\n  }\r\n\r\n  set lineDashOffset(value: f64) {\r\n    this._lineDashOffset[this._stackIndex] = value;\r\n  }\r\n\r\n  get lineJoin(): LineJoin {\r\n    return this._lineJoin[this._stackIndex];\r\n  }\r\n\r\n  set lineJoin(value: LineJoin) {\r\n    this._lineJoin[this._stackIndex] = value;\r\n  }\r\n\r\n  public lineTo(x: f64, y: f64): void {\r\n    this.write_path_two(CanvasInstruction.LineTo, true, x, y);\r\n  }\r\n\r\n  get lineWidth(): f64 {\r\n    return this._lineWidth[this._stackIndex];\r\n  }\r\n\r\n  set lineWidth(value: f64) {\r\n    this._lineWidth[this._stackIndex] = value;\r\n  }\r\n\r\n  get miterLimit(): f64 {\r\n    return this._miterLimit[this._stackIndex];\r\n  }\r\n\r\n  set miterLimit(value: f64) {\r\n    this._miterLimit[this._stackIndex] = value;\r\n  }\r\n\r\n  public moveTo(x: f64, y: f64): void {\r\n    this.write_path_two(\r\n      CanvasInstruction.MoveTo,\r\n      true,\r\n      x,\r\n      y,\r\n    );\r\n  }\r\n\r\n  public quadraticCurveTo(cpx: f64, cpy: f64, x: f64, y: f64): void {\r\n    this.write_path_four(\r\n      CanvasInstruction.QuadraticCurveTo,\r\n      true,\r\n      cpx,\r\n      cpy,\r\n      x,\r\n      y,\r\n    );\r\n  }\r\n\r\n  public rect(x: f64, y: f64, width: f64, height: f64): void {\r\n    this.write_path_four(\r\n      CanvasInstruction.Rect,\r\n      true,\r\n      x,\r\n      y,\r\n      width,\r\n      height,\r\n    );\r\n  }\r\n\r\n  public rotate(angle: f64): void {\r\n    var cos: f64 = Math.cos(angle);\r\n    var sin: f64 = Math.sin(angle);\r\n\r\n    var a: f64 = this._transformA[this._stackIndex];\r\n    var b: f64 = this._transformB[this._stackIndex];\r\n    var c: f64 = this._transformC[this._stackIndex];\r\n    var d: f64 = this._transformD[this._stackIndex];\r\n\r\n    this._transformA[this._stackIndex] = a * cos + c * sin;\r\n    this._transformB[this._stackIndex] = b * cos + d * sin;\r\n    this._transformC[this._stackIndex] = a * -sin + c * cos;\r\n    this._transformD[this._stackIndex] = b * -sin + d * cos;\r\n  }\r\n\r\n  public scale(x: f64, y: f64): void {\r\n    this._transformA[this._stackIndex] *= x;\r\n    this._transformB[this._stackIndex] *= x;\r\n    this._transformC[this._stackIndex] *= y;\r\n    this._transformD[this._stackIndex] *= y;\r\n  }\r\n\r\n  public setTransform(a: f64, b: f64, c: f64, d: f64, e: f64, f: f64): void {\r\n    this._transformA[this._stackIndex] = a;\r\n    this._transformB[this._stackIndex] = b;\r\n    this._transformC[this._stackIndex] = c;\r\n    this._transformD[this._stackIndex] = d;\r\n    this._transformE[this._stackIndex] = e;\r\n    this._transformF[this._stackIndex] = f;\r\n  }\r\n\r\n  get shadowBlur(): f64 {\r\n    return this._shadowBlur[this._stackIndex];\r\n  }\r\n\r\n  set shadowBlur(value: f64) {\r\n    this._shadowBlur[this._stackIndex] = value;\r\n  }\r\n\r\n  get shadowColor(): string {\r\n    return this._shadowColor[this._stackIndex];\r\n  }\r\n\r\n  set shadowColor(value: string) {\r\n    this._shadowColor[this._stackIndex] = value;\r\n  }\r\n\r\n  get shadowOffsetX(): f64 {\r\n    return this._shadowOffsetX[this._stackIndex];\r\n  }\r\n\r\n  set shadowOffsetX(value: f64) {\r\n    this._shadowOffsetX[this._stackIndex] = value;\r\n  }\r\n\r\n  get shadowOffsetY(): f64 {\r\n    return this._shadowOffsetY[this._stackIndex];\r\n  }\r\n\r\n  set shadowOffsetY(value: f64) {\r\n    this._shadowOffsetY[this._stackIndex] = value;\r\n  }\r\n\r\n  public stroke(): void {\r\n    if (this.globalAlpha == 0.0) return;\r\n    if (this._pathIndex == 1) return;\r\n    this.update_filter();\r\n    this.update_global_alpha();\r\n    this.update_global_composite_operation();\r\n    this.update_image_smoothing_enabled();\r\n    this.update_image_smoothing_quality();\r\n    this.update_line_cap();\r\n    this.update_line_dash();\r\n    this.update_line_dash_offset();\r\n    this.update_line_join();\r\n    this.update_line_width();\r\n    this.update_miter_limit();\r\n    this.update_path();\r\n    this.update_shadow_blur();\r\n    this.update_shadow_color();\r\n    this.update_shadow_offset_x();\r\n    this.update_shadow_offset_y();\r\n    this.update_stroke_style();\r\n    this.update_transform();\r\n    super.write_stroke();\r\n  }\r\n\r\n  public strokeRect(x: f64, y: f64, width: f64, height: f64): void {\r\n    if (this.globalAlpha == 0.0) return;\r\n    if (width == 0.0) return;\r\n    if (height == 0.0) return;\r\n    this.update_filter();\r\n    this.update_global_alpha();\r\n    this.update_global_composite_operation();\r\n    this.update_image_smoothing_enabled();\r\n    this.update_image_smoothing_quality();\r\n    this.update_line_cap();\r\n    this.update_line_dash();\r\n    this.update_line_dash_offset();\r\n    this.update_line_join();\r\n    this.update_line_width();\r\n    this.update_miter_limit();\r\n    this.update_shadow_blur();\r\n    this.update_shadow_color();\r\n    this.update_shadow_offset_x();\r\n    this.update_shadow_offset_y();\r\n    this.update_stroke_style();\r\n    this.update_transform();\r\n    super.write_stroke_rect(x, y, width, height);\r\n  }\r\n\r\n  get strokeStyle(): string | null {\r\n    if (this._strokeStyle[this._stackIndex].which != FillStrokeWhich.Style) return null;\r\n    return this._strokeStyle[this._stackIndex].style;\r\n  }\r\n\r\n  set strokeStyle(value: string | null) {\r\n    var result: string = value === null ? \"#000\" : value;\r\n    this._strokeStyle[this._stackIndex].style = result;\r\n    this._strokeStyle[this._stackIndex].which = FillStrokeWhich.Style;\r\n  }\r\n\r\n  get strokeGradient(): CanvasGradient | null {\r\n    if (this._strokeStyle[this._stackIndex].which != FillStrokeWhich.Gradient) return null;\r\n    return this._strokeStyle[this._stackIndex].gradient;\r\n  }\r\n\r\n  set strokeGradient(value: CanvasGradient | null)  {\r\n    if (value == null) return;\r\n    this._strokeStyle[this._stackIndex].gradient = value;\r\n    this._strokeStyle[this._stackIndex].which = FillStrokeWhich.Gradient;\r\n  }\r\n\r\n  get strokePattern(): CanvasPattern | null {\r\n    if (this._strokeStyle[this._stackIndex].which != FillStrokeWhich.Pattern) return null;\r\n    return this._strokeStyle[this._stackIndex].pattern;\r\n  }\r\n\r\n  set strokePattern(value: CanvasPattern | null)  {\r\n    if (value == null) return;\r\n    this._strokeStyle[this._stackIndex].pattern = value;\r\n    this._strokeStyle[this._stackIndex].which = FillStrokeWhich.Pattern;\r\n  }\r\n\r\n  public strokeText(text: string, x: f64, y: f64, maxWidth: f64 = -1.0): void {\r\n    if (text.length == 0) return;\r\n    if (this._globalAlpha[this._stackIndex] == 0.0) return;\r\n    if (maxWidth == 0.0) return;\r\n    this.update_direction();\r\n    this.update_filter();\r\n    this.update_font();\r\n    this.update_global_alpha();\r\n    this.update_global_composite_operation();\r\n    this.update_image_smoothing_enabled();\r\n    this.update_image_smoothing_quality();\r\n    this.update_line_cap();\r\n    this.update_line_dash();\r\n    this.update_line_dash_offset();\r\n    this.update_line_join();\r\n    this.update_line_width();\r\n    this.update_miter_limit();\r\n    this.update_shadow_blur();\r\n    this.update_shadow_color();\r\n    this.update_shadow_offset_x();\r\n    this.update_shadow_offset_y();\r\n    this.update_stroke_style();\r\n    this.update_text_align();\r\n    this.update_text_baseline();\r\n    this.update_transform();\r\n    super.write_stroke_text(text, x, y, maxWidth);\r\n  }\r\n\r\n  get textAlign(): TextAlign {\r\n    return this._textAlign[this._stackIndex];\r\n  }\r\n\r\n  set textAlign(value: TextAlign) {\r\n    this._textAlign[this._stackIndex] = value;\r\n  }\r\n\r\n  get textBaseline(): TextBaseline {\r\n    return this._textBaseline[this._stackIndex];\r\n  }\r\n\r\n  set textBaseline(value: TextBaseline) {\r\n    this._textBaseline[this._stackIndex] = value;\r\n  }\r\n\r\n  public transform(a: f64, b: f64, c: f64, d: f64, e: f64, f: f64): void {\r\n    var sa: f64 = this._transformA[this._stackIndex];\r\n    var sb: f64 = this._transformB[this._stackIndex];\r\n    var sc: f64 = this._transformC[this._stackIndex];\r\n    var sd: f64 = this._transformD[this._stackIndex];\r\n    var se: f64 = this._transformE[this._stackIndex];\r\n    var sf: f64 = this._transformF[this._stackIndex];\r\n    this._transformA[this._stackIndex] = sa * a + sc * b;\r\n    this._transformB[this._stackIndex] = sb * a + sd * b;\r\n    this._transformC[this._stackIndex] = sa * c + sc * d;\r\n    this._transformD[this._stackIndex] = sb * c + sd * d;\r\n    this._transformE[this._stackIndex] = sa * e + sc * f + se;\r\n    this._transformF[this._stackIndex] = sb * e + sd * f + sf;\r\n  }\r\n\r\n  public translate(x: f64, y: f64): void {\r\n    this._transformE[this._stackIndex] += this._transformA[this._stackIndex] * x + this._transformC[this._stackIndex] * y;\r\n    this._transformF[this._stackIndex] += this._transformB[this._stackIndex] * x + this._transformD[this._stackIndex] * y;\r\n  }\r\n\r\n  private update_direction(): void {\r\n    if (this._directionCurrent == this._direction[this._stackIndex]) return;\r\n    this._directionCurrent = this._direction[this._stackIndex];\r\n    super.write_direction(this._directionCurrent);\r\n  }\r\n\r\n  private update_fill_style(): void {\r\n    if (this._fillStyleCurrent == this._fillStyle[this._stackIndex]) return;\r\n    this._fillStyle[this._stackIndex].set(this._fillStyleCurrent);\r\n    switch (this._fillStyleCurrent.which) {\r\n      case FillStrokeWhich.Gradient:\r\n        super.write_fill_gradient(<CanvasGradient>this._fillStyleCurrent.gradient);\r\n        return;\r\n      case FillStrokeWhich.Pattern:\r\n        super.write_fill_pattern(<CanvasPattern>this._fillStyleCurrent.pattern);\r\n        return;\r\n      case FillStrokeWhich.Style:\r\n        super.write_fill_style(<string>this._fillStyleCurrent.style);\r\n        return;\r\n    }\r\n  }\r\n\r\n  private update_filter(): void {\r\n    if (this._filterCurrent == this._filter[this._stackIndex]) return;\r\n    this._filterCurrent = this._filter[this._stackIndex];\r\n    super.write_filter(this._filterCurrent);\r\n  }\r\n\r\n  private update_font(): void {\r\n    if (this._fontCurrent == this._font[this._stackIndex]) return;\r\n    this._fontCurrent = this._font[this._stackIndex];\r\n    super.write_font(this._fontCurrent);\r\n  }\r\n\r\n  private update_global_alpha(): void {\r\n    if (this._globalAlphaCurrent == this._globalAlpha[this._stackIndex]) return;\r\n    this._globalAlphaCurrent = this._globalAlpha[this._stackIndex];\r\n    super.write_global_alpha(this._globalAlphaCurrent);\r\n  }\r\n\r\n  private update_global_composite_operation(): void {\r\n    if (this._globalCompositeOperationCurrent == this._globalCompositeOperation[this._stackIndex]) return;\r\n    this._globalCompositeOperationCurrent = this._globalCompositeOperation[this._stackIndex];\r\n    super.write_global_composite_operation(this._globalCompositeOperationCurrent);\r\n  }\r\n\r\n  private update_image_smoothing_enabled(): void {\r\n    if (this._imageSmoothingEnabledCurrent == this._imageSmoothingEnabled[this._stackIndex]) return;\r\n    this._imageSmoothingEnabledCurrent = this._imageSmoothingEnabled[this._stackIndex];\r\n    super.write_image_smoothing_enabled(this._imageSmoothingEnabledCurrent);\r\n  }\r\n\r\n  private update_image_smoothing_quality(): void {\r\n    if (this._imageSmoothingQualityCurrent == this._imageSmoothingQuality[this._stackIndex]) return;\r\n    this._imageSmoothingQualityCurrent = this._imageSmoothingQuality[this._stackIndex];\r\n    super.write_image_smoothing_quality(this._imageSmoothingQualityCurrent);\r\n  }\r\n\r\n  private update_line_cap(): void {\r\n    if (this._lineCapCurrent == this._lineCap[this._stackIndex]) return;\r\n    this._lineCapCurrent = this._lineCap[this._stackIndex];\r\n    super.write_line_cap(this._lineCapCurrent);\r\n  }\r\n\r\n  private update_line_join(): void {\r\n    if (this._lineJoinCurrent == this._lineJoin[this._stackIndex]) return;\r\n    this._lineJoinCurrent = this._lineJoin[this._stackIndex];\r\n    super.write_line_join(this._lineJoinCurrent);\r\n  }\r\n\r\n  private update_line_width(): void {\r\n    if (this._lineWidthCurrent == this._lineWidth[this._stackIndex]) return;\r\n    this._lineWidthCurrent = this._lineWidth[this._stackIndex];\r\n    super.write_line_width(this._lineWidthCurrent);\r\n  }\r\n\r\n  private update_miter_limit(): void {\r\n    if (this._miterLimitCurrent == this._miterLimit[this._stackIndex]) return;\r\n    this._miterLimitCurrent = this._miterLimit[this._stackIndex];\r\n    super.write_miter_limit(this._miterLimitCurrent);\r\n  }\r\n\r\n  private update_line_dash_offset(): void {\r\n    if (this._lineDashOffsetCurrent == this._lineDashOffset[this._stackIndex]) return;\r\n    this._lineDashOffsetCurrent = this._lineDashOffset[this._stackIndex];\r\n    super.write_line_dash_offset(this._lineDashOffsetCurrent);\r\n  }\r\n\r\n  @inline\r\n  private update_line_dash(): void {\r\n    var next: Float64Array = this._lineDash[this._stackIndex];\r\n    var current: Float64Array = this._lineDashCurrent;\r\n    if (next.length != current.length) {\r\n      this._lineDashCurrent = copyTypedArray(next);\r\n      super.write_line_dash(next);\r\n      return;\r\n    }\r\n    var i: i32 = 0;\r\n    var length: i32 = next.length;\r\n    while (i < length) {\r\n      if (next[i] != current[i]) {\r\n        this._lineDashCurrent = copyTypedArray(next);\r\n        super.write_line_dash(next);\r\n        break;\r\n      }\r\n      ++i;\r\n    }\r\n  }\r\n\r\n  private update_shadow_blur(): void {\r\n    if (this._shadowBlurCurrent == this._shadowBlur[this._stackIndex]) return;\r\n    this._shadowBlurCurrent = this._shadowBlur[this._stackIndex];\r\n    super.write_shadow_blur(this._shadowBlurCurrent);\r\n  }\r\n\r\n  private update_shadow_color(): void {\r\n    if (this._shadowColorCurrent == this._shadowColor[this._stackIndex]) return;\r\n    this._shadowColorCurrent = this._shadowColor[this._stackIndex];\r\n    super.write_shadow_color(this._shadowColorCurrent);\r\n  }\r\n\r\n  private update_shadow_offset_x(): void {\r\n    if (this._shadowOffsetXCurrent == this._shadowOffsetX[this._stackIndex]) return;\r\n    this._shadowOffsetXCurrent = this._shadowOffsetX[this._stackIndex];\r\n    super.write_shadow_offset_x(this._shadowOffsetXCurrent);\r\n  }\r\n\r\n  private update_shadow_offset_y(): void {\r\n    if (this._shadowOffsetYCurrent == this._shadowOffsetY[this._stackIndex]) return;\r\n    this._shadowOffsetYCurrent = this._shadowOffsetY[this._stackIndex];\r\n    super.write_shadow_offset_y(this._shadowOffsetYCurrent);\r\n  }\r\n\r\n  private update_stroke_style(): void {\r\n    if (this._strokeStyleCurrent == this._strokeStyle[this._stackIndex]) return;\r\n    this._strokeStyle[this._stackIndex].set(this._strokeStyleCurrent);\r\n    switch (this._strokeStyleCurrent.which) {\r\n      case FillStrokeWhich.Gradient:\r\n        super.write_stroke_gradient(<CanvasGradient>this._strokeStyleCurrent.gradient);\r\n        return;\r\n      case FillStrokeWhich.Pattern:\r\n        super.write_stroke_pattern(<CanvasPattern>this._strokeStyleCurrent.pattern);\r\n        return;\r\n      case FillStrokeWhich.Style:\r\n        super.write_stroke_style(<string>this._strokeStyleCurrent.style);\r\n        return;\r\n    }\r\n  }\r\n\r\n  private update_text_align(): void {\r\n    if (this._textAlignCurrent == this._textAlign[this._stackIndex]) return;\r\n    this._textAlignCurrent = this._textAlign[this._stackIndex];\r\n    super.write_text_align(this._textAlignCurrent);\r\n  }\r\n\r\n  private update_text_baseline(): void {\r\n    if (this._textBaselineCurrent == this._textBaseline[this._stackIndex]) return;\r\n    this._textBaselineCurrent = this._textBaseline[this._stackIndex];\r\n    super.write_text_baseline(this._textBaselineCurrent);\r\n  }\r\n\r\n  private update_transform(): void {\r\n    if (\r\n      this._transformA[this._stackIndex] == this._transformACurrent\r\n      && this._transformB[this._stackIndex] == this._transformBCurrent\r\n      && this._transformC[this._stackIndex] == this._transformCCurrent\r\n      && this._transformD[this._stackIndex] == this._transformDCurrent\r\n      && this._transformE[this._stackIndex] == this._transformECurrent\r\n      && this._transformF[this._stackIndex] == this._transformFCurrent\r\n    ) return;\r\n    this._transformACurrent = this._transformA[this._stackIndex];\r\n    this._transformBCurrent = this._transformB[this._stackIndex];\r\n    this._transformCCurrent = this._transformC[this._stackIndex];\r\n    this._transformDCurrent = this._transformD[this._stackIndex];\r\n    this._transformECurrent = this._transformE[this._stackIndex];\r\n    this._transformFCurrent = this._transformF[this._stackIndex];\r\n    super.write_set_transform(\r\n      this._transformACurrent,\r\n      this._transformBCurrent,\r\n      this._transformCCurrent,\r\n      this._transformDCurrent,\r\n      this._transformECurrent,\r\n      this._transformFCurrent,\r\n    );\r\n  }\r\n\r\n  @inline\r\n  private update_path(): void {\r\n    var i: i32 = 0;\r\n    var pathItem: Path2DElement;\r\n    while (i < this._pathIndex) {\r\n      pathItem = this._path[i];\r\n      if (pathItem.updateTransform) {\r\n        this._transformA[this._stackIndex] = pathItem.transformA;\r\n        this._transformB[this._stackIndex] = pathItem.transformB;\r\n        this._transformC[this._stackIndex] = pathItem.transformC;\r\n        this._transformD[this._stackIndex] = pathItem.transformD;\r\n        this._transformE[this._stackIndex] = pathItem.transformE;\r\n        this._transformF[this._stackIndex] = pathItem.transformF;\r\n        this.update_transform();\r\n      }\r\n      switch (pathItem.count) {\r\n        case 0: {\r\n          super.write_zero(pathItem.instruction);\r\n          break;\r\n        }\r\n        case 1: {\r\n          super.write_one(pathItem.instruction, pathItem.a);\r\n          break;\r\n        }\r\n        case 2: {\r\n          super.write_two(pathItem.instruction, pathItem.a, pathItem.b);\r\n          break;\r\n        }\r\n        case 4: {\r\n          super.write_four(pathItem.instruction, pathItem.a, pathItem.b, pathItem.c, pathItem.d);\r\n          break;\r\n        }\r\n        case 5: {\r\n          super.write_five(pathItem.instruction, pathItem.a, pathItem.b, pathItem.c, pathItem.d, pathItem.e);\r\n          break;\r\n        }\r\n        case 6: {\r\n          super.write_six(pathItem.instruction, pathItem.a, pathItem.b, pathItem.c, pathItem.d, pathItem.e, pathItem.f);\r\n          break;\r\n        }\r\n        case 8: {\r\n          super.write_eight(pathItem.instruction, pathItem.a, pathItem.b, pathItem.c, pathItem.d, pathItem.e, pathItem.f, pathItem.g, pathItem.h);\r\n          break;\r\n        }\r\n      }\r\n      ++i;\r\n    }\r\n    this._pathIndex = 1;\r\n  }\r\n\r\n  @inline\r\n  private write_path_zero(instruction: CanvasInstruction, updateTransform: bool): void {\r\n    var pathItem: Path2DElement = this._path[this._pathIndex++];\r\n    pathItem.instruction = instruction\r\n    pathItem.count = 0;\r\n    if (updateTransform) {\r\n      pathItem.transformA = this._transformA[this._stackIndex];\r\n      pathItem.transformB = this._transformB[this._stackIndex];\r\n      pathItem.transformC = this._transformC[this._stackIndex];\r\n      pathItem.transformD = this._transformD[this._stackIndex];\r\n      pathItem.transformE = this._transformE[this._stackIndex];\r\n      pathItem.transformF = this._transformF[this._stackIndex];\r\n      pathItem.updateTransform = true;\r\n    }\r\n  }\r\n\r\n  @inline\r\n  private write_path_two(instruction: CanvasInstruction, updateTransform: bool, a: f64, b: f64): void {\r\n    var pathItem: Path2DElement = this._path[this._pathIndex++];\r\n    pathItem.instruction = instruction\r\n    pathItem.count = 2;\r\n    pathItem.a = a;\r\n    pathItem.b = b;\r\n    if (updateTransform) {\r\n      pathItem.transformA = this._transformA[this._stackIndex];\r\n      pathItem.transformB = this._transformB[this._stackIndex];\r\n      pathItem.transformC = this._transformC[this._stackIndex];\r\n      pathItem.transformD = this._transformD[this._stackIndex];\r\n      pathItem.transformE = this._transformE[this._stackIndex];\r\n      pathItem.transformF = this._transformF[this._stackIndex];\r\n      pathItem.updateTransform = true;\r\n    }\r\n  }\r\n\r\n  @inline\r\n  private write_path_four(instruction: CanvasInstruction, updateTransform: bool, a: f64, b: f64, c: f64, d: f64): void {\r\n    var pathItem: Path2DElement = this._path[this._pathIndex++];\r\n    pathItem.instruction = instruction\r\n    pathItem.count = 4;\r\n    pathItem.a = a;\r\n    pathItem.b = b;\r\n    pathItem.c = c;\r\n    pathItem.d = d;\r\n    if (updateTransform) {\r\n      pathItem.transformA = this._transformA[this._stackIndex];\r\n      pathItem.transformB = this._transformB[this._stackIndex];\r\n      pathItem.transformC = this._transformC[this._stackIndex];\r\n      pathItem.transformD = this._transformD[this._stackIndex];\r\n      pathItem.transformE = this._transformE[this._stackIndex];\r\n      pathItem.transformF = this._transformF[this._stackIndex];\r\n      pathItem.updateTransform = true;\r\n    }\r\n  }\r\n\r\n  @inline\r\n  private write_path_five(instruction: CanvasInstruction, updateTransform: bool, a: f64, b: f64, c: f64, d: f64, e: f64): void {\r\n    var pathItem: Path2DElement = this._path[this._pathIndex++];\r\n    pathItem.instruction = instruction\r\n    pathItem.count = 5;\r\n    pathItem.a = a;\r\n    pathItem.b = b;\r\n    pathItem.c = c;\r\n    pathItem.d = d;\r\n    pathItem.e = e;\r\n    if (updateTransform) {\r\n      pathItem.transformA = this._transformA[this._stackIndex];\r\n      pathItem.transformB = this._transformB[this._stackIndex];\r\n      pathItem.transformC = this._transformC[this._stackIndex];\r\n      pathItem.transformD = this._transformD[this._stackIndex];\r\n      pathItem.transformE = this._transformE[this._stackIndex];\r\n      pathItem.transformF = this._transformF[this._stackIndex];\r\n      pathItem.updateTransform = true;\r\n    }\r\n  }\r\n\r\n  @inline\r\n  private write_path_six(instruction: CanvasInstruction, updateTransform: bool, a: f64, b: f64, c: f64, d: f64, e: f64, f: f64): void {\r\n    var pathItem: Path2DElement = this._path[this._pathIndex++];\r\n    pathItem.instruction = instruction\r\n    pathItem.count = 6;\r\n    pathItem.a = a;\r\n    pathItem.b = b;\r\n    pathItem.c = c;\r\n    pathItem.d = d;\r\n    pathItem.e = e;\r\n    pathItem.f = f;\r\n    if (updateTransform) {\r\n      pathItem.transformA = this._transformA[this._stackIndex];\r\n      pathItem.transformB = this._transformB[this._stackIndex];\r\n      pathItem.transformC = this._transformC[this._stackIndex];\r\n      pathItem.transformD = this._transformD[this._stackIndex];\r\n      pathItem.transformE = this._transformE[this._stackIndex];\r\n      pathItem.transformF = this._transformF[this._stackIndex];\r\n      pathItem.updateTransform = true;\r\n    }\r\n  }\r\n\r\n  @inline\r\n  private write_path_eight(instruction: CanvasInstruction, updateTransform: bool, a: f64, b: f64, c: f64, d: f64, e: f64, f: f64, g: f64, h: f64): void {\r\n    var pathItem: Path2DElement = this._path[this._pathIndex++];\r\n    pathItem.instruction = instruction\r\n    pathItem.count = 8;\r\n    pathItem.a = a;\r\n    pathItem.b = b;\r\n    pathItem.c = c;\r\n    pathItem.d = d;\r\n    pathItem.e = e;\r\n    pathItem.f = f;\r\n    pathItem.g = g;\r\n    pathItem.h = h;\r\n    if (updateTransform) {\r\n      pathItem.transformA = this._transformA[this._stackIndex];\r\n      pathItem.transformB = this._transformB[this._stackIndex];\r\n      pathItem.transformC = this._transformC[this._stackIndex];\r\n      pathItem.transformD = this._transformD[this._stackIndex];\r\n      pathItem.transformE = this._transformE[this._stackIndex];\r\n      pathItem.transformF = this._transformF[this._stackIndex];\r\n      pathItem.updateTransform = true;\r\n    }\r\n  }\r\n}","import {\r\n  MAX_BLENGTH,\r\n  HEADER_SIZE,\r\n  allocateUnsafe,\r\n  reallocateUnsafe,\r\n  LOAD,\r\n  STORE\r\n} from \"./internal/arraybuffer\";\r\n\r\nimport {\r\n  allocateUnsafe as allocateUnsafeString,\r\n  freeUnsafe as freeUnsafeString,\r\n  copyUnsafe as copyUnsafeString\r\n} from \"./internal/string\";\r\n\r\nimport {\r\n  COMPARATOR,\r\n  SORT\r\n} from \"./internal/sort\";\r\n\r\nimport {\r\n  itoa,\r\n  dtoa,\r\n  itoa_stream,\r\n  dtoa_stream,\r\n  MAX_DOUBLE_LENGTH\r\n} from \"./internal/number\";\r\n\r\nimport {\r\n  isArray as builtin_isArray\r\n} from \"./builtins\";\r\n\r\nexport class Array<T> {\r\n  [key: number]: T; // compatibility only\r\n\r\n  /* @internal */ buffer_: ArrayBuffer;\r\n  /* @internal */ length_: i32;\r\n\r\n  @inline static isArray<U>(value: U): bool {\r\n    return builtin_isArray(value) && value !== null;\r\n  }\r\n\r\n  constructor(length: i32 = 0) {\r\n    const MAX_LENGTH = MAX_BLENGTH >>> alignof<T>();\r\n    if (<u32>length > <u32>MAX_LENGTH) throw new RangeError(\"Invalid array length\");\r\n    var byteLength = length << alignof<T>();\r\n    var buffer = allocateUnsafe(byteLength);\r\n    this.buffer_ = buffer;\r\n    this.length_ = length;\r\n    memory.fill(\r\n      changetype<usize>(buffer) + HEADER_SIZE,\r\n      0,\r\n      <usize>byteLength\r\n    );\r\n  }\r\n\r\n  @inline\r\n  get length(): i32 {\r\n    return this.length_;\r\n  }\r\n\r\n  set length(length: i32) {\r\n    var buffer = this.buffer_;\r\n    var capacity = buffer.byteLength >>> alignof<T>();\r\n    if (<u32>length > <u32>capacity) {\r\n      const MAX_LENGTH = MAX_BLENGTH >>> alignof<T>();\r\n      if (<u32>length > <u32>MAX_LENGTH) throw new RangeError(\"Invalid array length\");\r\n      buffer = reallocateUnsafe(buffer, length << alignof<T>());\r\n      this.buffer_ = buffer;\r\n    }\r\n    this.length_ = length;\r\n  }\r\n\r\n  every(callbackfn: (element: T, index: i32, array: Array<T>) => bool): bool {\r\n    var buffer = this.buffer_;\r\n    for (let index = 0, toIndex = this.length_; index < min(toIndex, this.length_); ++index) {\r\n      if (!callbackfn(LOAD<T>(buffer, index), index, this)) return false;\r\n    }\r\n    return true;\r\n  }\r\n\r\n  findIndex(predicate: (element: T, index: i32, array: Array<T>) => bool): i32 {\r\n    var buffer = this.buffer_;\r\n    for (let index = 0, toIndex = this.length_; index < min(toIndex, this.length_); ++index) {\r\n      if (predicate(LOAD<T>(buffer, index), index, this)) return index;\r\n    }\r\n    return -1;\r\n  }\r\n\r\n  @operator(\"[]\")\r\n  private __get(index: i32): T {\r\n    var buffer = this.buffer_;\r\n    return <u32>index < <u32>(buffer.byteLength >>> alignof<T>())\r\n      ? LOAD<T>(buffer, index)\r\n      : <T>unreachable();\r\n  }\r\n\r\n  @operator(\"{}\")\r\n  private __unchecked_get(index: i32): T {\r\n    return LOAD<T>(this.buffer_, index);\r\n  }\r\n\r\n  @operator(\"[]=\")\r\n  private __set(index: i32, value: T): void {\r\n    var buffer = this.buffer_;\r\n    var capacity = buffer.byteLength >>> alignof<T>();\r\n    if (<u32>index >= <u32>capacity) {\r\n      const MAX_LENGTH = MAX_BLENGTH >>> alignof<T>();\r\n      if (<u32>index >= <u32>MAX_LENGTH) throw new Error(\"Invalid array length\");\r\n      buffer = reallocateUnsafe(buffer, (index + 1) << alignof<T>());\r\n      this.buffer_ = buffer;\r\n      this.length_ = index + 1;\r\n    }\r\n    STORE<T>(buffer, index, value);\r\n    if (isManaged<T>()) __gc_link(changetype<usize>(this), changetype<usize>(value)); // tslint:disable-line\r\n  }\r\n\r\n  @operator(\"{}=\")\r\n  private __unchecked_set(index: i32, value: T): void {\r\n    STORE<T>(this.buffer_, index, value);\r\n    if (isManaged<T>()) __gc_link(changetype<usize>(this), changetype<usize>(value)); // tslint:disable-line\r\n  }\r\n\r\n  fill(value: T, start: i32 = 0, end: i32 = i32.MAX_VALUE): this {\r\n    var buffer = this.buffer_;\r\n    var len    = this.length_;\r\n\r\n    start = start < 0 ? max(len + start, 0) : min(start, len);\r\n    end   = end   < 0 ? max(len + end,   0) : min(end,   len);\r\n\r\n    if (sizeof<T>() == 1) {\r\n      if (start < end) {\r\n        memory.fill(\r\n          changetype<usize>(buffer) + start + HEADER_SIZE,\r\n          <u8>value,\r\n          <usize>(end - start)\r\n        );\r\n      }\r\n    } else {\r\n      for (; start < end; ++start) {\r\n        STORE<T>(buffer, start, value);\r\n      }\r\n    }\r\n    return this;\r\n  }\r\n\r\n  @inline\r\n  includes(searchElement: T, fromIndex: i32 = 0): bool {\r\n    return this.indexOf(searchElement, fromIndex) >= 0;\r\n  }\r\n\r\n  indexOf(searchElement: T, fromIndex: i32 = 0): i32 {\r\n    var length = this.length_;\r\n    if (length == 0 || fromIndex >= length) return -1;\r\n    if (fromIndex < 0) fromIndex = max(length + fromIndex, 0);\r\n    var buffer = this.buffer_;\r\n    while (fromIndex < length) {\r\n      if (LOAD<T>(buffer, fromIndex) == searchElement) return fromIndex;\r\n      ++fromIndex;\r\n    }\r\n    return -1;\r\n  }\r\n\r\n  lastIndexOf(searchElement: T, fromIndex: i32 = this.length_): i32 {\r\n    var length = this.length_;\r\n    if (length == 0) return -1;\r\n    if (fromIndex < 0) fromIndex = length + fromIndex; // no need to clamp\r\n    else if (fromIndex >= length) fromIndex = length - 1;\r\n    var buffer = this.buffer_;\r\n    while (fromIndex >= 0) {                           // ^\r\n      if (LOAD<T>(buffer, fromIndex) == searchElement) return fromIndex;\r\n      --fromIndex;\r\n    }\r\n    return -1;\r\n  }\r\n\r\n  push(element: T): i32 {\r\n    var length = this.length_;\r\n    var buffer = this.buffer_;\r\n    var capacity = buffer.byteLength >>> alignof<T>();\r\n    var newLength = length + 1; // safe only if length is checked\r\n    if (<u32>length >= <u32>capacity) {\r\n      const MAX_LENGTH = MAX_BLENGTH >>> alignof<T>();\r\n      if (<u32>length >= <u32>MAX_LENGTH) throw new Error(\"Invalid array length\");\r\n      buffer = reallocateUnsafe(buffer, newLength << alignof<T>());\r\n      this.buffer_ = buffer;\r\n    }\r\n    this.length_ = newLength;\r\n    STORE<T>(buffer, length, element);\r\n    if (isManaged<T>()) __gc_link(changetype<usize>(this), changetype<usize>(element)); // tslint:disable-line\r\n    return newLength;\r\n  }\r\n\r\n  concat(items: Array<T>): Array<T> {\r\n    var thisLen = this.length_;\r\n    var otherLen = items === null ? 0 : items.length_;\r\n    var outLen = thisLen + otherLen;\r\n    var out = new Array<T>(outLen);\r\n\r\n    if (thisLen) {\r\n      memory.copy(\r\n        changetype<usize>(out.buffer_)  + HEADER_SIZE,\r\n        changetype<usize>(this.buffer_) + HEADER_SIZE,\r\n        <usize>thisLen << alignof<T>()\r\n      );\r\n    }\r\n    if (otherLen) {\r\n      memory.copy(\r\n        changetype<usize>(out.buffer_)   + HEADER_SIZE + (<usize>thisLen << alignof<T>()),\r\n        changetype<usize>(items.buffer_) + HEADER_SIZE,\r\n        <usize>otherLen << alignof<T>()\r\n      );\r\n    }\r\n    return out;\r\n  }\r\n\r\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): this {\r\n    var buffer = this.buffer_;\r\n    var len = this.length_;\r\n\r\n        end   = min<i32>(end, len);\r\n    var to    = target < 0 ? max(len + target, 0) : min(target, len);\r\n    var from  = start < 0 ? max(len + start, 0) : min(start, len);\r\n    var last  = end < 0 ? max(len + end, 0) : min(end, len);\r\n    var count = min(last - from, len - to);\r\n\r\n    if (from < to && to < (from + count)) {\r\n      from += count - 1;\r\n      to   += count - 1;\r\n      while (count) {\r\n        STORE<T>(buffer, to, LOAD<T>(buffer, from));\r\n        --from, --to, --count;\r\n      }\r\n    } else {\r\n      memory.copy(\r\n        changetype<usize>(buffer) + HEADER_SIZE + (<usize>to << alignof<T>()),\r\n        changetype<usize>(buffer) + HEADER_SIZE + (<usize>from << alignof<T>()),\r\n        <usize>count << alignof<T>()\r\n      );\r\n    }\r\n    return this;\r\n  }\r\n\r\n  pop(): T {\r\n    var length = this.length_;\r\n    if (length < 1) throw new RangeError(\"Array is empty\");\r\n    var element = LOAD<T>(this.buffer_, --length);\r\n    this.length_ = length;\r\n    return element;\r\n  }\r\n\r\n  forEach(callbackfn: (value: T, index: i32, array: Array<T>) => void): void {\r\n    var buffer = this.buffer_;\r\n    for (let index = 0, toIndex = this.length_; index < toIndex && index < this.length_; ++index) {\r\n      callbackfn(LOAD<T>(buffer, index), index, this);\r\n    }\r\n  }\r\n\r\n  map<U>(callbackfn: (value: T, index: i32, array: Array<T>) => U): Array<U> {\r\n    var buffer = this.buffer_;\r\n    var length = this.length_;\r\n    var result = new Array<U>(length);\r\n    var resultBuffer = result.buffer_;\r\n    for (let index = 0; index < min(length, this.length_); ++index) {\r\n      STORE<U>(resultBuffer, index, callbackfn(LOAD<T>(buffer, index), index, this));\r\n    }\r\n    return result;\r\n  }\r\n\r\n  filter(callbackfn: (value: T, index: i32, array: Array<T>) => bool): Array<T> {\r\n    var buffer = this.buffer_;\r\n    var result = new Array<T>();\r\n    for (let index = 0, toIndex = this.length_; index < min(toIndex, this.length_); ++index) {\r\n      let value = LOAD<T>(buffer, index);\r\n      if (callbackfn(value, index, this)) result.push(value);\r\n    }\r\n    return result;\r\n  }\r\n\r\n  reduce<U>(\r\n    callbackfn: (previousValue: U, currentValue: T, currentIndex: i32, array: Array<T>) => U,\r\n    initialValue: U\r\n  ): U {\r\n    var accum = initialValue;\r\n    var buffer = this.buffer_;\r\n    for (let index = 0, toIndex = this.length_; index < min(toIndex, this.length_); ++index) {\r\n      accum = callbackfn(accum, LOAD<T>(buffer, index), index, this);\r\n    }\r\n    return accum;\r\n  }\r\n\r\n  reduceRight<U>(\r\n    callbackfn: (previousValue: U, currentValue: T, currentIndex: i32, array: Array<T>) => U,\r\n    initialValue: U\r\n  ): U {\r\n    var accum = initialValue;\r\n    var buffer = this.buffer_;\r\n    for (let index: i32 = this.length_ - 1; index >= 0; --index) {\r\n      accum = callbackfn(accum, LOAD<T>(buffer, index), index, this);\r\n    }\r\n    return accum;\r\n  }\r\n\r\n  shift(): T {\r\n    var length = this.length_;\r\n    if (length < 1) throw new RangeError(\"Array is empty\");\r\n    var buffer = this.buffer_;\r\n    var element = LOAD<T>(buffer, 0);\r\n    var lastIndex = length - 1;\r\n    memory.copy(\r\n      changetype<usize>(buffer) + HEADER_SIZE,\r\n      changetype<usize>(buffer) + HEADER_SIZE + sizeof<T>(),\r\n      <usize>lastIndex << alignof<T>()\r\n    );\r\n    STORE<T>(buffer, lastIndex, <T>null);\r\n    this.length_ = lastIndex;\r\n    return element;\r\n  }\r\n\r\n  some(callbackfn: (element: T, index: i32, array: Array<T>) => bool): bool {\r\n    var buffer = this.buffer_;\r\n    for (let index = 0, toIndex = this.length_; index < min(toIndex, this.length_); ++index) {\r\n      if (callbackfn(LOAD<T>(buffer, index), index, this)) return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  unshift(element: T): i32 {\r\n    var buffer = this.buffer_;\r\n    var capacity = buffer.byteLength >>> alignof<T>();\r\n    var length = this.length_;\r\n    var newLength = length + 1; // safe only if length is checked\r\n    if (<u32>length >= <u32>capacity) {\r\n      const MAX_LENGTH = MAX_BLENGTH >>> alignof<T>();\r\n      if (<u32>length >= <u32>MAX_LENGTH) throw new Error(\"Invalid array length\");\r\n      buffer = reallocateUnsafe(buffer, newLength << alignof<T>());\r\n      capacity = buffer.byteLength >>> alignof<T>();\r\n      this.buffer_ = buffer;\r\n    }\r\n    memory.copy(\r\n      changetype<usize>(buffer) + HEADER_SIZE + sizeof<T>(),\r\n      changetype<usize>(buffer) + HEADER_SIZE,\r\n      <usize>(capacity - 1) << alignof<T>()\r\n    );\r\n    STORE<T>(buffer, 0, element);\r\n    this.length_ = newLength;\r\n    if (isManaged<T>()) __gc_link(changetype<usize>(this), changetype<usize>(element)); // tslint:disable-line\r\n    return newLength;\r\n  }\r\n\r\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Array<T> {\r\n    var length = this.length_;\r\n    if (begin < 0) begin = max(length + begin, 0);\r\n    else if (begin > length) begin = length;\r\n    if (end < 0) end = length + end; // no need to clamp\r\n    else if (end > length) end = length;\r\n    if (end < begin) end = begin;    // ^\r\n    var newLength = end - begin;\r\n    assert(newLength >= 0);\r\n    var sliced = new Array<T>(newLength);\r\n    if (newLength) {\r\n      memory.copy(\r\n        changetype<usize>(sliced.buffer_) + HEADER_SIZE,\r\n        changetype<usize>(this.buffer_) + HEADER_SIZE + (<usize>begin << alignof<T>()),\r\n        <usize>newLength << alignof<T>()\r\n      );\r\n    }\r\n    return sliced;\r\n  }\r\n\r\n  splice(start: i32, deleteCount: i32 = i32.MAX_VALUE): Array<T> {\r\n    var length  = this.length_;\r\n    start       = start < 0 ? max<i32>(length + start, 0) : min<i32>(start, length);\r\n    deleteCount = max<i32>(min<i32>(deleteCount, length - start), 0);\r\n    var buffer  = this.buffer_;\r\n    var spliced = new Array<T>(deleteCount);\r\n    var source  = changetype<usize>(buffer) + HEADER_SIZE + (<usize>start << alignof<T>());\r\n    memory.copy(\r\n      changetype<usize>(spliced.buffer_) + HEADER_SIZE,\r\n      source,\r\n      <usize>deleteCount << alignof<T>()\r\n    );\r\n    var offset = start + deleteCount;\r\n    if (length != offset) {\r\n      memory.copy(\r\n        source,\r\n        changetype<usize>(buffer) + HEADER_SIZE + (<usize>offset << alignof<T>()),\r\n        <usize>(length - offset) << alignof<T>()\r\n      );\r\n    }\r\n    this.length_ = length - deleteCount;\r\n    return spliced;\r\n  }\r\n\r\n  reverse(): Array<T> {\r\n    var buffer = this.buffer_;\r\n    for (let front = 0, back = this.length_ - 1; front < back; ++front, --back) {\r\n      let temp = LOAD<T>(buffer, front);\r\n      STORE<T>(buffer, front, LOAD<T>(buffer, back));\r\n      STORE<T>(buffer, back, temp);\r\n    }\r\n    return this;\r\n  }\r\n\r\n  sort(comparator: (a: T, b: T) => i32 = COMPARATOR<T>()): this {\r\n    // TODO remove this when flow will allow trackcing null\r\n    assert(comparator); // The comparison function must be a function\r\n\r\n    var length = this.length_;\r\n    if (length <= 1) return this;\r\n    var buffer = this.buffer_;\r\n    if (length == 2) {\r\n      let a = LOAD<T>(buffer, 1); // a = arr[1]\r\n      let b = LOAD<T>(buffer, 0); // b = arr[0]\r\n      if (comparator(a, b) < 0) {\r\n        STORE<T>(buffer, 1, b);   // arr[1] = b;\r\n        STORE<T>(buffer, 0, a);   // arr[0] = a;\r\n      }\r\n      return this;\r\n    }\r\n    SORT<T>(buffer, 0, length, comparator);\r\n    return this;\r\n  }\r\n\r\n  join(separator: string = \",\"): string {\r\n    var lastIndex = this.length_ - 1;\r\n    if (lastIndex < 0) return \"\";\r\n    var result = \"\";\r\n    var value: T;\r\n    var buffer = this.buffer_;\r\n    var sepLen = separator.length;\r\n    var hasSeparator = sepLen != 0;\r\n    if (value instanceof bool) {\r\n      if (!lastIndex) {\r\n        return select<string>(\"true\", \"false\", LOAD<T,bool>(buffer, 0));\r\n      }\r\n      let valueLen = 5; // max possible length of element len(\"false\")\r\n      let estLen = (valueLen + sepLen) * lastIndex + valueLen;\r\n      let result = allocateUnsafeString(estLen);\r\n      let offset = 0;\r\n      for (let i = 0; i < lastIndex; ++i) {\r\n        value = LOAD<T,bool>(buffer, i);\r\n        valueLen = 4 + <i32>(!value);\r\n        copyUnsafeString(result, offset, select<string>(\"true\", \"false\", value), 0, valueLen);\r\n        offset += valueLen;\r\n        if (hasSeparator) {\r\n          copyUnsafeString(result, offset, changetype<String>(separator), 0, sepLen);\r\n          offset += sepLen;\r\n        }\r\n      }\r\n      value = LOAD<T,bool>(buffer, lastIndex);\r\n      valueLen = 4 + <i32>(!value);\r\n      copyUnsafeString(result, offset, select<string>(\"true\", \"false\", value), 0, valueLen);\r\n      offset += valueLen;\r\n\r\n      let out = result;\r\n      if (estLen > offset) {\r\n        out = result.substring(0, offset);\r\n        freeUnsafeString(result);\r\n      }\r\n      return out;\r\n    } else if (isInteger<T>()) {\r\n      if (!lastIndex) {\r\n        return changetype<string>(itoa<T>(LOAD<T>(buffer, 0)));\r\n      }\r\n      const valueLen = (sizeof<T>() <= 4 ? 10 : 20) + <i32>isSigned<T>();\r\n      let estLen = (valueLen + sepLen) * lastIndex + valueLen;\r\n      let result = allocateUnsafeString(estLen);\r\n      let offset = 0;\r\n      for (let i = 0; i < lastIndex; ++i) {\r\n        value = LOAD<T>(buffer, i);\r\n        offset += itoa_stream<T>(changetype<usize>(result), offset, value);\r\n        if (hasSeparator) {\r\n          copyUnsafeString(result, offset, separator, 0, sepLen);\r\n          offset += sepLen;\r\n        }\r\n      }\r\n      value = LOAD<T>(buffer, lastIndex);\r\n      offset += itoa_stream<T>(changetype<usize>(result), offset, value);\r\n      let out = result;\r\n      if (estLen > offset) {\r\n        out = result.substring(0, offset);\r\n        freeUnsafeString(result);\r\n      }\r\n      return out;\r\n    } else if (isFloat<T>()) {\r\n      if (!lastIndex) {\r\n        return changetype<string>(dtoa(LOAD<T,f64>(buffer, 0)));\r\n      }\r\n      const valueLen = MAX_DOUBLE_LENGTH;\r\n      let estLen = (valueLen + sepLen) * lastIndex + valueLen;\r\n      let result = allocateUnsafeString(estLen);\r\n      let offset = 0;\r\n      for (let i = 0; i < lastIndex; ++i) {\r\n        value = LOAD<T,f64>(buffer, i);\r\n        offset += dtoa_stream(changetype<usize>(result), offset, value);\r\n        if (hasSeparator) {\r\n          copyUnsafeString(result, offset, separator, 0, sepLen);\r\n          offset += sepLen;\r\n        }\r\n      }\r\n      value = LOAD<T,f64>(buffer, lastIndex);\r\n      offset += dtoa_stream(changetype<usize>(result), offset, value);\r\n      let out = result;\r\n      if (estLen > offset) {\r\n        out = result.substring(0, offset);\r\n        freeUnsafeString(result);\r\n      }\r\n      return out;\r\n    } else if (isString<T>()) {\r\n      if (!lastIndex) {\r\n        return LOAD<string>(buffer, 0);\r\n      }\r\n      let estLen = 0;\r\n      for (let i = 0, len = lastIndex + 1; i < len; ++i) {\r\n        estLen += LOAD<string>(buffer, i).length;\r\n      }\r\n      let offset = 0;\r\n      let result = allocateUnsafeString(estLen + sepLen * lastIndex);\r\n      for (let i = 0; i < lastIndex; ++i) {\r\n        value = LOAD<string>(buffer, i);\r\n        if (value) {\r\n          let valueLen = value.length;                          // tslint:disable-line:no-unsafe-any\r\n          copyUnsafeString(result, offset, value, 0, valueLen); // tslint:disable-line:no-unsafe-any\r\n          offset += valueLen;                                   // tslint:disable-line:no-unsafe-any\r\n        }\r\n        if (hasSeparator) {\r\n          copyUnsafeString(result, offset, separator, 0, sepLen);\r\n          offset += sepLen;\r\n        }\r\n      }\r\n      value = LOAD<string>(buffer, lastIndex);\r\n      if (value) {\r\n        let valueLen = value.length;                          // tslint:disable-line:no-unsafe-any\r\n        copyUnsafeString(result, offset, value, 0, valueLen); // tslint:disable-line:no-unsafe-any\r\n      }\r\n      return result;\r\n    } else if (isArray<T>()) {\r\n      if (!lastIndex) {\r\n        value = LOAD<T>(buffer, 0);\r\n        return value ? value.join(separator) : \"\"; // tslint:disable-line:no-unsafe-any\r\n      }\r\n      for (let i = 0; i < lastIndex; ++i) {\r\n        value = LOAD<T>(buffer, i);\r\n        if (value) result += value.join(separator); // tslint:disable-line:no-unsafe-any\r\n        if (hasSeparator) result += separator;\r\n      }\r\n      value = LOAD<T>(buffer, lastIndex);\r\n      if (value) result += value.join(separator); // tslint:disable-line:no-unsafe-any\r\n      return result;\r\n    } else if (isReference<T>()) { // References\r\n      if (!lastIndex) return \"[object Object]\";\r\n      const valueLen = 15; // max possible length of element len(\"[object Object]\")\r\n      let estLen = (valueLen + sepLen) * lastIndex + valueLen;\r\n      let result = allocateUnsafeString(estLen);\r\n      let offset = 0;\r\n      for (let i = 0; i < lastIndex; ++i) {\r\n        value = LOAD<T>(buffer, i);\r\n        if (value) {\r\n          copyUnsafeString(result, offset, changetype<String>(\"[object Object]\"), 0, valueLen);\r\n          offset += valueLen;\r\n        }\r\n        if (hasSeparator) {\r\n          copyUnsafeString(result, offset, changetype<String>(separator), 0, sepLen);\r\n          offset += sepLen;\r\n        }\r\n      }\r\n      if (LOAD<T>(buffer, lastIndex)) {\r\n        copyUnsafeString(result, offset, changetype<String>(\"[object Object]\"), 0, valueLen);\r\n        offset += valueLen;\r\n      }\r\n      let out = result;\r\n      if (estLen > offset) {\r\n        out = result.substring(0, offset);\r\n        freeUnsafeString(result);\r\n      }\r\n      return out;\r\n    } else {\r\n      assert(false); // Unsupported generic typename\r\n    }\r\n  }\r\n\r\n  @inline\r\n  toString(): string {\r\n    return this.join();\r\n  }\r\n\r\n  private __gc(): void {\r\n    var buffer = this.buffer_;\r\n    __gc_mark(changetype<usize>(buffer)); // tslint:disable-line\r\n    if (isManaged<T>()) {\r\n      let offset: usize = 0;\r\n      let end = <usize>this.length_ << alignof<usize>();\r\n      while (offset < end) {\r\n        __gc_mark(load<usize>(changetype<usize>(buffer) + offset, HEADER_SIZE)); // tslint:disable-line\r\n        offset += sizeof<usize>();\r\n      }\r\n    }\r\n  }\r\n}\r\n","// You need to import your own allocator\r\nimport \"allocator/tlsf\";\r\n\r\n// import CanvasRenderingContext2D and Image\r\nimport { OptimizedCanvasRenderingContext2D, Image } from \"./index\";\r\nimport { CanvasGradient } from \"./renderer/CanvasGradient\";\r\nimport { CanvasPattern } from \"./renderer/CanvasPattern\";\r\nimport { CanvasPatternType } from \"../src/shared\";\r\nimport { TextureMap } from \"./primitives/TextureMap\";\r\n\r\nlet ctx: OptimizedCanvasRenderingContext2D = new OptimizedCanvasRenderingContext2D();\r\nlet kitten: Image;\r\nlet rotation: f64 = 0;\r\nlet rotValue: f64 = Math.PI / 180.0;\r\nlet gradient: CanvasGradient;\r\nlet kittenPattern: CanvasPattern;\r\nlet kittenLoaded: bool = false;\r\nexport function init(): void {\r\n  // contexts must be initialized until the `constructor()` bugs are fixed in assemblyscript on the main branch\r\n  ctx.init();\r\n\r\n  gradient = ctx.createLinearGradient(0.0, 0.0, 100.0, 100.0);\r\n  gradient.addColorStop(0.0, \"black\");\r\n  gradient.addColorStop(1.0, \"white\");\r\n}\r\n\r\nexport function update(): void {\r\n  if (kitten == null && TextureMap.has(\"kitten\")) {\r\n    kitten = TextureMap.get(\"kitten\");\r\n  }\r\n  if (kitten != null && kitten.loaded && !kittenLoaded) {\r\n    kittenLoaded = true;\r\n    kittenPattern = ctx.createPattern(kitten, CanvasPatternType.repeat);\r\n  }\r\n\r\n  // rotate the cat\r\n  rotation += rotValue;\r\n}\r\n\r\nexport function draw(): Float64Array {\r\n  // perform some simple drawing calls\r\n  ctx.clearRect(0.0, 0.0, 800.0, 600.0);\r\n  if (kittenLoaded) {\r\n    ctx.save();\r\n    ctx.translate(150.0, 150.0);\r\n    ctx.rotate(rotation);\r\n    ctx.translate(-150.0, -150.0);\r\n    ctx.fillPattern = kittenPattern;\r\n    ctx.fillRect(0.0, 0.0, 500, 500);\r\n    ctx.restore();\r\n  }\r\n\r\n  ctx.save();\r\n  ctx.fillGradient = gradient;\r\n  ctx.translate(500.0, 500.0);\r\n  ctx.fillRect(0.0, 0.0, 100.0, 100.0);\r\n  ctx.restore();\r\n\r\n  // we must always return a reference to a `Float64Array`. The commit function is repurposed for the AssemblyScript context\r\n  return ctx.commit();\r\n}\r\n\r\nexport { memory }\r\n","export enum Direction {\r\n  ltr = 0,\r\n  rtl = 1,\r\n  inherit = 2,\r\n}\r\n","import { CanvasPattern } from \"../renderer/CanvasPattern\";\r\nimport { CanvasGradient } from \"../renderer/CanvasGradient\";\r\n\r\nexport const enum FillStrokeWhich {\r\n  Style,\r\n  Gradient,\r\n  Pattern,\r\n}\r\n\r\nexport class FillStrokeWhichValue {\r\n  pattern: CanvasPattern | null = null;\r\n  gradient: CanvasGradient | null = null;\r\n  style: string | null = \"#000\";\r\n  which: FillStrokeWhich = FillStrokeWhich.Style;\r\n\r\n  @operator(\"==\")\r\n  protected equals(value: FillStrokeWhichValue): bool {\r\n    return this.which == value.which\r\n      && this.pattern == value.pattern\r\n      && this.gradient == value.gradient\r\n      && this.style == value.style;\r\n  }\r\n\r\n  @inline\r\n  public set(value: FillStrokeWhichValue): void {\r\n    value.gradient = this.gradient;\r\n    value.pattern = this.pattern;\r\n    value.style = this.style;\r\n    value.which = this.which;\r\n  }\r\n}","export enum GlobalCompositeOperation {\r\n  source_over = 0,\r\n  source_in = 1,\r\n  source_out = 2,\r\n  source_atop = 3,\r\n  destination_over = 4,\r\n  destination_in = 5,\r\n  destination_out = 6,\r\n  destination_atop = 7,\r\n  lighter = 8,\r\n  copy = 9,\r\n  xor = 10,\r\n  multiply = 11,\r\n  screen = 12,\r\n  overlay = 13,\r\n  darken = 14,\r\n  lighten = 15,\r\n  color_dodge = 16,\r\n  color_burn = 17,\r\n  hard_light = 18,\r\n  soft_light = 19,\r\n  difference = 20,\r\n  exclusion = 21,\r\n  hue = 22,\r\n  saturation = 23,\r\n  color = 24,\r\n  luminosity = 25,\r\n}\r\n","export enum ImageSmoothingQuality {\r\n  low = 0,\r\n  medium = 1,\r\n  high = 2,\r\n}\r\n","export enum LineCap {\r\n  butt = 0,\r\n  round = 1,\r\n  square = 2,\r\n}\r\n","export enum LineJoin {\r\n  bevel = 0,\r\n  round = 1,\r\n  miter = 2,\r\n}\r\n","export enum TextAlign {\r\n  left = 0,\r\n  right = 1,\r\n  center = 2,\r\n  start = 3,\r\n  end = 4,\r\n}\r\n","export enum TextBaseline {\r\n  top = 0,\r\n  hanging = 1,\r\n  middle = 2,\r\n  alphabetic = 3,\r\n  ideographic = 4,\r\n  bottom = 5,\r\n}\r\n","import { CanvasInstruction } from \"../../src/shared\";\r\n\r\nexport class Path2DElement {\r\n  instruction: CanvasInstruction = CanvasInstruction.Commit;\r\n  transformA: f64 = 1.0;\r\n  transformB: f64 = 0.0;\r\n  transformC: f64 = 0.0;\r\n  transformD: f64 = 1.0;\r\n  transformE: f64 = 0.0;\r\n  transformF: f64 = 0.0;\r\n  count: i32 = 0;\r\n  updateTransform: bool = false;\r\n  a: f64 = 0;\r\n  b: f64 = 0;\r\n  c: f64 = 0;\r\n  d: f64 = 0;\r\n  e: f64 = 0;\r\n  f: f64 = 0;\r\n  g: f64 = 0;\r\n  h: f64 = 0;\r\n}\r\n","export function copyTypedArray(value: Float64Array): Float64Array {\r\n  var copy: Float64Array = new Float64Array(value.length);\r\n  for (var i = 0; i < copy.length; i++)\r\n    copy[i] = value[i];\r\n\r\n  return copy;\r\n}\r\n\r\nexport function doubleTypedArray(value: Float64Array): Float64Array {\r\n  var copy: Float64Array = new Float64Array(value.length * 2);\r\n  var i: i32;\r\n  for (i = 0; i < copy.length; i++)\r\n    copy[i] = value[i];\r\n\r\n  for (i = 0; i < copy.length; i++)\r\n    copy[i + copy.length] = value[i];\r\n\r\n  return copy;\r\n}\r\n"]}