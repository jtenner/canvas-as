{"version":3,"sources":["~lib/internal/allocator.ts","~lib/allocator/tlsf.ts","assembly/primitives/ImageBitmap.ts","~lib/memory.ts","assembly/renderer/Serializer.ts","~lib/internal/arraybuffer.ts","~lib/internal/typedarray.ts","~lib/internal/memory.ts","~lib/map.ts","~lib/arraybuffer.ts","assembly/renderer/CanvasRenderingContext2DSerializer.ts","assembly/renderer/CanvasRenderingContext2D.ts","~lib/array.ts","assembly/index.ts","assembly/shared/Direction.ts","assembly/shared/GlobalCompositeOperation.ts","assembly/shared/ImageSmoothingQuality.ts","assembly/shared/LineCap.ts","assembly/shared/LineJoin.ts","assembly/shared/TextAlign.ts","assembly/shared/TextBaseline.ts","~lib/builtins.ts"],"names":[],"mappings":"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","sourceRoot":"assemblyscript:///","sourceContents":["/** Number of alignment bits. */\nexport const AL_BITS: u32 = 3;\n/** Number of possible alignment values. */\nexport const AL_SIZE: usize = 1 << <usize>AL_BITS;\n/** Mask to obtain just the alignment bits. */\nexport const AL_MASK: usize = AL_SIZE - 1;\n/** Maximum 32-bit allocation size. */\nexport const MAX_SIZE_32: usize = 1 << 30; // 1GB\n","/**\n * Two-Level Segregate Fit Memory Allocator.\n *\n * A general purpose dynamic memory allocator specifically designed to meet real-time requirements.\n * Always aligns to 8 bytes.\n *\n * @module std/assembly/allocator/tlsf\n *//***/\n\n// ╒══════════════ Block size interpretation (32-bit) ═════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┼─┴─┴─┴─┴─╫─┴─┴─┤\n// │ |                    FL                       │ SB = SL + AL  │ ◄─ usize\n// └───────────────────────────────────────────────┴─────────╨─────┘\n// FL: first level, SL: second level, AL: alignment, SB: small block\n\nimport {\n  AL_BITS,\n  AL_SIZE,\n  AL_MASK\n} from \"../internal/allocator\";\n\nconst SL_BITS: u32 = 5;\nconst SL_SIZE: usize = 1 << <usize>SL_BITS;\n\nconst SB_BITS: usize = <usize>(SL_BITS + AL_BITS);\nconst SB_SIZE: usize = 1 << <usize>SB_BITS;\n\nconst FL_BITS: u32 = (sizeof<usize>() == sizeof<u32>()\n  ? 30 // ^= up to 1GB per block\n  : 32 // ^= up to 4GB per block\n) - SB_BITS;\n\n// ╒════════════════ Block structure layout (32-bit) ══════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┼─┼─┤\n// │                          size                             │L│F│ ◄─┐ info\n// ╞═══════════════════════════════════════════════════════════╧═╧═╡   │      ┐\n// │                        if free: ◄ prev                        │ ◄─┤ usize\n// ├───────────────────────────────────────────────────────────────┤   │\n// │                        if free: next ►                        │ ◄─┤\n// ├───────────────────────────────────────────────────────────────┤   │\n// │                ... unused free space >= 0 ...                 │   │    = 0\n// ├ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┤   │\n// │                        if free: jump ▲                        │ ◄─┘\n// └───────────────────────────────────────────────────────────────┘ MIN SIZE ┘\n// F: FREE, L: LEFT_FREE\n\n/** Tag indicating that this block is free. */\nconst FREE: usize = 1 << 0;\n/** Tag indicating that this block's left block is free. */\nconst LEFT_FREE: usize = 1 << 1;\n/** Mask to obtain all tags. */\nconst TAGS: usize = FREE | LEFT_FREE;\n\n/** Block structure. */\n@unmanaged\nclass Block {\n\n  /** Info field holding this block's size and tags. */\n  info: usize;\n\n  /** End offset of the {@link Block#info} field. User data starts here. */\n  static readonly INFO: usize = (sizeof<usize>() + AL_MASK) & ~AL_MASK;\n\n  /** Previous free block, if any. Only valid if free. */\n  prev: Block | null;\n  /** Next free block, if any. Only valid if free. */\n  next: Block | null;\n\n  /** Minimum size of a block, excluding {@link Block#info}. */\n  static readonly MIN_SIZE: usize = (3 * sizeof<usize>() + AL_MASK) & ~AL_MASK;// prev + next + jump\n\n  /** Maximum size of a used block, excluding {@link Block#info}. */\n  static readonly MAX_SIZE: usize = 1 << (FL_BITS + SB_BITS);\n\n  /** Gets this block's left (free) block in memory. */\n  get left(): Block {\n    assert(this.info & LEFT_FREE); // must be free to contain a jump\n    return assert(\n      load<Block>(changetype<usize>(this) - sizeof<usize>())\n    ); // can't be null\n  }\n\n  /** Gets this block's right block in memory. */\n  get right(): Block {\n    assert(this.info & ~TAGS); // can't skip beyond the tail block\n    return assert(\n      changetype<Block>(\n        changetype<usize>(this) + Block.INFO + (this.info & ~TAGS)\n      )\n    ); // can't be null\n  }\n}\n\n// ╒════════════════ Root structure layout (32-bit) ═══════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤          ┐\n// │        0        |           flMap                            S│ ◄────┐\n// ╞═══════════════════════════════════════════════════════════════╡      │\n// │                           slMap[0] S                          │ ◄─┐  │\n// ├───────────────────────────────────────────────────────────────┤   │  │\n// │                           slMap[1]                            │ ◄─┤  │\n// ├───────────────────────────────────────────────────────────────┤  u32 │\n// │                              ...                              │ ◄─┤  │\n// ├───────────────────────────────────────────────────────────────┤   │  │\n// │                           slMap[22] P                         │ ◄─┘  │\n// ╞═══════════════════════════════════════════════════════════════╡    usize\n// │                            head[0]                            │ ◄────┤\n// ├───────────────────────────────────────────────────────────────┤      │\n// │                              ...                              │ ◄────┤\n// ├───────────────────────────────────────────────────────────────┤      │\n// │                           head[736]                           │ ◄────┤\n// ╞═══════════════════════════════════════════════════════════════╡      │\n// │                            tailRef                            │ ◄────┘\n// └───────────────────────────────────────────────────────────────┘   SIZE   ┘\n// S: Small blocks map, P: Possibly padded if 64-bit\n\nassert((1 << SL_BITS) <= 32); // second level must fit into 32 bits\n\n/** Root structure. */\n@unmanaged\nclass Root {\n\n  /** First level bitmap. */\n  flMap: usize = 0;\n\n  /** Start offset of second level maps. */\n  private static readonly SL_START: usize = sizeof<usize>();\n\n  // Using *one* SL map per *FL bit*\n\n  /** Gets the second level map for the specified first level. */\n  getSLMap(fl: usize): u32 {\n    assert(fl < FL_BITS); // fl out of range\n    return load<u32>(changetype<usize>(this) + fl * 4, Root.SL_START);\n  }\n\n  /** Sets the second level map for the specified first level. */\n  setSLMap(fl: usize, value: u32): void {\n    assert(fl < FL_BITS); // fl out of range\n    store<u32>(changetype<usize>(this) + fl * 4, value, Root.SL_START);\n  }\n\n  /** End offset of second level maps. */\n  private static readonly SL_END: usize = Root.SL_START + FL_BITS * 4;\n\n  // Using *number bits per SL* heads per *FL bit*\n\n  /** Start offset of FL/SL heads. */\n  private static readonly HL_START: usize = (Root.SL_END + AL_MASK) & ~AL_MASK;\n\n  /** Gets the head of the specified first and second level index. */\n  getHead(fl: usize, sl: u32): Block | null {\n    assert(fl < FL_BITS); // fl out of range\n    assert(sl < SL_SIZE); // sl out of range\n    return changetype<Block>(load<usize>(\n      changetype<usize>(this) + (fl * SL_SIZE + <usize>sl) * sizeof<usize>()\n    , Root.HL_START));\n  }\n\n  /** Sets the head of the specified first and second level index. */\n  setHead(fl: usize, sl: u32, value: Block | null): void {\n    assert(fl < FL_BITS); // fl out of range\n    assert(sl < SL_SIZE); // sl out of range\n    store<usize>(\n      changetype<usize>(this) + (fl * SL_SIZE + <usize>sl) * sizeof<usize>()\n    , changetype<usize>(value)\n    , Root.HL_START);\n  }\n\n  /** End offset of FL/SL heads. */\n  private static readonly HL_END: usize = (\n    Root.HL_START + FL_BITS * SL_SIZE * sizeof<usize>()\n  );\n\n  get tailRef(): usize { return load<usize>(0, Root.HL_END); }\n  set tailRef(value: usize) { store<usize>(0, value, Root.HL_END); }\n\n  /** Total size of the {@link Root} structure. */\n  static readonly SIZE: usize = Root.HL_END + sizeof<usize>();\n\n  /** Inserts a previously used block back into the free list. */\n  insert(block: Block): void {\n    // check as much as possible here to prevent invalid free blocks\n    assert(block); // cannot be null\n    var blockInfo = block.info;\n    assert(blockInfo & FREE); // must be free\n    var size: usize;\n    assert(\n      (size = block.info & ~TAGS) >= Block.MIN_SIZE && size < Block.MAX_SIZE\n    ); // must be valid, not necessary to compute yet if noAssert=true\n\n    var right: Block = assert(block.right); // can't be null\n    var rightInfo = right.info;\n\n    // merge with right block if also free\n    if (rightInfo & FREE) {\n      this.remove(right);\n      block.info = (blockInfo += Block.INFO + (rightInfo & ~TAGS));\n      right = block.right;\n      rightInfo = right.info;\n      // jump is set below\n    }\n\n    // merge with left block if also free\n    if (blockInfo & LEFT_FREE) {\n      let left: Block = assert(block.left); // can't be null\n      let leftInfo = left.info;\n      assert(leftInfo & FREE); // must be free according to tags\n      this.remove(left);\n      left.info = (leftInfo += Block.INFO + (blockInfo & ~TAGS));\n      block = left;\n      blockInfo = leftInfo;\n      // jump is set below\n    }\n\n    right.info = rightInfo | LEFT_FREE;\n    this.setJump(block, right);\n    // right is no longer used now, hence rightInfo is not synced\n\n    size = blockInfo & ~TAGS;\n    assert(size >= Block.MIN_SIZE && size < Block.MAX_SIZE); // must be valid\n\n    // mapping_insert\n    var fl: usize, sl: u32;\n    if (size < SB_SIZE) {\n      fl = 0;\n      sl = <u32>(size / AL_SIZE);\n    } else {\n      fl = fls<usize>(size);\n      sl = <u32>((size >> (fl - SL_BITS)) ^ (1 << SL_BITS));\n      fl -= SB_BITS - 1;\n    }\n\n    // perform insertion\n    var head = this.getHead(fl, sl);\n    block.prev = null;\n    block.next = head;\n    if (head) head.prev = block;\n    this.setHead(fl, sl, block);\n\n    // update first and second level maps\n    this.flMap |= (1 << fl);\n    this.setSLMap(fl, this.getSLMap(fl) | (1 << sl));\n  }\n\n  /**\n   * Removes a free block from FL/SL maps. Does not alter left/jump because it\n   * is likely that splitting is performed afterwards, invalidating any changes\n   * again.\n   */\n  private remove(block: Block): void {\n    var blockInfo = block.info;\n    assert(blockInfo & FREE); // must be free\n    var size = blockInfo & ~TAGS;\n    assert(size >= Block.MIN_SIZE && size < Block.MAX_SIZE); // must be valid\n\n    // mapping_insert\n    var fl: usize, sl: u32;\n    if (size < SB_SIZE) {\n      fl = 0;\n      sl = <u32>(size / AL_SIZE);\n    } else {\n      fl = fls<usize>(size);\n      sl = <u32>((size >> (fl - SL_BITS)) ^ (1 << SL_BITS));\n      fl -= SB_BITS - 1;\n    }\n\n    // link previous and next free block\n    var prev = block.prev;\n    var next = block.next;\n    if (prev) prev.next = next;\n    if (next) next.prev = prev;\n\n    // update head if we are removing it\n    if (block == this.getHead(fl, sl)) {\n      this.setHead(fl, sl, next);\n\n      // clear second level map if head is empty now\n      if (!next) {\n        let slMap = this.getSLMap(fl);\n        this.setSLMap(fl, slMap &= ~(1 << sl));\n\n        // clear first level map if second level is empty now\n        if (!slMap) this.flMap &= ~(1 << fl);\n      }\n    }\n  }\n\n  /** Searches for a free block of at least the specified size. */\n  search(size: usize): Block | null {\n    assert(size >= Block.MIN_SIZE && size < Block.MAX_SIZE);\n\n    // mapping_search\n    var fl: usize, sl: u32;\n    if (size < SB_SIZE) {\n      fl = 0;\n      sl = <u32>(size / AL_SIZE);\n    } else {\n      // (*) size += (1 << (fls<usize>(size) - SL_BITS)) - 1;\n      fl = fls<usize>(size);\n      sl = <u32>((size >> (fl - SL_BITS)) ^ (1 << SL_BITS));\n      fl -= SB_BITS - 1;\n      // (*) instead of rounding up, use next second level list for better fit\n      if (sl < SL_SIZE - 1) ++sl;\n      else ++fl, sl = 0;\n    }\n\n    // search second level\n    var slMap = this.getSLMap(fl) & (~0 << sl);\n    var head: Block | null;\n    if (!slMap) {\n      // search next larger first level\n      let flMap = this.flMap & (~0 << (fl + 1));\n      if (!flMap) {\n        head = null;\n      } else {\n        fl = ffs<usize>(flMap);\n        slMap = assert(this.getSLMap(fl)); // can't be zero if fl points here\n        head = this.getHead(fl, ffs<u32>(slMap));\n      }\n    } else {\n      head = this.getHead(fl, ffs<u32>(slMap));\n    }\n    return head;\n  }\n\n  /** Links a free left with its right block in memory. */\n  private setJump(left: Block, right: Block): void {\n    assert(left.info & FREE);       // must be free\n    assert(left.right == right);    // right block must match\n    assert(right.info & LEFT_FREE); // right block must be tagged as LEFT_FREE\n    store<Block>(\n      changetype<usize>(right) - sizeof<usize>()\n    , left); // last word in left block's (free) data region\n  }\n\n  /**\n   * Uses the specified free block, removing it from internal maps and\n   * splitting it if possible, and returns its data pointer.\n   */\n  use(block: Block, size: usize): usize {\n    var blockInfo = block.info;\n    assert(blockInfo & FREE); // must be free so we can use it\n    assert(size >= Block.MIN_SIZE && size < Block.MAX_SIZE); // must be valid\n    assert(!(size & AL_MASK)); // size must be aligned so the new block is\n\n    this.remove(block);\n\n    // split if the block can hold another MIN_SIZE block\n    var remaining = (blockInfo & ~TAGS) - size;\n    if (remaining >= Block.INFO + Block.MIN_SIZE) {\n      block.info = size | (blockInfo & LEFT_FREE); // also discards FREE\n\n      let spare = changetype<Block>(\n        changetype<usize>(block) + Block.INFO + size\n      );\n      spare.info = (remaining - Block.INFO) | FREE; // not LEFT_FREE\n      this.insert(spare); // also sets jump\n\n    // otherwise tag block as no longer FREE and right as no longer LEFT_FREE\n    } else {\n      block.info = blockInfo & ~FREE;\n      let right: Block = assert(block.right); // can't be null (tail)\n      right.info &= ~LEFT_FREE;\n    }\n\n    return changetype<usize>(block) + Block.INFO;\n  }\n\n  /** Adds more memory to the pool. */\n  addMemory(start: usize, end: usize): bool {\n    assert(start <= end);\n    assert(!(start & AL_MASK)); // must be aligned\n    assert(!(end & AL_MASK)); // must be aligned\n\n    var tailRef = this.tailRef;\n    var tailInfo: usize = 0;\n    if (tailRef) {\n      assert(start >= tailRef + sizeof<usize>()); // starts after tail\n\n      // merge with current tail if adjacent\n      if (start - Block.INFO == tailRef) {\n        start -= Block.INFO;\n        tailInfo = changetype<Block>(tailRef).info;\n      }\n\n    } else {\n      assert(start >= changetype<usize>(this) + Root.SIZE); // starts after root\n    }\n\n    // check if size is large enough for a free block and the tail block\n    var size = end - start;\n    if (size < Block.INFO + Block.MIN_SIZE + Block.INFO) {\n      return false;\n    }\n\n    // left size is total minus its own and the zero-length tail's header\n    var leftSize = size - 2 * Block.INFO;\n    var left = changetype<Block>(start);\n    left.info = leftSize | FREE | (tailInfo & LEFT_FREE);\n    left.prev = null;\n    left.next = null;\n\n    // tail is a zero-length used block\n    var tail = changetype<Block>(start + size - Block.INFO);\n    tail.info = 0 | LEFT_FREE;\n    this.tailRef = changetype<usize>(tail);\n\n    this.insert(left); // also merges with free left before tail / sets jump\n\n    return true;\n  }\n}\n\n/** Determines the first (LSB to MSB) set bit's index of a word. */\nfunction ffs<T>(word: T): T {\n  assert(word != 0); // word cannot be 0\n  return ctz<T>(word);  // differs from ffs only for 0\n}\n\n/** Determines the last (LSB to MSB) set bit's index of a word. */\nfunction fls<T>(word: T): T {\n  assert(word != 0); // word cannot be 0\n  const inv: T = (sizeof<T>() << 3) - 1;\n  return inv - clz<T>(word);\n}\n\n/** Reference to the initialized {@link Root} structure, once initialized. */\nvar ROOT: Root = changetype<Root>(0);\n\n// Memory allocator interface\n\n/** Allocates a chunk of memory. */\n@global export function __memory_allocate(size: usize): usize {\n\n  // initialize if necessary\n  var root = ROOT;\n  if (!root) {\n    let rootOffset = (HEAP_BASE + AL_MASK) & ~AL_MASK;\n    let pagesBefore = memory.size();\n    let pagesNeeded = <i32>((((rootOffset + Root.SIZE) + 0xffff) & ~0xffff) >>> 16);\n    if (pagesNeeded > pagesBefore && memory.grow(pagesNeeded - pagesBefore) < 0) unreachable();\n    ROOT = root = changetype<Root>(rootOffset);\n    root.tailRef = 0;\n    root.flMap = 0;\n    for (let fl: usize = 0; fl < FL_BITS; ++fl) {\n      root.setSLMap(fl, 0);\n      for (let sl: u32 = 0; sl < SL_SIZE; ++sl) {\n        root.setHead(fl, sl, null);\n      }\n    }\n    root.addMemory((rootOffset + Root.SIZE + AL_MASK) & ~AL_MASK, memory.size() << 16);\n  }\n\n  // search for a suitable block\n  if (size > Block.MAX_SIZE) unreachable();\n\n  // 32-bit MAX_SIZE is 1 << 30 and itself aligned, hence the following can't overflow MAX_SIZE\n  size = max<usize>((size + AL_MASK) & ~AL_MASK, Block.MIN_SIZE);\n\n  var block = root.search(size);\n  if (!block) {\n\n    // request more memory\n    let pagesBefore = memory.size();\n    let pagesNeeded = <i32>(((size + 0xffff) & ~0xffff) >>> 16);\n    let pagesWanted = max(pagesBefore, pagesNeeded); // double memory\n    if (memory.grow(pagesWanted) < 0) {\n      if (memory.grow(pagesNeeded) < 0) {\n        unreachable(); // out of memory\n      }\n    }\n    let pagesAfter = memory.size();\n    root.addMemory(<usize>pagesBefore << 16, <usize>pagesAfter << 16);\n    block = assert(root.search(size)); // must be found now\n  }\n\n  assert((block.info & ~TAGS) >= size);\n  return root.use(<Block>block, size);\n}\n\n/** Frees the chunk of memory at the specified address. */\n@global export function __memory_free(data: usize): void {\n  if (data) {\n    let root = ROOT;\n    if (root) {\n      let block = changetype<Block>(data - Block.INFO);\n      let blockInfo = block.info;\n      assert(!(blockInfo & FREE)); // must be used\n      block.info = blockInfo | FREE;\n      root.insert(changetype<Block>(data - Block.INFO));\n    }\n  }\n}\n\n@global export function __memory_reset(): void {\n  unreachable();\n}\n","import { load_image } from \"../linked\";\r\n\r\nvar index: i32 = 0;\r\n\r\nexport function createImageBitmap(src: string): ImageBitmap {\r\n  var img: ImageBitmap = ImageBitmap.create(index++);\r\n  load_image(img, src);\r\n  return img;\r\n}\r\n\r\nexport class ImageBitmap {\r\n  public _index: i32 = 0;\r\n  public _loaded: i32 = 0;\r\n  public width: i32 = 0;\r\n  public height: i32 = 0;\r\n\r\n  public static create(index: i32): ImageBitmap {\r\n    return new ImageBitmap(index);\r\n  }\r\n\r\n  protected constructor(index: i32) {\r\n    this._index = index;\r\n  }\r\n}\r\n","import { memcmp, memmove, memset } from \"./internal/memory\";\n\n@builtin export declare const HEAP_BASE: usize; // tslint:disable-line\n\n/* tslint:disable */\n\nexport namespace memory {\n\n  @builtin export declare function size(): i32;\n\n  @builtin export declare function grow(pages: i32): i32;\n\n  @inline export function fill(dest: usize, c: u8, n: usize): void { // see: musl/src/string/memset\n    if (isDefined(__memory_fill)) { __memory_fill(dest, c, n); return; }\n    memset(dest, c, n);\n  }\n\n  @inline export function copy(dest: usize, src: usize, n: usize): void { // see: musl/src/string/memmove.c\n    if (isDefined(__memory_copy)) { __memory_copy(dest, src, n); return; }\n    memmove(dest, src, n);\n  }\n\n  @inline export function compare(vl: usize, vr: usize, n: usize): i32 { // see: musl/src/string/memcmp.c\n    if (isDefined(__memory_compare)) return __memory_compare(vl, vr, n);\n    return memcmp(vl, vr, n);\n  }\n\n  // Passive segments\n\n  // export function init(segmentIndex: u32, srcOffset: usize, dstOffset: usize, n: usize): void {\n  //   __memory_init(segmentIndex, srcOffset, dstOffset);\n  // }\n\n  // export function drop(segmentIndex: u32): void {\n  //   __memory_drop(segmentIndex);\n  // }\n\n  // Allocator\n\n  @inline export function allocate(size: usize): usize {\n    if (isDefined(__memory_allocate)) return __memory_allocate(size);\n    WARNING(\"Calling 'memory.allocate' requires a memory manager to be present.\");\n    return <usize>unreachable();\n  }\n\n  @inline export function free(ptr: usize): void {\n    if (isDefined(__memory_free)) { __memory_free(ptr); return; }\n    WARNING(\"Calling 'memory.free' requires a memory manager to be present.\");\n    unreachable();\n  }\n\n  @inline export function reset(): void {\n    if (isDefined(__memory_reset)) { __memory_reset(); return; }\n    unreachable();\n  }\n}\n","import { log } from \"../linked/util\";\r\n\r\nexport class Serializer<T> {\r\n  index: i32 = 0;\r\n  data: Float64Array = new Float64Array(8000);\r\n\r\n  public init(): void {\r\n    this.index = 0;\r\n  }\r\n\r\n  @inline\r\n  protected write_zero(instruction: T): void {\r\n    if (this.data.length <= (this.index + 2)) this.grow();\r\n    this.data[this.index++] = <f64>instruction;\r\n    this.data[this.index++] = 2.0; // stride\r\n  }\r\n\r\n  @inline\r\n  protected write_one(instruction: T, value: f64): void {\r\n    if (this.data.length <= (this.index + 3)) this.grow();\r\n    this.data[this.index++] = <f64>instruction;\r\n    this.data[this.index++] = 3.0; // stride\r\n    this.data[this.index++] = value;\r\n  }\r\n\r\n\r\n  @inline\r\n  protected write_two(instruction: T, a: f64, b: f64): void {\r\n    if (this.data.length <= (this.index + 4)) this.grow();\r\n    this.data[this.index++] = <f64>instruction;\r\n    this.data[this.index++] = 4.0; // stride\r\n    this.data[this.index++] = a;\r\n    this.data[this.index++] = b;\r\n  }\r\n\r\n  @inline\r\n  protected write_four(instruction: T, a: f64, b: f64, c: f64, d: f64): void {\r\n    if (this.data.length <= (this.index + 6)) this.grow();\r\n    this.data[this.index++] = <f64>instruction;\r\n    this.data[this.index++] = 6.0; // stride\r\n    this.data[this.index++] = a;\r\n    this.data[this.index++] = b;\r\n    this.data[this.index++] = c;\r\n    this.data[this.index++] = d;\r\n  }\r\n\r\n  @inline\r\n  protected write_five(instruction: T, a: f64, b: f64, c: f64, d: f64, e: f64): void {\r\n    if (this.data.length <= (this.index + 7)) this.grow();\r\n    this.data[this.index++] = <f64>instruction;\r\n    this.data[this.index++] = 7.0; // stride\r\n    this.data[this.index++] = a;\r\n    this.data[this.index++] = b;\r\n    this.data[this.index++] = c;\r\n    this.data[this.index++] = d;\r\n    this.data[this.index++] = e;\r\n  }\r\n\r\n  @inline\r\n  protected write_six(instruction: T, a: f64, b: f64, c: f64, d: f64, e: f64, f: f64): void {\r\n    if (this.data.length <= (this.index + 8)) this.grow();\r\n    this.data[this.index++] = <f64>instruction;\r\n    this.data[this.index++] = 8.0; // stride\r\n    this.data[this.index++] = a;\r\n    this.data[this.index++] = b;\r\n    this.data[this.index++] = c;\r\n    this.data[this.index++] = d;\r\n    this.data[this.index++] = e;\r\n    this.data[this.index++] = f;\r\n  }\r\n\r\n  @inline\r\n  protected write_eight(instruction: T, a: f64, b: f64, c: f64, d: f64, e: f64, f: f64, g: f64, h: f64): void {\r\n    if (this.data.length <= (this.index + 11)) this.grow();\r\n    this.data[this.index++] = <f64>instruction;\r\n    this.data[this.index++] = 10.0; // stride\r\n    this.data[this.index++] = a;\r\n    this.data[this.index++] = b;\r\n    this.data[this.index++] = c;\r\n    this.data[this.index++] = d;\r\n    this.data[this.index++] = e;\r\n    this.data[this.index++] = f;\r\n    this.data[this.index++] = g;\r\n    this.data[this.index++] = h;\r\n  }\r\n\r\n  @inline\r\n  protected write_nine(instruction: T, a: f64, b: f64, c: f64, d: f64, e: f64, f: f64, g: f64, h: f64, i: f64): void {\r\n    if (this.data.length <= (this.index + 11)) this.grow();\r\n    this.data[this.index++] = <f64>instruction;\r\n    this.data[this.index++] = 11.0; // stride\r\n    this.data[this.index++] = a;\r\n    this.data[this.index++] = b;\r\n    this.data[this.index++] = c;\r\n    this.data[this.index++] = d;\r\n    this.data[this.index++] = e;\r\n    this.data[this.index++] = f;\r\n    this.data[this.index++] = g;\r\n    this.data[this.index++] = h;\r\n    this.data[this.index++] = i;\r\n  }\r\n\r\n  @inline\r\n  protected write_variable(instruction: T, props: f64[]): void {\r\n    if (this.data.length <= (this.index + props.length + 2)) this.grow();\r\n    this.data[this.index++] = <f64>instruction;\r\n    this.data[this.index++] = <f64>(props.length + 2);\r\n    var i: i32 = 0;\r\n    var length: i32 = props.length;\r\n    while (i < length) {\r\n      this.data[this.index++] = props[i];\r\n      ++i;\r\n    }\r\n  }\r\n\r\n  @inline\r\n  protected grow(): void {\r\n    var data: Float64Array = new Float64Array(this.data.length + 8000);\r\n    var length: i32 = this.data.length;\r\n    var i: i32 = 0;\r\n    while (i < length) {\r\n      data[i] = this.data[i];\r\n      ++i;\r\n    }\r\n    this.data = data;\r\n  }\r\n}\r\n","import {\n  AL_MASK,\n  MAX_SIZE_32\n } from \"./allocator\";\n\n/** Size of an ArrayBuffer header. */\nexport const HEADER_SIZE: usize = (offsetof<ArrayBuffer>() + AL_MASK) & ~AL_MASK;\n/** Maximum byte length of an ArrayBuffer. */\nexport const MAX_BLENGTH: i32 = <i32>MAX_SIZE_32 - HEADER_SIZE;\n\nfunction computeSize(byteLength: i32): usize {\n  // round up to power of 2, with HEADER_SIZE=8:\n  // 0            -> 2^3  = 8\n  // 1..8         -> 2^4  = 16\n  // 9..24        -> 2^5  = 32\n  // ...\n  // MAX_LENGTH   -> 2^30 = 0x40000000 (MAX_SIZE_32)\n  return <usize>1 << <usize>(<u32>32 - clz<u32>(byteLength + HEADER_SIZE - 1));\n}\n\n// Low-level utility\n\nfunction __gc(ref: usize): void {}\n\nexport function allocateUnsafe(byteLength: i32): ArrayBuffer {\n  assert(<u32>byteLength <= <u32>MAX_BLENGTH);\n  var buffer: usize;\n  if (isManaged<ArrayBuffer>()) {\n    buffer = __gc_allocate(computeSize(byteLength), __gc); // tslint:disable-line\n  } else {\n    buffer = memory.allocate(computeSize(byteLength));\n  }\n  store<i32>(buffer, byteLength, offsetof<ArrayBuffer>(\"byteLength\"));\n  return changetype<ArrayBuffer>(buffer);\n}\n\nexport function reallocateUnsafe(buffer: ArrayBuffer, newByteLength: i32): ArrayBuffer {\n  var oldByteLength = buffer.byteLength;\n  if (newByteLength > oldByteLength) {\n    assert(newByteLength <= MAX_BLENGTH);\n    if (newByteLength <= <i32>(computeSize(oldByteLength) - HEADER_SIZE)) { // fast path: zero out additional space\n      store<i32>(changetype<usize>(buffer), newByteLength, offsetof<ArrayBuffer>(\"byteLength\"));\n    } else { // slow path: copy to new buffer\n      let newBuffer = allocateUnsafe(newByteLength);\n      memory.copy(\n        changetype<usize>(newBuffer) + HEADER_SIZE,\n        changetype<usize>(buffer) + HEADER_SIZE,\n        <usize>oldByteLength\n      );\n      if (!isManaged<ArrayBuffer>()) {\n        memory.free(changetype<usize>(buffer));\n      }\n      buffer = newBuffer;\n    }\n    memory.fill(\n      changetype<usize>(buffer) + HEADER_SIZE + <usize>oldByteLength,\n      0,\n      <usize>(newByteLength - oldByteLength)\n    );\n  } else if (newByteLength < oldByteLength) { // fast path: override size\n    // TBD: worth to copy and release if size is significantly less than before?\n    assert(newByteLength >= 0);\n    store<i32>(changetype<usize>(buffer), newByteLength, offsetof<ArrayBuffer>(\"byteLength\"));\n  }\n  return buffer;\n}\n\n// The helpers below use two different types in order to emit loads and stores that load respectively\n// store one type to/from memory while returning/taking the desired output/input type. This allows to\n// emit instructions like\n//\n// * `i32.load8` ^= `<i32>load<i8>(...)` that reads an i8 but returns an i32, or\n// * `i64.load32_s` ^= `<i64>load<i32>(...)`) that reads a 32-bit as a 64-bit integer\n//\n// without having to emit an additional instruction for conversion purposes. The second parameter\n// can be omitted for references and other loads and stores that simply return the exact type.\n\n@inline export function LOAD<T,TOut = T>(buffer: ArrayBuffer, index: i32, byteOffset: i32 = 0): TOut {\n  return <TOut>load<T>(changetype<usize>(buffer) + (<usize>index << alignof<T>()) + <usize>byteOffset, HEADER_SIZE);\n}\n\n@inline export function STORE<T,TIn = T>(buffer: ArrayBuffer, index: i32, value: TIn, byteOffset: i32 = 0): void {\n  store<T>(changetype<usize>(buffer) + (<usize>index << alignof<T>()) + <usize>byteOffset, value, HEADER_SIZE);\n}\n","import {\n  HEADER_SIZE as AB_HEADER_SIZE,\n  MAX_BLENGTH as AB_MAX_BLENGTH,\n  allocateUnsafe,\n  LOAD,\n  STORE\n} from \"./arraybuffer\";\n\nimport {\n  SORT as SORT_IMPL\n} from \"./sort\";\n\n/** Typed array base class. Not a global object. */\nexport abstract class TypedArray<T> {\n  [key: number]: T; // compatibility only\n\n  readonly buffer: ArrayBuffer;\n  readonly byteOffset: i32;\n  readonly byteLength: i32;\n\n  constructor(length: i32) {\n    const MAX_LENGTH = <u32>AB_MAX_BLENGTH / sizeof<T>();\n    if (<u32>length > MAX_LENGTH) throw new RangeError(\"Invalid typed array length\");\n    var byteLength = length << alignof<T>();\n    var buffer = allocateUnsafe(byteLength);\n    memory.fill(changetype<usize>(buffer) + AB_HEADER_SIZE, 0, <usize>byteLength);\n    this.buffer = buffer;\n    this.byteOffset = 0;\n    this.byteLength = byteLength;\n  }\n\n  @inline\n  get length(): i32 {\n    return this.byteLength >>> alignof<T>();\n  }\n\n  @operator(\"[]\")\n  protected __get(index: i32): T {\n    if (<u32>index >= <u32>(this.byteLength >>> alignof<T>())) throw new Error(\"Index out of bounds\");\n    return LOAD<T>(this.buffer, index, this.byteOffset);\n  }\n\n  @inline @operator(\"{}\")\n  protected __unchecked_get(index: i32): T {\n    return LOAD<T>(this.buffer, index, this.byteOffset);\n  }\n\n  @operator(\"[]=\")\n  protected __set(index: i32, value: NATIVE<T>): void {\n    if (<u32>index >= <u32>(this.byteLength >>> alignof<T>())) throw new Error(\"Index out of bounds\");\n    STORE<T,NATIVE<T>>(this.buffer, index, value, this.byteOffset);\n  }\n\n  @inline @operator(\"{}=\")\n  protected __unchecked_set(index: i32, value: NATIVE<T>): void {\n    STORE<T,NATIVE<T>>(this.buffer, index, value, this.byteOffset);\n  }\n\n  // copyWithin(target: i32, start: i32, end: i32 = this.length): this\n}\n\n@inline\nexport function FILL<TArray extends TypedArray<T>, T>(\n  array: TArray,\n  value: NATIVE<T>,\n  start: i32,\n  end: i32\n): TArray {\n  var buffer = array.buffer;\n  var byteOffset = array.byteOffset;\n  var len = array.length;\n  start = start < 0 ? max(len + start, 0) : min(start, len);\n  end   = end   < 0 ? max(len + end,   0) : min(end,   len);\n  if (sizeof<T>() == 1) {\n    if (start < end) {\n      memory.fill(\n        changetype<usize>(buffer) + start + byteOffset + AB_HEADER_SIZE,\n        <u8>value,\n        <usize>(end - start)\n      );\n    }\n  } else {\n    for (; start < end; ++start) {\n      STORE<T,NATIVE<T>>(buffer, start, value, byteOffset);\n    }\n  }\n  return array;\n}\n\n@inline\nexport function SORT<TArray extends TypedArray<T>, T>(\n  array: TArray,\n  comparator: (a: T, b: T) => i32\n): TArray {\n  var byteOffset = array.byteOffset;\n  var length = array.length;\n  if (length <= 1) return array;\n  var buffer = array.buffer;\n  if (length == 2) {\n    let a = LOAD<T>(buffer, 1, byteOffset);\n    let b = LOAD<T>(buffer, 0, byteOffset);\n    if (comparator(a, b) < 0) {\n      STORE<T>(buffer, 1, b, byteOffset);\n      STORE<T>(buffer, 0, a, byteOffset);\n    }\n    return array;\n  }\n  SORT_IMPL<T>(buffer, byteOffset, length, comparator);\n  return array;\n}\n\n@inline\nexport function SUBARRAY<TArray extends TypedArray<T>, T>(\n  array: TArray,\n  begin: i32,\n  end: i32\n): TArray {\n  var length = <i32>array.length;\n  if (begin < 0) begin = max(length + begin, 0);\n  else begin = min(begin, length);\n  if (end < 0) end = max(length + end, begin);\n  else end = max(min(end, length), begin);\n  var slice = memory.allocate(offsetof<TArray>());\n  store<usize>(slice, array.buffer, offsetof<TArray>(\"buffer\"));\n  store<i32>(slice, <i32>array.byteOffset + (begin << alignof<T>()), offsetof<TArray>(\"byteOffset\"));\n  store<i32>(slice, (end - begin) << alignof<T>(), offsetof<TArray>(\"byteLength\"));\n  return changetype<TArray>(slice);\n}\n\n@inline\nexport function REDUCE<TArray extends TypedArray<T>, T, TRet>(\n  array: TArray,\n  callbackfn: (accumulator: TRet, value: T, index: i32, array: TArray) => TRet,\n  initialValue: TRet\n): TRet {\n  var index = 0;\n  var length = <i32>array.length;\n  while (index != length) {\n    initialValue = callbackfn(\n      initialValue,\n      unchecked(array[index]),\n      index,\n      array,\n    );\n    ++index;\n  }\n  return initialValue;\n}\n\n@inline\nexport function REDUCE_RIGHT<TArray extends TypedArray<T>, T, TRet>(\n  array: TArray,\n  callbackfn: (accumulator: TRet, value: T, index: i32, array: TArray) => TRet,\n  initialValue: TRet\n): TRet {\n  var index = <i32>array.length - 1;\n  var length = -1;\n  while (index != length) {\n    initialValue = callbackfn(\n      initialValue,\n      unchecked(array[index]),\n      index,\n      array,\n    );\n    --index;\n  }\n  return initialValue;\n}\n\n@inline\nexport function MAP<TArray extends TypedArray<T>, T>(\n  array: TArray,\n  callbackfn: (value: T, index: i32, self: TArray) => T,\n): TArray {\n  var length: i32 = array.length;\n  var result = instantiate<TArray>(length);\n  var i: i32 = 0;\n  while (i < length) {\n    unchecked(result[i] = callbackfn(array[i], i, <TArray>array));\n    ++i;\n  }\n  return result;\n}\n","// this function will go away once `memory.copy` becomes an intrinsic\nexport function memcpy(dest: usize, src: usize, n: usize): void { // see: musl/src/string/memcpy.c\n  var w: u32, x: u32;\n\n  // copy 1 byte each until src is aligned to 4 bytes\n  while (n && (src & 3)) {\n    store<u8>(dest++, load<u8>(src++));\n    n--;\n  }\n\n  // if dst is aligned to 4 bytes as well, copy 4 bytes each\n  if ((dest & 3) == 0) {\n    while (n >= 16) {\n      store<u32>(dest     , load<u32>(src     ));\n      store<u32>(dest +  4, load<u32>(src +  4));\n      store<u32>(dest +  8, load<u32>(src +  8));\n      store<u32>(dest + 12, load<u32>(src + 12));\n      src += 16; dest += 16; n -= 16;\n    }\n    if (n & 8) {\n      store<u32>(dest    , load<u32>(src    ));\n      store<u32>(dest + 4, load<u32>(src + 4));\n      dest += 8; src += 8;\n    }\n    if (n & 4) {\n      store<u32>(dest, load<u32>(src));\n      dest += 4; src += 4;\n    }\n    if (n & 2) { // drop to 2 bytes each\n      store<u16>(dest, load<u16>(src));\n      dest += 2; src += 2;\n    }\n    if (n & 1) { // drop to 1 byte\n      store<u8>(dest++, load<u8>(src++));\n    }\n    return;\n  }\n\n  // if dst is not aligned to 4 bytes, use alternating shifts to copy 4 bytes each\n  // doing shifts if faster when copying enough bytes (here: 32 or more)\n  if (n >= 32) {\n    switch (dest & 3) {\n      // known to be != 0\n      case 1: {\n        w = load<u32>(src);\n        store<u8>(dest++, load<u8>(src++));\n        store<u8>(dest++, load<u8>(src++));\n        store<u8>(dest++, load<u8>(src++));\n        n -= 3;\n        while (n >= 17) {\n          x = load<u32>(src + 1);\n          store<u32>(dest, w >> 24 | x << 8);\n          w = load<u32>(src + 5);\n          store<u32>(dest + 4, x >> 24 | w << 8);\n          x = load<u32>(src + 9);\n          store<u32>(dest + 8, w >> 24 | x << 8);\n          w = load<u32>(src + 13);\n          store<u32>(dest + 12, x >> 24 | w << 8);\n          src += 16; dest += 16; n -= 16;\n        }\n        break;\n      }\n      case 2: {\n        w = load<u32>(src);\n        store<u8>(dest++, load<u8>(src++));\n        store<u8>(dest++, load<u8>(src++));\n        n -= 2;\n        while (n >= 18) {\n          x = load<u32>(src + 2);\n          store<u32>(dest, w >> 16 | x << 16);\n          w = load<u32>(src + 6);\n          store<u32>(dest + 4, x >> 16 | w << 16);\n          x = load<u32>(src + 10);\n          store<u32>(dest + 8, w >> 16 | x << 16);\n          w = load<u32>(src + 14);\n          store<u32>(dest + 12, x >> 16 | w << 16);\n          src += 16; dest += 16; n -= 16;\n        }\n        break;\n      }\n      case 3: {\n        w = load<u32>(src);\n        store<u8>(dest++, load<u8>(src++));\n        n -= 1;\n        while (n >= 19) {\n          x = load<u32>(src + 3);\n          store<u32>(dest, w >> 8 | x << 24);\n          w = load<u32>(src + 7);\n          store<u32>(dest + 4, x >> 8 | w << 24);\n          x = load<u32>(src + 11);\n          store<u32>(dest + 8, w >> 8 | x << 24);\n          w = load<u32>(src + 15);\n          store<u32>(dest + 12, x >> 8 | w << 24);\n          src += 16; dest += 16; n -= 16;\n        }\n        break;\n      }\n    }\n  }\n\n  // copy remaining bytes one by one\n  if (n & 16) {\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n  }\n  if (n & 8) {\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n  }\n  if (n & 4) {\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n  }\n  if (n & 2) {\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n  }\n  if (n & 1) {\n    store<u8>(dest++, load<u8>(src++));\n  }\n}\n\n// this function will go away once `memory.copy` becomes an intrinsic\nexport function memmove(dest: usize, src: usize, n: usize): void { // see: musl/src/string/memmove.c\n  if (dest === src) return;\n  if (src + n <= dest || dest + n <= src) {\n    memcpy(dest, src, n);\n    return;\n  }\n  if (dest < src) {\n    if ((src & 7) == (dest & 7)) {\n      while (dest & 7) {\n        if (!n) return;\n        --n;\n        store<u8>(dest++, load<u8>(src++));\n      }\n      while (n >= 8) {\n        store<u64>(dest, load<u64>(src));\n        n    -= 8;\n        dest += 8;\n        src  += 8;\n      }\n    }\n    while (n) {\n      store<u8>(dest++, load<u8>(src++));\n      --n;\n    }\n  } else {\n    if ((src & 7) == (dest & 7)) {\n      while ((dest + n) & 7) {\n        if (!n) return;\n        store<u8>(dest + --n, load<u8>(src + n));\n      }\n      while (n >= 8) {\n        n -= 8;\n        store<u64>(dest + n, load<u64>(src + n));\n      }\n    }\n    while (n) {\n      store<u8>(dest + --n, load<u8>(src + n));\n    }\n  }\n}\n\n// this function will go away once `memory.fill` becomes an intrinsic\nexport function memset(dest: usize, c: u8, n: usize): void { // see: musl/src/string/memset\n\n  // fill head and tail with minimal branching\n  if (!n) return;\n  store<u8>(dest, c);\n  store<u8>(dest + n - 1, c);\n  if (n <= 2) return;\n\n  store<u8>(dest + 1, c);\n  store<u8>(dest + 2, c);\n  store<u8>(dest + n - 2, c);\n  store<u8>(dest + n - 3, c);\n  if (n <= 6) return;\n  store<u8>(dest + 3, c);\n  store<u8>(dest + n - 4, c);\n  if (n <= 8) return;\n\n  // advance pointer to align it at 4-byte boundary\n  var k: usize = -dest & 3;\n  dest += k;\n  n -= k;\n  n &= -4;\n\n  var c32: u32 = <u32>-1 / 255 * c;\n\n  // fill head/tail up to 28 bytes each in preparation\n  store<u32>(dest, c32);\n  store<u32>(dest + n - 4, c32);\n  if (n <= 8) return;\n  store<u32>(dest + 4, c32);\n  store<u32>(dest + 8, c32);\n  store<u32>(dest + n - 12, c32);\n  store<u32>(dest + n - 8, c32);\n  if (n <= 24) return;\n  store<u32>(dest + 12, c32);\n  store<u32>(dest + 16, c32);\n  store<u32>(dest + 20, c32);\n  store<u32>(dest + 24, c32);\n  store<u32>(dest + n - 28, c32);\n  store<u32>(dest + n - 24, c32);\n  store<u32>(dest + n - 20, c32);\n  store<u32>(dest + n - 16, c32);\n\n  // align to a multiple of 8\n  k = 24 + (dest & 4);\n  dest += k;\n  n -= k;\n\n  // copy 32 bytes each\n  var c64: u64 = <u64>c32 | (<u64>c32 << 32);\n  while (n >= 32) {\n    store<u64>(dest, c64);\n    store<u64>(dest + 8, c64);\n    store<u64>(dest + 16, c64);\n    store<u64>(dest + 24, c64);\n    n -= 32;\n    dest += 32;\n  }\n}\n\nexport function memcmp(vl: usize, vr: usize, n: usize): i32 { // see: musl/src/string/memcmp.c\n  if (vl == vr) return 0;\n  while (n != 0 && load<u8>(vl) == load<u8>(vr)) {\n    n--; vl++; vr++;\n  }\n  return n ? <i32>load<u8>(vl) - <i32>load<u8>(vr) : 0;\n}\n","import {\n  HEADER_SIZE as HEADER_SIZE_AB\n} from \"./internal/arraybuffer\";\n\nimport {\n  HASH\n} from \"./internal/hash\";\n\n// A deterministic hash map based on CloseTable from https://github.com/jorendorff/dht\n\nconst INITIAL_CAPACITY = 4;\nconst FILL_FACTOR: f64 = 8 / 3;\nconst FREE_FACTOR: f64 = 3 / 4;\n\n/** Structure of a map entry. */\n@unmanaged class MapEntry<K,V> {\n  key: K;\n  value: V;\n  taggedNext: usize; // LSB=1 indicates EMPTY\n}\n\n/** Empty bit. */\nconst EMPTY: usize = 1 << 0;\n\n/** Size of a bucket. */\nconst BUCKET_SIZE = sizeof<usize>();\n\n/** Computes the alignment of an entry. */\n@inline function ENTRY_ALIGN<K,V>(): usize {\n  // can align to 4 instead of 8 if 32-bit and K/V is <= 32-bits\n  const maxkv = sizeof<K>() > sizeof<V>() ? sizeof<K>() : sizeof<V>();\n  const align = (maxkv > sizeof<usize>() ? maxkv : sizeof<usize>()) - 1;\n  return align;\n}\n\n/** Computes the aligned size of an entry. */\n@inline function ENTRY_SIZE<K,V>(): usize {\n  const align = ENTRY_ALIGN<K,V>();\n  const size = (offsetof<MapEntry<K,V>>() + align) & ~align;\n  return size;\n}\n\nexport class Map<K,V> {\n\n  // buckets holding references to the respective first entry within\n  private buckets: ArrayBuffer; // usize[bucketsMask + 1]\n  private bucketsMask: u32;\n\n  // entries in insertion order\n  private entries: ArrayBuffer; // MapEntry<K,V>[entriesCapacity]\n  private entriesCapacity: i32;\n  private entriesOffset: i32;\n  private entriesCount: i32;\n\n  get size(): i32 { return this.entriesCount; }\n\n  constructor() { this.clear(); }\n\n  clear(): void {\n    const bucketsSize = INITIAL_CAPACITY * <i32>BUCKET_SIZE;\n    this.buckets = new ArrayBuffer(bucketsSize);\n    this.bucketsMask = INITIAL_CAPACITY - 1;\n    const entriesSize = INITIAL_CAPACITY * <i32>ENTRY_SIZE<K,V>();\n    this.entries = new ArrayBuffer(entriesSize, true);\n    this.entriesCapacity = INITIAL_CAPACITY;\n    this.entriesOffset = 0;\n    this.entriesCount = 0;\n  }\n\n  private find(key: K, hashCode: u32): MapEntry<K,V> | null {\n    var entry = load<MapEntry<K,V>>(\n      changetype<usize>(this.buckets) + <usize>(hashCode & this.bucketsMask) * BUCKET_SIZE,\n      HEADER_SIZE_AB\n    );\n    while (entry) {\n      if (!(entry.taggedNext & EMPTY) && entry.key == key) return entry;\n      entry = changetype<MapEntry<K,V>>(entry.taggedNext & ~EMPTY);\n    }\n    return null;\n  }\n\n  has(key: K): bool {\n    return this.find(key, HASH<K>(key)) !== null;\n  }\n\n  get(key: K): V {\n    var entry = this.find(key, HASH<K>(key));\n    return entry ? entry.value : <V>unreachable();\n  }\n\n  set(key: K, value: V): void {\n    var hashCode = HASH<K>(key);\n    var entry = this.find(key, hashCode);\n    if (entry) {\n      entry.value = value;\n    } else {\n      // check if rehashing is necessary\n      if (this.entriesOffset == this.entriesCapacity) {\n        this.rehash(\n          this.entriesCount < <i32>(this.entriesCapacity * FREE_FACTOR)\n            ?  this.bucketsMask           // just rehash if 1/4+ entries are empty\n            : (this.bucketsMask << 1) | 1 // grow capacity to next 2^N\n        );\n      }\n      // append new entry\n      let entries = this.entries;\n      entry = changetype<MapEntry<K,V>>(\n        changetype<usize>(entries) + HEADER_SIZE_AB + this.entriesOffset++ * ENTRY_SIZE<K,V>()\n      );\n      entry.key = key;\n      entry.value = value;\n      ++this.entriesCount;\n      // link with previous entry in bucket\n      let bucketPtrBase = changetype<usize>(this.buckets) + <usize>(hashCode & this.bucketsMask) * BUCKET_SIZE;\n      entry.taggedNext = load<usize>(bucketPtrBase, HEADER_SIZE_AB);\n      store<usize>(bucketPtrBase, changetype<usize>(entry), HEADER_SIZE_AB);\n      if (isManaged<K>()) __gc_link(changetype<usize>(this), changetype<usize>(key)); // tslint:disable-line\n      if (isManaged<V>()) __gc_link(changetype<usize>(this), changetype<usize>(value)); // tslint:disable-line\n    }\n  }\n\n  delete(key: K): bool {\n    var entry = this.find(key, HASH<K>(key));\n    if (!entry) return false;\n    entry.taggedNext |= EMPTY;\n    --this.entriesCount;\n    // check if rehashing is appropriate\n    var halfBucketsMask = this.bucketsMask >> 1;\n    if (\n      halfBucketsMask + 1 >= max<u32>(INITIAL_CAPACITY, this.entriesCount) &&\n      this.entriesCount < <i32>(this.entriesCapacity * FREE_FACTOR)\n    ) this.rehash(halfBucketsMask);\n    return true;\n  }\n\n  private rehash(newBucketsMask: u32): void {\n    var newBucketsCapacity = <i32>(newBucketsMask + 1);\n    var newBuckets = new ArrayBuffer(newBucketsCapacity * <i32>BUCKET_SIZE);\n    var newEntriesCapacity = <i32>(newBucketsCapacity * FILL_FACTOR);\n    var newEntries = new ArrayBuffer(newEntriesCapacity * <i32>ENTRY_SIZE<K,V>(), true);\n\n    // copy old entries to new entries\n    var oldPtr = changetype<usize>(this.entries) + HEADER_SIZE_AB;\n    var oldEnd = oldPtr + <usize>this.entriesOffset * ENTRY_SIZE<K,V>();\n    var newPtr = changetype<usize>(newEntries) + HEADER_SIZE_AB;\n    while (oldPtr != oldEnd) {\n      let oldEntry = changetype<MapEntry<K,V>>(oldPtr);\n      if (!(oldEntry.taggedNext & EMPTY)) {\n        let newEntry = changetype<MapEntry<K,V>>(newPtr);\n        newEntry.key = oldEntry.key;\n        newEntry.value = oldEntry.value;\n        let newBucketIndex = HASH<K>(oldEntry.key) & newBucketsMask;\n        let newBucketPtrBase = changetype<usize>(newBuckets) + <usize>newBucketIndex * BUCKET_SIZE;\n        newEntry.taggedNext = load<usize>(newBucketPtrBase, HEADER_SIZE_AB);\n        store<usize>(newBucketPtrBase, newPtr, HEADER_SIZE_AB);\n        newPtr += ENTRY_SIZE<K,V>();\n      }\n      oldPtr += ENTRY_SIZE<K,V>();\n    }\n\n    this.buckets = newBuckets;\n    this.bucketsMask = newBucketsMask;\n    this.entries = newEntries;\n    this.entriesCapacity = newEntriesCapacity;\n    this.entriesOffset = this.entriesCount;\n  }\n\n  toString(): string {\n    return \"[object Map]\";\n  }\n\n  private __gc(): void {\n    __gc_mark(changetype<usize>(this.buckets)); // tslint:disable-line\n    var entries = this.entries;\n    __gc_mark(changetype<usize>(entries)); // tslint:disable-line\n    if (isManaged<K>() || isManaged<V>()) {\n      let offset: usize = 0;\n      let end: usize = this.entriesOffset * ENTRY_SIZE<K,V>();\n      while (offset < end) {\n        let entry = changetype<MapEntry<K,V>>(\n          changetype<usize>(entries) + HEADER_SIZE_AB + offset * ENTRY_SIZE<K,V>()\n        );\n        if (!(entry.taggedNext & EMPTY)) {\n          if (isManaged<K>()) __gc_mark(changetype<usize>(entry.key)); // tslint:disable-line\n          if (isManaged<V>()) __gc_mark(changetype<usize>(entry.value)); // tslint:disable-line\n        }\n        offset += ENTRY_SIZE<K,V>();\n      }\n    }\n  }\n}\n","import {\n  HEADER_SIZE,\n  MAX_BLENGTH,\n  allocateUnsafe\n} from \"./internal/arraybuffer\";\n\n@sealed\nexport class ArrayBuffer {\n\n  readonly byteLength: i32; // capped to [0, MAX_LENGTH]\n\n  // @unsafe\n  get data(): usize { return changetype<usize>(this) + HEADER_SIZE; }\n\n  constructor(length: i32, unsafe: bool = false) {\n    if (<u32>length > <u32>MAX_BLENGTH) throw new RangeError(\"Invalid array buffer length\");\n    var buffer = allocateUnsafe(length);\n    if (!unsafe) memory.fill(changetype<usize>(buffer) + HEADER_SIZE, 0, <usize>length);\n    return buffer;\n  }\n\n  slice(begin: i32 = 0, end: i32 = MAX_BLENGTH): ArrayBuffer {\n    var len = this.byteLength;\n    if (begin < 0) begin = max(len + begin, 0);\n    else begin = min(begin, len);\n    if (end < 0) end = max(len + end, 0);\n    else end = min(end, len);\n    var newLen = max(end - begin, 0);\n    var buffer = allocateUnsafe(newLen);\n    memory.copy(changetype<usize>(buffer) + HEADER_SIZE, changetype<usize>(this) + HEADER_SIZE + begin, newLen);\n    return buffer;\n  }\n\n  toString(): string {\n    return \"[object ArrayBuffer]\";\n  }\n}\n","import {\r\n  CanvasInstruction,\r\n  Direction,\r\n  FillRule,\r\n  GlobalCompositeOperation,\r\n  ImageSmoothingQuality,\r\n  LineCap,\r\n  LineJoin,\r\n  TextAlign,\r\n  TextBaseline,\r\n} from \"../shared\";\r\nimport { Serializer } from \"./Serializer\";\r\nimport { ImageBitmap } from \"../primitives\";\r\nimport { send_string_to_js } from \"../linked\";\r\n\r\nexport class CanvasRenderingContext2DSerializer extends Serializer<CanvasInstruction> {\r\n  private _stringMap: Map<string, i32> = new Map<string, i32>();\r\n  private _stringIndex: i32 = -1;\r\n\r\n  public init(): void {\r\n    super.init();\r\n  }\r\n\r\n  @inline\r\n  protected write_arc(x: f64, y: f64, radius: f64, startAngle: f64, endAngle: f64, anticlockwise: bool): void {\r\n    this.write_six(\r\n      CanvasInstruction.Arc,\r\n      x,\r\n      y,\r\n      radius,\r\n      startAngle,\r\n      endAngle,\r\n      anticlockwise ? 1.0 : 0.0,\r\n    );\r\n  }\r\n\r\n  @inline\r\n  protected write_arc_to(x1: f64, y1: f64, x2: f64, y2: f64, radius: f64): void {\r\n    this.write_five(\r\n      CanvasInstruction.ArcTo,\r\n      x1,\r\n      y1,\r\n      x2,\r\n      y2,\r\n      radius,\r\n    );\r\n  }\r\n\r\n  @inline\r\n  protected write_begin_path(): void {\r\n    this.write_zero(CanvasInstruction.BeginPath);\r\n  }\r\n\r\n  @inline\r\n  protected write_bezier_curve_to(cp1x: f64, cp1y: f64, cp2x: f64, cp2y: f64, x: f64, y: f64): void {\r\n    this.write_six(\r\n      CanvasInstruction.BezierCurveTo,\r\n      cp1x,\r\n      cp1y,\r\n      cp2x,\r\n      cp2y,\r\n      x,\r\n      y,\r\n    );\r\n  }\r\n\r\n  @inline\r\n  protected write_clear_rect(x: f64, y: f64, width: f64, height: f64): void {\r\n    this.write_four(\r\n      CanvasInstruction.ClearRect,\r\n      x,\r\n      y,\r\n      width,\r\n      height,\r\n    );\r\n  }\r\n\r\n  @inline\r\n  protected write_clip(fillRule: FillRule): void {\r\n    this.write_one(\r\n      CanvasInstruction.Clip,\r\n      <f64>fillRule,\r\n    );\r\n  }\r\n\r\n  @inline\r\n  protected write_close_path(): void {\r\n    this.write_zero(CanvasInstruction.ClosePath);\r\n  }\r\n\r\n  @inline\r\n  protected write_direction(value: Direction): void {\r\n    this.write_one(\r\n      CanvasInstruction.Direction,\r\n      <f64>value,\r\n    );\r\n  }\r\n\r\n  @inline\r\n  protected write_draw_focus_if_needed(): void {\r\n    this.write_zero(CanvasInstruction.DrawFocusIfNeeded);\r\n  }\r\n\r\n  @inline\r\n  protected write_draw_image(img: ImageBitmap, x: f64, y: f64, width: f64, height: f64, sx: f64, sy: f64, swidth: f64, sheight: f64): void {\r\n    this.write_nine(\r\n      CanvasInstruction.DrawImage,\r\n      <f64>img._index,\r\n      x,\r\n      y,\r\n      width,\r\n      height,\r\n      sx,\r\n      sy,\r\n      swidth,\r\n      sheight,\r\n    );\r\n  }\r\n\r\n  @inline\r\n  protected write_ellipse(x: f64, y: f64, radiusX: f64, radiusY: f64, rotation: f64, startAngle: f64, endAngle: f64, anticlockwise: bool): void {\r\n    this.write_eight(\r\n      CanvasInstruction.Ellipse,\r\n      x,\r\n      y,\r\n      radiusX,\r\n      radiusY,\r\n      rotation,\r\n      startAngle,\r\n      endAngle,\r\n      anticlockwise ? 1.0 : 0.0,\r\n    );\r\n  }\r\n\r\n  @inline\r\n  protected write_fill(fillRule: FillRule = FillRule.nonzero): void {\r\n    this.write_one(\r\n      CanvasInstruction.Fill,\r\n      <f64>fillRule,\r\n    );\r\n  }\r\n\r\n  @inline\r\n  protected write_fill_rect(x: f64, y: f64, width: f64, height: f64): void {\r\n    this.write_four(\r\n      CanvasInstruction.FillRect,\r\n      x,\r\n      y,\r\n      width,\r\n      height,\r\n    );\r\n  }\r\n\r\n  @inline\r\n  protected write_fill_style(value: string): void {\r\n    this.write_one(\r\n      CanvasInstruction.FillStyle,\r\n      this.send_string(value),\r\n    );\r\n  }\r\n\r\n  @inline\r\n  protected write_fill_text(text: string, x: f64, y: f64, maxWidth: f64): void {\r\n    this.write_four(\r\n      CanvasInstruction.FillText,\r\n      this.send_string(text),\r\n      x,\r\n      y,\r\n      maxWidth,\r\n    );\r\n  }\r\n\r\n  @inline\r\n  protected write_filter(value: string): void {\r\n    this.write_one(\r\n      CanvasInstruction.Filter,\r\n      this.send_string(value),\r\n    );\r\n  }\r\n\r\n  @inline\r\n  protected write_font(value: string): void {\r\n    this.write_one(\r\n      CanvasInstruction.Font,\r\n      this.send_string(value),\r\n    )\r\n  }\r\n\r\n  @inline\r\n  protected write_global_alpha(value: f64): void {\r\n    this.write_one(\r\n      CanvasInstruction.GlobalAlpha,\r\n      value,\r\n    );\r\n  }\r\n\r\n  @inline\r\n  protected write_global_composite_operation(value: GlobalCompositeOperation): void {\r\n    this.write_one(\r\n      CanvasInstruction.GlobalCompositeOperation,\r\n      <f64>value,\r\n    )\r\n  }\r\n\r\n  @inline\r\n  protected write_image_smoothing_enabled(value: bool): void {\r\n    this.write_one(\r\n      CanvasInstruction.ImageSmoothingEnabled,\r\n      value ? 1.0 : 0.0,\r\n    );\r\n  }\r\n\r\n  @inline\r\n  protected write_image_smoothing_quality(value: ImageSmoothingQuality): void {\r\n    this.write_one(\r\n      CanvasInstruction.ImageSmoothingQuality,\r\n      <f64>value,\r\n    );\r\n  }\r\n\r\n  @inline\r\n  protected write_line_cap(value: LineCap): void {\r\n    this.write_one(\r\n      CanvasInstruction.LineCap,\r\n      <f64>value,\r\n    );\r\n  }\r\n\r\n  @inline\r\n  protected write_line_dash(lineDash: f64[]): void {\r\n    this.write_variable(\r\n      CanvasInstruction.LineDash,\r\n      lineDash,\r\n    );\r\n  }\r\n\r\n  @inline\r\n  protected write_line_dash_offset(value: f64): void {\r\n    this.write_one(\r\n      CanvasInstruction.LineDashOffset,\r\n      <f64>value,\r\n    );\r\n  }\r\n\r\n  @inline\r\n  protected write_line_join(value: LineJoin): void {\r\n    this.write_one(\r\n      CanvasInstruction.LineJoin,\r\n      <f64>value,\r\n    );\r\n  }\r\n\r\n  @inline\r\n  protected write_line_to(x: f64, y: f64): void {\r\n    this.write_two(\r\n      CanvasInstruction.LineTo,\r\n      x,\r\n      y,\r\n    );\r\n  }\r\n\r\n  @inline\r\n  protected write_line_width(value: f64): void {\r\n    this.write_one(\r\n      CanvasInstruction.LineWidth,\r\n      <f64>value,\r\n    );\r\n  }\r\n\r\n  @inline\r\n  protected write_miter_limit(value: f64): void {\r\n    this.write_one(\r\n      CanvasInstruction.MiterLimit,\r\n      value,\r\n    );\r\n  }\r\n\r\n  @inline\r\n  protected write_move_to(x: f64, y: f64): void {\r\n    this.write_two(\r\n      CanvasInstruction.MoveTo,\r\n      x,\r\n      y,\r\n    );\r\n  }\r\n\r\n  @inline\r\n  protected write_quadratic_curve_to(cpx: f64, cpy: f64, x: f64, y: f64): void {\r\n    this.write_four(\r\n      CanvasInstruction.QuadraticCurveTo,\r\n      cpx,\r\n      cpy,\r\n      x,\r\n      y,\r\n    );\r\n  }\r\n\r\n  @inline\r\n  protected write_rect(x: f64, y: f64, width: f64, height: f64): void {\r\n    this.write_four(\r\n      CanvasInstruction.Rect,\r\n      x,\r\n      y,\r\n      width,\r\n      height,\r\n    );\r\n  }\r\n\r\n  @inline\r\n  protected write_restore(): void {\r\n    this.write_zero(CanvasInstruction.Restore);\r\n  }\r\n\r\n  @inline\r\n  protected write_rotate(angle: f64): void {\r\n    this.write_one(\r\n      CanvasInstruction.Rotate,\r\n      angle,\r\n    );\r\n  }\r\n\r\n  @inline\r\n  protected write_save(): void {\r\n    this.write_zero(CanvasInstruction.Save);\r\n  }\r\n\r\n  @inline\r\n  protected write_scale(x: f64, y: f64): void {\r\n    this.write_two(\r\n      CanvasInstruction.Scale,\r\n      x,\r\n      y,\r\n    );\r\n  }\r\n\r\n  @inline\r\n  protected write_set_transform(a: f64, b: f64, c: f64, d: f64, e: f64, f: f64 ): void {\r\n    this.write_six(\r\n      CanvasInstruction.SetTransform,\r\n      a,\r\n      b,\r\n      c,\r\n      d,\r\n      e,\r\n      f,\r\n    );\r\n  }\r\n\r\n  @inline\r\n  protected write_shadow_blur(value: f64): void {\r\n    this.write_one(\r\n      CanvasInstruction.ShadowBlur,\r\n      value,\r\n    );\r\n  }\r\n\r\n  @inline\r\n  protected write_shadow_color(value: string): void {\r\n    this.write_one(\r\n      CanvasInstruction.ShadowColor,\r\n      this.send_string(value),\r\n    );\r\n  }\r\n\r\n  @inline\r\n  protected write_shadow_offset_x(value: f64): void {\r\n    this.write_one(\r\n      CanvasInstruction.ShadowOffsetX,\r\n      value,\r\n    );\r\n  }\r\n\r\n  @inline\r\n  protected write_shadow_offset_y(value: f64): void {\r\n    this.write_one(\r\n      CanvasInstruction.ShadowOffsetY,\r\n      value,\r\n    );\r\n  }\r\n\r\n  @inline\r\n  protected write_stroke(): void {\r\n    this.write_zero(CanvasInstruction.Stroke);\r\n  }\r\n\r\n  @inline\r\n  protected write_stroke_rect(x: f64, y: f64, width: f64, height: f64): void {\r\n    this.write_four(\r\n      CanvasInstruction.StrokeRect,\r\n      x,\r\n      y,\r\n      width,\r\n      height,\r\n    );\r\n  }\r\n\r\n  @inline\r\n  protected write_stroke_style(value: string): void {\r\n    this.write_one(\r\n      CanvasInstruction.StrokeStyle,\r\n      this.send_string(value),\r\n    )\r\n  }\r\n\r\n  @inline\r\n  protected write_stroke_text(text: string, x: f64, y: f64, maxWidth: f64): void {\r\n    this.write_four(\r\n      CanvasInstruction.StrokeText,\r\n      this.send_string(text),\r\n      x,\r\n      y,\r\n      maxWidth,\r\n    );\r\n  }\r\n\r\n  @inline\r\n  protected write_text_align(value: TextAlign): void {\r\n    this.write_one(\r\n      CanvasInstruction.TextAlign,\r\n      <f64>value,\r\n    );\r\n  }\r\n\r\n  @inline\r\n  protected write_text_baseline(value: TextBaseline): void {\r\n    this.write_one(\r\n      CanvasInstruction.TextBaseline,\r\n      <f64>value,\r\n    );\r\n  }\r\n\r\n  @inline\r\n  protected write_transform(a: f64, b: f64, c: f64, d: f64, e: f64, f: f64): void {\r\n    this.write_six(\r\n      CanvasInstruction.Transform,\r\n      a,\r\n      b,\r\n      c,\r\n      d,\r\n      e,\r\n      f,\r\n    );\r\n  }\r\n\r\n  @inline\r\n  protected write_translate(x: f64, y: f64): void {\r\n    this.write_two(\r\n      CanvasInstruction.Translate,\r\n      x,\r\n      y,\r\n    );\r\n  }\r\n\r\n  @inline\r\n  protected write_commit(): void {\r\n    this.write_zero(CanvasInstruction.Commit);\r\n    this.index = 0;\r\n  }\r\n\r\n  @inline\r\n  protected send_string(value: string): f64 {\r\n    if (this._stringMap.has(value)) {\r\n      return <f64>this._stringMap.get(value);\r\n    }\r\n    ++this._stringIndex;\r\n    this._stringMap.set(value, this._stringIndex);\r\n    send_string_to_js(this._stringIndex, value);\r\n    return <f64>this._stringIndex;\r\n  }\r\n}\r\n","import { ImageBitmap, Matrix } from \"../primitives\";\r\nimport {\r\n  Direction,\r\n  FillRule,\r\n  GlobalCompositeOperation,\r\n  ImageSmoothingQuality,\r\n  LineCap,\r\n  LineJoin,\r\n  TextAlign,\r\n  TextBaseline,\r\n} from \"../shared\";\r\nimport { CanvasRenderingContext2DSerializer } from \"./CanvasRenderingContext2DSerializer\";\r\nimport { log } from \"../linked/util\";\r\n\r\nexport function getContext(type: string): CanvasRenderingContext2D | null {\r\n  if (type == \"2d\") return new CanvasRenderingContext2D();\r\n  return null;\r\n}\r\n\r\nexport class CanvasRenderingContext2D extends CanvasRenderingContext2DSerializer {\r\n  private _direction: Direction[] = new Array<Direction>(0);\r\n  private _fillStyle: string[] = new Array<string>(0);\r\n  private _filter: string[] = new Array<string>(0);\r\n  private _font: string[] = new Array<string>(0);\r\n  private _globalAlpha: f64[] = new Array<f64>(0);\r\n  private _globalCompositeOperation: GlobalCompositeOperation[] = new Array<GlobalCompositeOperation>(0);\r\n  private _imageSmoothingEnabled: bool[] = new Array<bool>(0);\r\n  private _imageSmoothingQuality: ImageSmoothingQuality[] = new Array<ImageSmoothingQuality>(0);\r\n  private _lineCap: LineCap[] = new Array<LineCap>(0);\r\n  private _lineDash: f64[][] = new Array<f64[]>(0);\r\n  private _lineDashOffset: f64[] = new Array<f64>(0);\r\n  private _lineJoin: LineJoin[] = new Array<LineJoin>(0);\r\n  private _lineWidth: f64[] = new Array<f64>(0);\r\n  private _miterLimit: f64[] = new Array<f64>(0);\r\n  private _transformA: f64[] = new Array<f64>(0);\r\n  private _transformB: f64[] = new Array<f64>(0);\r\n  private _transformC: f64[] = new Array<f64>(0);\r\n  private _transformD: f64[] = new Array<f64>(0);\r\n  private _transformE: f64[] = new Array<f64>(0);\r\n  private _transformF: f64[] = new Array<f64>(0);\r\n  private _shadowBlur: f64[] = new Array<f64>(0);\r\n  private _shadowColor: string[] = new Array<string>(0);\r\n  private _shadowOffsetX: f64[] = new Array<f64>(0);\r\n  private _shadowOffsetY: f64[] = new Array<f64>(0);\r\n  private _strokeStyle: string[] = new Array<string>(0);\r\n  private _textAlign: TextAlign[] = new Array<TextAlign>(0);\r\n  private _textBaseline: TextBaseline[] = new Array<TextBaseline>(0);\r\n  private _stackIndex: i32 = 0;\r\n\r\n  public init(): void {\r\n    var i: i32 = 0;\r\n    while (i < 100) {\r\n      this._direction.push(Direction.inherit);\r\n      this._fillStyle.push(\"#000\");\r\n      this._filter.push(\"none\");\r\n      this._font.push(\"none\");\r\n      this._globalAlpha.push(1.0);\r\n      this._globalCompositeOperation.push(GlobalCompositeOperation.source_over);\r\n      this._imageSmoothingEnabled.push(true);\r\n      this._imageSmoothingQuality.push(ImageSmoothingQuality.low);\r\n      this._lineCap.push(LineCap.butt);\r\n      this._lineDash.push([]);\r\n      this._lineDashOffset.push(0.0);\r\n      this._lineJoin.push(LineJoin.miter);\r\n      this._lineWidth.push(1.0);\r\n      this._miterLimit.push(10.0);\r\n      this._transformA.push(1.0);\r\n      this._transformB.push(0.0);\r\n      this._transformC.push(0.0);\r\n      this._transformD.push(1.0);\r\n      this._transformE.push(0.0);\r\n      this._transformF.push(0.0);\r\n      this._shadowBlur.push(0.0);\r\n      this._shadowColor.push(\"#000\");\r\n      this._shadowOffsetX.push(0.0);\r\n      this._shadowOffsetY.push(0.0);\r\n      this._strokeStyle.push(\"#000\");\r\n      this._textAlign.push(TextAlign.start);\r\n      this._textBaseline.push(TextBaseline.alphabetic);\r\n      i++;\r\n    }\r\n    super.init();\r\n  }\r\n\r\n  public save(): void {\r\n    super.write_save();\r\n    var next: i32 = this._stackIndex + 1;\r\n    unchecked(this._direction[next] = this.direction);\r\n    unchecked(this._fillStyle[next] = this.fillStyle);\r\n    unchecked(this._filter[next] = this.filter);\r\n    unchecked(this._font[next] = this.font);\r\n    unchecked(this._globalAlpha[next] = this.globalAlpha);\r\n    unchecked(this._globalCompositeOperation[next] = this.globalCompositeOperation);\r\n    unchecked(this._imageSmoothingEnabled[next] = this.imageSmoothingEnabled);\r\n    unchecked(this._imageSmoothingQuality[next] = this.imageSmoothingQuality);\r\n    unchecked(this._lineCap[next] = this.lineCap);\r\n    unchecked(this._lineDash[next] = this.getLineDash());\r\n    unchecked(this._lineDashOffset[next] = this.lineDashOffset);\r\n    unchecked(this._lineJoin[next] = this.lineJoin);\r\n    unchecked(this._lineWidth[next] = this.lineWidth);\r\n    unchecked(this._miterLimit[next] = this.miterLimit);\r\n    unchecked(this._transformA[next] = this._transformA[this._stackIndex]);\r\n    unchecked(this._transformB[next] = this._transformB[this._stackIndex]);\r\n    unchecked(this._transformC[next] = this._transformC[this._stackIndex]);\r\n    unchecked(this._transformD[next] = this._transformD[this._stackIndex]);\r\n    unchecked(this._transformE[next] = this._transformE[this._stackIndex]);\r\n    unchecked(this._transformF[next] = this._transformF[this._stackIndex]);\r\n    unchecked(this._shadowBlur[next] = this.shadowBlur);\r\n    unchecked(this._shadowColor[next] = this.shadowColor);\r\n    unchecked(this._shadowOffsetX[next] = this.shadowOffsetX);\r\n    unchecked(this._shadowOffsetY[next] = this.shadowOffsetY);\r\n    unchecked(this._strokeStyle[next] = this.strokeStyle);\r\n    unchecked(this._textAlign[next] = this.textAlign);\r\n    unchecked(this._textBaseline[next] = this.textBaseline);\r\n\r\n    this._stackIndex = next;\r\n  }\r\n\r\n  public restore(): void {\r\n    super.write_restore();\r\n    --this._stackIndex;\r\n  }\r\n\r\n  public arc(x: f64, y: f64, radius: f64, startAngle: f64, endAngle: f64, anticlockwise: bool = false): void {\r\n    super.write_arc(x, y, radius, startAngle, endAngle, anticlockwise);\r\n  }\r\n\r\n  public arcTo(x1: f64, y1: f64, x2: f64, y2: f64, radius: f64): void {\r\n    super.write_arc_to(x1, y1, x2, y2, radius);\r\n  }\r\n\r\n  public beginPath(): void {\r\n    super.write_begin_path();\r\n  }\r\n\r\n  public bezierCurveTo(cp1x: f64, cp1y: f64, cp2x: f64, cp2y: f64, x: f64, y: f64): void {\r\n    super.write_bezier_curve_to(cp1x, cp1y, cp2x, cp2y, x, y);\r\n  }\r\n\r\n  public clearRect(x: f64, y: f64, width: f64, height: f64): void {\r\n    super.write_clear_rect(x, y, width, height);\r\n  }\r\n\r\n  public clip(fillRule: FillRule = FillRule.evenodd): void {\r\n    super.write_clip(fillRule);\r\n  }\r\n\r\n  public closePath(): void {\r\n    super.write_close_path();\r\n  }\r\n\r\n  public commit(): ArrayBuffer {\r\n    super.write_commit();\r\n    super.index = 0;\r\n    return super.data.buffer;\r\n  }\r\n\r\n  get currentTransform(): Matrix {\r\n    return Matrix.create(\r\n      unchecked(this._transformA[this._stackIndex]),\r\n      unchecked(this._transformB[this._stackIndex]),\r\n      unchecked(this._transformC[this._stackIndex]),\r\n      unchecked(this._transformD[this._stackIndex]),\r\n      unchecked(this._transformE[this._stackIndex]),\r\n      unchecked(this._transformF[this._stackIndex]),\r\n    );\r\n  }\r\n\r\n  set currentTransform(value: Matrix) {\r\n    unchecked(this._transformA[this._stackIndex] = value.a);\r\n    unchecked(this._transformB[this._stackIndex] = value.b);\r\n    unchecked(this._transformC[this._stackIndex] = value.c);\r\n    unchecked(this._transformD[this._stackIndex] = value.d);\r\n    unchecked(this._transformE[this._stackIndex] = value.e);\r\n    unchecked(this._transformF[this._stackIndex] = value.f);\r\n    super.write_set_transform(value.a, value.b, value.c, value.d, value.e, value.f);\r\n  }\r\n\r\n  get direction(): Direction {\r\n    return unchecked(this._direction[this._stackIndex]);\r\n  }\r\n\r\n  set direction(value: Direction) {\r\n    unchecked(this._direction[this._stackIndex] = value);\r\n    super.write_direction(value);\r\n  }\r\n\r\n  public drawFocusedIfNeeded(): void {\r\n    super.write_draw_focus_if_needed();\r\n  }\r\n\r\n  public drawImage(img: ImageBitmap, x: f64, y: f64, width: f64, height: f64, sx: f64, sy: f64, swidth: f64, sheight: f64): void {\r\n    if (!img._loaded) return;\r\n    super.write_draw_image(img, x, y, width, height, sx, sy, swidth, sheight);\r\n  }\r\n\r\n  public drawImagePosition(img: ImageBitmap, x: f64, y: f64): void {\r\n    if (!img._loaded) return;\r\n    super.write_draw_image(img, x, y, img.width, img.height, 0.0, 0.0, img.width, img.height);\r\n  }\r\n\r\n  public drawImageSize(img: ImageBitmap, x: f64, y: f64, width: f64, height: f64): void {\r\n    if (!img._loaded) return;\r\n    super.write_draw_image(img, x, y, width, height, 0.0, 0.0, img.width, img.height);\r\n  }\r\n\r\n  public ellipse(x: f64, y: f64, radiusX: f64, radiusY: f64, rotation: f64, startAngle: f64, endAngle: f64, anticlockwise: bool = false): void {\r\n    super.write_ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise);\r\n  }\r\n\r\n  public fill(fillRule: FillRule = FillRule.nonzero): void {\r\n    super.write_fill(fillRule);\r\n  }\r\n\r\n  public fillRect(x: f64, y: f64, width: f64, height: f64): void {\r\n    super.write_fill_rect(x, y, width, height);\r\n  }\r\n\r\n  get fillStyle(): string {\r\n    return unchecked(this._fillStyle[this._stackIndex]);\r\n  }\r\n\r\n  set fillStyle(value: string) {\r\n    unchecked(this._fillStyle[this._stackIndex] = value);\r\n    super.write_fill_style(value);\r\n  }\r\n\r\n  public fillText(text: string, x: f64, y: f64, maxWidth: f64 = -1.0): void {\r\n    return super.write_fill_text(text, x, y, maxWidth);\r\n  }\r\n\r\n  get filter(): string {\r\n    return unchecked(this._filter[this._stackIndex]);\r\n  }\r\n\r\n  set filter(value: string) {\r\n    unchecked(this._filter[this._stackIndex] = value);\r\n    super.write_filter(value);\r\n  }\r\n\r\n  get font(): string {\r\n    return unchecked(this._font[this._stackIndex]);\r\n  }\r\n\r\n  set font(value: string) {\r\n    unchecked(this._font[this._stackIndex] = value);\r\n    super.write_font(value);\r\n  }\r\n\r\n  get globalAlpha(): f64 {\r\n    return unchecked(this._globalAlpha[this._stackIndex]);\r\n  }\r\n\r\n  set globalAlpha(value: f64) {\r\n    unchecked(this._globalAlpha[this._stackIndex] = value);\r\n    super.write_global_alpha(value);\r\n  }\r\n\r\n  get globalCompositeOperation(): GlobalCompositeOperation {\r\n    return unchecked(this._globalCompositeOperation[this._stackIndex]);\r\n  }\r\n\r\n  set globalCompositeOperation(value: GlobalCompositeOperation) {\r\n    unchecked(this._globalCompositeOperation[this._stackIndex] = value);\r\n    super.write_global_composite_operation(value);\r\n  }\r\n\r\n  get imageSmoothingEnabled(): bool {\r\n    return unchecked(this._imageSmoothingEnabled[this._stackIndex]);\r\n  }\r\n\r\n  set imageSmoothingEnabled(value: bool) {\r\n    unchecked(this._imageSmoothingEnabled[this._stackIndex] = value);\r\n    super.write_image_smoothing_enabled(value);\r\n  }\r\n\r\n  get imageSmoothingQuality(): ImageSmoothingQuality {\r\n    return unchecked(this._imageSmoothingQuality[this._stackIndex]);\r\n  }\r\n\r\n  set imageSmoothingQuality(value: ImageSmoothingQuality) {\r\n    unchecked(this._imageSmoothingQuality[this._stackIndex] = value);\r\n    super.write_image_smoothing_quality(value);\r\n  }\r\n\r\n  get lineCap(): LineCap {\r\n    return unchecked(this._lineCap[this._stackIndex]);\r\n  }\r\n\r\n  set lineCap(value: LineCap) {\r\n    unchecked(this._lineCap[this._stackIndex] = value);\r\n    super.write_line_cap(value);\r\n  }\r\n\r\n  public getLineDash(): Array<f64> {\r\n    var lineDash: f64[] = unchecked(this._lineDash[this._stackIndex]);\r\n    return lineDash.slice(0);\r\n  }\r\n\r\n  public setLineDash(value: Array<f64>): void {\r\n    unchecked(this._lineDash[this._stackIndex] = ((value.length & 1) == 1) ? value.concat(value) : value.slice(0));\r\n    super.write_line_dash(unchecked(this._lineDash[this._stackIndex]));\r\n  }\r\n\r\n  get lineDashOffset(): f64 {\r\n    return unchecked(this._lineDashOffset[this._stackIndex]);\r\n  }\r\n\r\n  set lineDashOffset(value: f64) {\r\n    unchecked(this._lineDashOffset[this._stackIndex] = value);\r\n    super.write_line_dash_offset(value);\r\n  }\r\n\r\n  get lineJoin(): LineJoin {\r\n    return unchecked(this._lineJoin[this._stackIndex]);\r\n  }\r\n\r\n  set lineJoin(value: LineJoin) {\r\n    unchecked(this._lineJoin[this._stackIndex] = value);\r\n    super.write_line_join(value);\r\n  }\r\n\r\n  public lineTo(x: f64, y: f64): void {\r\n    super.write_line_to(x, y);\r\n  }\r\n\r\n  get lineWidth(): f64 {\r\n    return unchecked(this._lineWidth[this._stackIndex]);\r\n  }\r\n\r\n  set lineWidth(value: f64) {\r\n    unchecked(this._lineWidth[this._stackIndex] = value);\r\n    super.write_line_width(value);\r\n  }\r\n\r\n  get miterLimit(): f64 {\r\n    return unchecked(this._miterLimit[this._stackIndex]);\r\n  }\r\n\r\n  set miterLimit(value: f64) {\r\n    unchecked(this._miterLimit[this._stackIndex] = value);\r\n    super.write_miter_limit(value);\r\n  }\r\n\r\n  public moveTo(x: f64, y: f64): void {\r\n    super.write_move_to(x, y);\r\n  }\r\n  \r\n  public quadraticCurveTo(cpx: f64, cpy: f64, x: f64, y: f64): void {\r\n    super.write_quadratic_curve_to(cpx, cpy, x, y);\r\n  }\r\n\r\n  public rect(x: f64, y: f64, width: f64, height: f64): void {\r\n    super.write_rect(x, y, width, height);\r\n  }\r\n\r\n  public rotate(angle: f64): void {\r\n    var cos: f64 = Math.cos(angle);\r\n    var sin: f64 = Math.sin(angle);\r\n    var a: f64 = this._transformA[this._stackIndex];\r\n    var b: f64 = this._transformB[this._stackIndex];\r\n    var c: f64 = this._transformC[this._stackIndex];\r\n    var d: f64 = this._transformD[this._stackIndex];\r\n    unchecked(this._transformA[this._stackIndex] = a * cos + c * sin);\r\n    unchecked(this._transformB[this._stackIndex] = b * cos + d * sin);\r\n    unchecked(this._transformC[this._stackIndex] = a * -sin + c * cos);\r\n    unchecked(this._transformD[this._stackIndex] = b * -sin + d * cos);\r\n    super.write_rotate(angle);\r\n  }\r\n\r\n  public scale(x: f64, y: f64): void {\r\n    unchecked(this._transformA[this._stackIndex] *= x);\r\n    unchecked(this._transformB[this._stackIndex] *= x);\r\n    unchecked(this._transformC[this._stackIndex] *= y);\r\n    unchecked(this._transformD[this._stackIndex] *= y);\r\n    super.write_scale(x, y);\r\n  }\r\n\r\n  public setTransform(a: f64, b: f64, c: f64, d: f64, e: f64, f: f64): void {\r\n    unchecked(this._transformA[this._stackIndex] = a);\r\n    unchecked(this._transformB[this._stackIndex] = b);\r\n    unchecked(this._transformC[this._stackIndex] = c);\r\n    unchecked(this._transformD[this._stackIndex] = d);\r\n    unchecked(this._transformE[this._stackIndex] = e);\r\n    unchecked(this._transformF[this._stackIndex] = f);\r\n    super.write_transform(a, b, c, d, e, f);\r\n  }\r\n\r\n  get shadowBlur(): f64 {\r\n    return unchecked(this._shadowBlur[this._stackIndex]);\r\n  }\r\n\r\n  set shadowBlur(value: f64) {\r\n    unchecked(this._shadowBlur[this._stackIndex] = value);\r\n    super.write_shadow_blur(value);\r\n  }\r\n\r\n  get shadowColor(): string {\r\n    return unchecked(this._shadowColor[this._stackIndex]);\r\n  }\r\n\r\n  set shadowColor(value: string) {\r\n    unchecked(this._shadowColor[this._stackIndex] = value);\r\n    super.write_shadow_color(value);\r\n  }\r\n\r\n  get shadowOffsetX(): f64 {\r\n    return unchecked(this._shadowOffsetX[this._stackIndex]);\r\n  }\r\n\r\n  set shadowOffsetX(value: f64) {\r\n    unchecked(this._shadowOffsetX[this._stackIndex] = value);\r\n    super.write_shadow_offset_x(value);\r\n  }\r\n\r\n  get shadowOffsetY(): f64 {\r\n    return unchecked(this._shadowOffsetY[this._stackIndex]);\r\n  }\r\n\r\n  set shadowOffsetY(value: f64) {\r\n    unchecked(this._shadowOffsetY[this._stackIndex] = value);\r\n    super.write_shadow_offset_y(value);\r\n  }\r\n\r\n  public stroke(): void {\r\n    super.write_stroke();\r\n  }\r\n\r\n  public strokeRect(x: f64, y: f64, width: f64, height: f64): void {\r\n    super.write_stroke_rect(x, y, width, height);\r\n  }\r\n\r\n  get strokeStyle(): string {\r\n    return unchecked(this._strokeStyle[this._stackIndex]);\r\n  }\r\n\r\n  set strokeStyle(value: string) {\r\n    unchecked(this._strokeStyle[this._stackIndex] = value);\r\n    super.write_stroke_style(value);\r\n  }\r\n\r\n  public strokeText(text: string, x: f64, y: f64, maxWidth: f64 = -1.0): void {\r\n    super.write_stroke_text(text, x, y, maxWidth);\r\n  }\r\n\r\n  get textAlign(): TextAlign {\r\n    return unchecked(this._textAlign[this._stackIndex]);\r\n  }\r\n\r\n  set textAlign(value: TextAlign) {\r\n    unchecked(this._textAlign[this._stackIndex] = value);\r\n    super.write_text_align(value);\r\n  }\r\n\r\n  get textBaseline(): TextBaseline {\r\n    return unchecked(this._textBaseline[this._stackIndex]);\r\n  }\r\n\r\n  set textBaseline(value: TextBaseline) {\r\n    unchecked(this._textBaseline[this._stackIndex] = value);\r\n    super.write_text_baseline(value);\r\n  }\r\n\r\n  public transform(a: f64, b: f64, c: f64, d: f64, e: f64, f: f64): void {\r\n    var sa: f64 = unchecked(this._transformA[this._stackIndex]);\r\n    var sb: f64 = unchecked(this._transformB[this._stackIndex]);\r\n    var sc: f64 = unchecked(this._transformC[this._stackIndex]);\r\n    var sd: f64 = unchecked(this._transformD[this._stackIndex]);\r\n    var se: f64 = unchecked(this._transformE[this._stackIndex]);\r\n    var sf: f64 = unchecked(this._transformF[this._stackIndex]);\r\n    unchecked(this._transformA[this._stackIndex] = sa * a + sc * b);\r\n    unchecked(this._transformB[this._stackIndex] = sb * a + sd * b);\r\n    unchecked(this._transformC[this._stackIndex] = sa * c + sc * d);\r\n    unchecked(this._transformD[this._stackIndex] = sb * c + sd * d);\r\n    unchecked(this._transformE[this._stackIndex] = sa * e + sc * f + se);\r\n    unchecked(this._transformF[this._stackIndex] = sb * e + sd * f + sf);\r\n    super.write_transform(a, b, c, d, e, f);\r\n  }\r\n\r\n  public translate(x: f64, y: f64): void {\r\n    unchecked(this._transformE[this._stackIndex] += this._transformA[this._stackIndex] * x + this._transformC[this._stackIndex] * y);\r\n    unchecked(this._transformF[this._stackIndex] += this._transformB[this._stackIndex] * x + this._transformD[this._stackIndex] * y);\r\n    super.write_translate(x, y);\r\n  }\r\n}\r\n","import {\n  MAX_BLENGTH,\n  HEADER_SIZE,\n  allocateUnsafe,\n  reallocateUnsafe,\n  LOAD,\n  STORE\n} from \"./internal/arraybuffer\";\n\nimport {\n  allocateUnsafe as allocateUnsafeString,\n  freeUnsafe as freeUnsafeString,\n  copyUnsafe as copyUnsafeString\n} from \"./internal/string\";\n\nimport {\n  COMPARATOR,\n  SORT\n} from \"./internal/sort\";\n\nimport {\n  itoa,\n  dtoa,\n  itoa_stream,\n  dtoa_stream,\n  MAX_DOUBLE_LENGTH\n} from \"./internal/number\";\n\nimport {\n  isArray as builtin_isArray\n} from \"./builtins\";\n\nexport class Array<T> {\n  [key: number]: T; // compatibility only\n\n  /* @internal */ buffer_: ArrayBuffer;\n  /* @internal */ length_: i32;\n\n  @inline static isArray<U>(value: U): bool {\n    return builtin_isArray(value) && value !== null;\n  }\n\n  constructor(length: i32 = 0) {\n    const MAX_LENGTH = MAX_BLENGTH >>> alignof<T>();\n    if (<u32>length > <u32>MAX_LENGTH) throw new RangeError(\"Invalid array length\");\n    var byteLength = length << alignof<T>();\n    var buffer = allocateUnsafe(byteLength);\n    this.buffer_ = buffer;\n    this.length_ = length;\n    memory.fill(\n      changetype<usize>(buffer) + HEADER_SIZE,\n      0,\n      <usize>byteLength\n    );\n  }\n\n  @inline\n  get length(): i32 {\n    return this.length_;\n  }\n\n  set length(length: i32) {\n    var buffer = this.buffer_;\n    var capacity = buffer.byteLength >>> alignof<T>();\n    if (<u32>length > <u32>capacity) {\n      const MAX_LENGTH = MAX_BLENGTH >>> alignof<T>();\n      if (<u32>length > <u32>MAX_LENGTH) throw new RangeError(\"Invalid array length\");\n      buffer = reallocateUnsafe(buffer, length << alignof<T>());\n      this.buffer_ = buffer;\n    }\n    this.length_ = length;\n  }\n\n  every(callbackfn: (element: T, index: i32, array: Array<T>) => bool): bool {\n    var buffer = this.buffer_;\n    for (let index = 0, toIndex = this.length_; index < min(toIndex, this.length_); ++index) {\n      if (!callbackfn(LOAD<T>(buffer, index), index, this)) return false;\n    }\n    return true;\n  }\n\n  findIndex(predicate: (element: T, index: i32, array: Array<T>) => bool): i32 {\n    var buffer = this.buffer_;\n    for (let index = 0, toIndex = this.length_; index < min(toIndex, this.length_); ++index) {\n      if (predicate(LOAD<T>(buffer, index), index, this)) return index;\n    }\n    return -1;\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): T {\n    var buffer = this.buffer_;\n    return <u32>index < <u32>(buffer.byteLength >>> alignof<T>())\n      ? LOAD<T>(buffer, index)\n      : <T>unreachable();\n  }\n\n  @operator(\"{}\")\n  private __unchecked_get(index: i32): T {\n    return LOAD<T>(this.buffer_, index);\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: T): void {\n    var buffer = this.buffer_;\n    var capacity = buffer.byteLength >>> alignof<T>();\n    if (<u32>index >= <u32>capacity) {\n      const MAX_LENGTH = MAX_BLENGTH >>> alignof<T>();\n      if (<u32>index >= <u32>MAX_LENGTH) throw new Error(\"Invalid array length\");\n      buffer = reallocateUnsafe(buffer, (index + 1) << alignof<T>());\n      this.buffer_ = buffer;\n      this.length_ = index + 1;\n    }\n    STORE<T>(buffer, index, value);\n    if (isManaged<T>()) __gc_link(changetype<usize>(this), changetype<usize>(value)); // tslint:disable-line\n  }\n\n  @operator(\"{}=\")\n  private __unchecked_set(index: i32, value: T): void {\n    STORE<T>(this.buffer_, index, value);\n    if (isManaged<T>()) __gc_link(changetype<usize>(this), changetype<usize>(value)); // tslint:disable-line\n  }\n\n  fill(value: T, start: i32 = 0, end: i32 = i32.MAX_VALUE): this {\n    var buffer = this.buffer_;\n    var len    = this.length_;\n\n    start = start < 0 ? max(len + start, 0) : min(start, len);\n    end   = end   < 0 ? max(len + end,   0) : min(end,   len);\n\n    if (sizeof<T>() == 1) {\n      if (start < end) {\n        memory.fill(\n          changetype<usize>(buffer) + start + HEADER_SIZE,\n          <u8>value,\n          <usize>(end - start)\n        );\n      }\n    } else {\n      for (; start < end; ++start) {\n        STORE<T>(buffer, start, value);\n      }\n    }\n    return this;\n  }\n\n  @inline\n  includes(searchElement: T, fromIndex: i32 = 0): bool {\n    return this.indexOf(searchElement, fromIndex) >= 0;\n  }\n\n  indexOf(searchElement: T, fromIndex: i32 = 0): i32 {\n    var length = this.length_;\n    if (length == 0 || fromIndex >= length) return -1;\n    if (fromIndex < 0) fromIndex = max(length + fromIndex, 0);\n    var buffer = this.buffer_;\n    while (fromIndex < length) {\n      if (LOAD<T>(buffer, fromIndex) == searchElement) return fromIndex;\n      ++fromIndex;\n    }\n    return -1;\n  }\n\n  lastIndexOf(searchElement: T, fromIndex: i32 = this.length_): i32 {\n    var length = this.length_;\n    if (length == 0) return -1;\n    if (fromIndex < 0) fromIndex = length + fromIndex; // no need to clamp\n    else if (fromIndex >= length) fromIndex = length - 1;\n    var buffer = this.buffer_;\n    while (fromIndex >= 0) {                           // ^\n      if (LOAD<T>(buffer, fromIndex) == searchElement) return fromIndex;\n      --fromIndex;\n    }\n    return -1;\n  }\n\n  push(element: T): i32 {\n    var length = this.length_;\n    var buffer = this.buffer_;\n    var capacity = buffer.byteLength >>> alignof<T>();\n    var newLength = length + 1; // safe only if length is checked\n    if (<u32>length >= <u32>capacity) {\n      const MAX_LENGTH = MAX_BLENGTH >>> alignof<T>();\n      if (<u32>length >= <u32>MAX_LENGTH) throw new Error(\"Invalid array length\");\n      buffer = reallocateUnsafe(buffer, newLength << alignof<T>());\n      this.buffer_ = buffer;\n    }\n    this.length_ = newLength;\n    STORE<T>(buffer, length, element);\n    if (isManaged<T>()) __gc_link(changetype<usize>(this), changetype<usize>(element)); // tslint:disable-line\n    return newLength;\n  }\n\n  concat(items: Array<T>): Array<T> {\n    var thisLen = this.length_;\n    var otherLen = items === null ? 0 : items.length_;\n    var outLen = thisLen + otherLen;\n    var out = new Array<T>(outLen);\n\n    if (thisLen) {\n      memory.copy(\n        changetype<usize>(out.buffer_)  + HEADER_SIZE,\n        changetype<usize>(this.buffer_) + HEADER_SIZE,\n        <usize>thisLen << alignof<T>()\n      );\n    }\n    if (otherLen) {\n      memory.copy(\n        changetype<usize>(out.buffer_)   + HEADER_SIZE + (<usize>thisLen << alignof<T>()),\n        changetype<usize>(items.buffer_) + HEADER_SIZE,\n        <usize>otherLen << alignof<T>()\n      );\n    }\n    return out;\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): this {\n    var buffer = this.buffer_;\n    var len = this.length_;\n\n        end   = min<i32>(end, len);\n    var to    = target < 0 ? max(len + target, 0) : min(target, len);\n    var from  = start < 0 ? max(len + start, 0) : min(start, len);\n    var last  = end < 0 ? max(len + end, 0) : min(end, len);\n    var count = min(last - from, len - to);\n\n    if (from < to && to < (from + count)) {\n      from += count - 1;\n      to   += count - 1;\n      while (count) {\n        STORE<T>(buffer, to, LOAD<T>(buffer, from));\n        --from, --to, --count;\n      }\n    } else {\n      memory.copy(\n        changetype<usize>(buffer) + HEADER_SIZE + (<usize>to << alignof<T>()),\n        changetype<usize>(buffer) + HEADER_SIZE + (<usize>from << alignof<T>()),\n        <usize>count << alignof<T>()\n      );\n    }\n    return this;\n  }\n\n  pop(): T {\n    var length = this.length_;\n    if (length < 1) throw new RangeError(\"Array is empty\");\n    var element = LOAD<T>(this.buffer_, --length);\n    this.length_ = length;\n    return element;\n  }\n\n  forEach(callbackfn: (value: T, index: i32, array: Array<T>) => void): void {\n    var buffer = this.buffer_;\n    for (let index = 0, toIndex = this.length_; index < toIndex && index < this.length_; ++index) {\n      callbackfn(LOAD<T>(buffer, index), index, this);\n    }\n  }\n\n  map<U>(callbackfn: (value: T, index: i32, array: Array<T>) => U): Array<U> {\n    var buffer = this.buffer_;\n    var length = this.length_;\n    var result = new Array<U>(length);\n    var resultBuffer = result.buffer_;\n    for (let index = 0; index < min(length, this.length_); ++index) {\n      STORE<U>(resultBuffer, index, callbackfn(LOAD<T>(buffer, index), index, this));\n    }\n    return result;\n  }\n\n  filter(callbackfn: (value: T, index: i32, array: Array<T>) => bool): Array<T> {\n    var buffer = this.buffer_;\n    var result = new Array<T>();\n    for (let index = 0, toIndex = this.length_; index < min(toIndex, this.length_); ++index) {\n      let value = LOAD<T>(buffer, index);\n      if (callbackfn(value, index, this)) result.push(value);\n    }\n    return result;\n  }\n\n  reduce<U>(\n    callbackfn: (previousValue: U, currentValue: T, currentIndex: i32, array: Array<T>) => U,\n    initialValue: U\n  ): U {\n    var accum = initialValue;\n    var buffer = this.buffer_;\n    for (let index = 0, toIndex = this.length_; index < min(toIndex, this.length_); ++index) {\n      accum = callbackfn(accum, LOAD<T>(buffer, index), index, this);\n    }\n    return accum;\n  }\n\n  reduceRight<U>(\n    callbackfn: (previousValue: U, currentValue: T, currentIndex: i32, array: Array<T>) => U,\n    initialValue: U\n  ): U {\n    var accum = initialValue;\n    var buffer = this.buffer_;\n    for (let index: i32 = this.length_ - 1; index >= 0; --index) {\n      accum = callbackfn(accum, LOAD<T>(buffer, index), index, this);\n    }\n    return accum;\n  }\n\n  shift(): T {\n    var length = this.length_;\n    if (length < 1) throw new RangeError(\"Array is empty\");\n    var buffer = this.buffer_;\n    var element = LOAD<T>(buffer, 0);\n    var lastIndex = length - 1;\n    memory.copy(\n      changetype<usize>(buffer) + HEADER_SIZE,\n      changetype<usize>(buffer) + HEADER_SIZE + sizeof<T>(),\n      <usize>lastIndex << alignof<T>()\n    );\n    STORE<T>(buffer, lastIndex, <T>null);\n    this.length_ = lastIndex;\n    return element;\n  }\n\n  some(callbackfn: (element: T, index: i32, array: Array<T>) => bool): bool {\n    var buffer = this.buffer_;\n    for (let index = 0, toIndex = this.length_; index < min(toIndex, this.length_); ++index) {\n      if (callbackfn(LOAD<T>(buffer, index), index, this)) return true;\n    }\n    return false;\n  }\n\n  unshift(element: T): i32 {\n    var buffer = this.buffer_;\n    var capacity = buffer.byteLength >>> alignof<T>();\n    var length = this.length_;\n    var newLength = length + 1; // safe only if length is checked\n    if (<u32>length >= <u32>capacity) {\n      const MAX_LENGTH = MAX_BLENGTH >>> alignof<T>();\n      if (<u32>length >= <u32>MAX_LENGTH) throw new Error(\"Invalid array length\");\n      buffer = reallocateUnsafe(buffer, newLength << alignof<T>());\n      capacity = buffer.byteLength >>> alignof<T>();\n      this.buffer_ = buffer;\n    }\n    memory.copy(\n      changetype<usize>(buffer) + HEADER_SIZE + sizeof<T>(),\n      changetype<usize>(buffer) + HEADER_SIZE,\n      <usize>(capacity - 1) << alignof<T>()\n    );\n    STORE<T>(buffer, 0, element);\n    this.length_ = newLength;\n    if (isManaged<T>()) __gc_link(changetype<usize>(this), changetype<usize>(element)); // tslint:disable-line\n    return newLength;\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Array<T> {\n    var length = this.length_;\n    if (begin < 0) begin = max(length + begin, 0);\n    else if (begin > length) begin = length;\n    if (end < 0) end = length + end; // no need to clamp\n    else if (end > length) end = length;\n    if (end < begin) end = begin;    // ^\n    var newLength = end - begin;\n    assert(newLength >= 0);\n    var sliced = new Array<T>(newLength);\n    if (newLength) {\n      memory.copy(\n        changetype<usize>(sliced.buffer_) + HEADER_SIZE,\n        changetype<usize>(this.buffer_) + HEADER_SIZE + (<usize>begin << alignof<T>()),\n        <usize>newLength << alignof<T>()\n      );\n    }\n    return sliced;\n  }\n\n  splice(start: i32, deleteCount: i32 = i32.MAX_VALUE): Array<T> {\n    var length  = this.length_;\n    start       = start < 0 ? max<i32>(length + start, 0) : min<i32>(start, length);\n    deleteCount = max<i32>(min<i32>(deleteCount, length - start), 0);\n    var buffer  = this.buffer_;\n    var spliced = new Array<T>(deleteCount);\n    var source  = changetype<usize>(buffer) + HEADER_SIZE + (<usize>start << alignof<T>());\n    memory.copy(\n      changetype<usize>(spliced.buffer_) + HEADER_SIZE,\n      source,\n      <usize>deleteCount << alignof<T>()\n    );\n    var offset = start + deleteCount;\n    if (length != offset) {\n      memory.copy(\n        source,\n        changetype<usize>(buffer) + HEADER_SIZE + (<usize>offset << alignof<T>()),\n        <usize>(length - offset) << alignof<T>()\n      );\n    }\n    this.length_ = length - deleteCount;\n    return spliced;\n  }\n\n  reverse(): Array<T> {\n    var buffer = this.buffer_;\n    for (let front = 0, back = this.length_ - 1; front < back; ++front, --back) {\n      let temp = LOAD<T>(buffer, front);\n      STORE<T>(buffer, front, LOAD<T>(buffer, back));\n      STORE<T>(buffer, back, temp);\n    }\n    return this;\n  }\n\n  sort(comparator: (a: T, b: T) => i32 = COMPARATOR<T>()): this {\n    // TODO remove this when flow will allow trackcing null\n    assert(comparator); // The comparison function must be a function\n\n    var length = this.length_;\n    if (length <= 1) return this;\n    var buffer = this.buffer_;\n    if (length == 2) {\n      let a = LOAD<T>(buffer, 1); // a = arr[1]\n      let b = LOAD<T>(buffer, 0); // b = arr[0]\n      if (comparator(a, b) < 0) {\n        STORE<T>(buffer, 1, b);   // arr[1] = b;\n        STORE<T>(buffer, 0, a);   // arr[0] = a;\n      }\n      return this;\n    }\n    SORT<T>(buffer, 0, length, comparator);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    var lastIndex = this.length_ - 1;\n    if (lastIndex < 0) return \"\";\n    var result = \"\";\n    var value: T;\n    var buffer = this.buffer_;\n    var sepLen = separator.length;\n    var hasSeparator = sepLen != 0;\n    if (value instanceof bool) {\n      if (!lastIndex) {\n        return select<string>(\"true\", \"false\", LOAD<T,bool>(buffer, 0));\n      }\n      let valueLen = 5; // max possible length of element len(\"false\")\n      let estLen = (valueLen + sepLen) * lastIndex + valueLen;\n      let result = allocateUnsafeString(estLen);\n      let offset = 0;\n      for (let i = 0; i < lastIndex; ++i) {\n        value = LOAD<T,bool>(buffer, i);\n        valueLen = 4 + <i32>(!value);\n        copyUnsafeString(result, offset, select<string>(\"true\", \"false\", value), 0, valueLen);\n        offset += valueLen;\n        if (hasSeparator) {\n          copyUnsafeString(result, offset, changetype<String>(separator), 0, sepLen);\n          offset += sepLen;\n        }\n      }\n      value = LOAD<T,bool>(buffer, lastIndex);\n      valueLen = 4 + <i32>(!value);\n      copyUnsafeString(result, offset, select<string>(\"true\", \"false\", value), 0, valueLen);\n      offset += valueLen;\n\n      let out = result;\n      if (estLen > offset) {\n        out = result.substring(0, offset);\n        freeUnsafeString(result);\n      }\n      return out;\n    } else if (isInteger<T>()) {\n      if (!lastIndex) {\n        return changetype<string>(itoa<T>(LOAD<T>(buffer, 0)));\n      }\n      const valueLen = (sizeof<T>() <= 4 ? 10 : 20) + <i32>isSigned<T>();\n      let estLen = (valueLen + sepLen) * lastIndex + valueLen;\n      let result = allocateUnsafeString(estLen);\n      let offset = 0;\n      for (let i = 0; i < lastIndex; ++i) {\n        value = LOAD<T>(buffer, i);\n        offset += itoa_stream<T>(changetype<usize>(result), offset, value);\n        if (hasSeparator) {\n          copyUnsafeString(result, offset, separator, 0, sepLen);\n          offset += sepLen;\n        }\n      }\n      value = LOAD<T>(buffer, lastIndex);\n      offset += itoa_stream<T>(changetype<usize>(result), offset, value);\n      let out = result;\n      if (estLen > offset) {\n        out = result.substring(0, offset);\n        freeUnsafeString(result);\n      }\n      return out;\n    } else if (isFloat<T>()) {\n      if (!lastIndex) {\n        return changetype<string>(dtoa(LOAD<T,f64>(buffer, 0)));\n      }\n      const valueLen = MAX_DOUBLE_LENGTH;\n      let estLen = (valueLen + sepLen) * lastIndex + valueLen;\n      let result = allocateUnsafeString(estLen);\n      let offset = 0;\n      for (let i = 0; i < lastIndex; ++i) {\n        value = LOAD<T,f64>(buffer, i);\n        offset += dtoa_stream(changetype<usize>(result), offset, value);\n        if (hasSeparator) {\n          copyUnsafeString(result, offset, separator, 0, sepLen);\n          offset += sepLen;\n        }\n      }\n      value = LOAD<T,f64>(buffer, lastIndex);\n      offset += dtoa_stream(changetype<usize>(result), offset, value);\n      let out = result;\n      if (estLen > offset) {\n        out = result.substring(0, offset);\n        freeUnsafeString(result);\n      }\n      return out;\n    } else if (isString<T>()) {\n      if (!lastIndex) {\n        return LOAD<string>(buffer, 0);\n      }\n      let estLen = 0;\n      for (let i = 0, len = lastIndex + 1; i < len; ++i) {\n        estLen += LOAD<string>(buffer, i).length;\n      }\n      let offset = 0;\n      let result = allocateUnsafeString(estLen + sepLen * lastIndex);\n      for (let i = 0; i < lastIndex; ++i) {\n        value = LOAD<string>(buffer, i);\n        if (value) {\n          let valueLen = value.length;                          // tslint:disable-line:no-unsafe-any\n          copyUnsafeString(result, offset, value, 0, valueLen); // tslint:disable-line:no-unsafe-any\n          offset += valueLen;                                   // tslint:disable-line:no-unsafe-any\n        }\n        if (hasSeparator) {\n          copyUnsafeString(result, offset, separator, 0, sepLen);\n          offset += sepLen;\n        }\n      }\n      value = LOAD<string>(buffer, lastIndex);\n      if (value) {\n        let valueLen = value.length;                          // tslint:disable-line:no-unsafe-any\n        copyUnsafeString(result, offset, value, 0, valueLen); // tslint:disable-line:no-unsafe-any\n      }\n      return result;\n    } else if (isArray<T>()) {\n      if (!lastIndex) {\n        value = LOAD<T>(buffer, 0);\n        return value ? value.join(separator) : \"\"; // tslint:disable-line:no-unsafe-any\n      }\n      for (let i = 0; i < lastIndex; ++i) {\n        value = LOAD<T>(buffer, i);\n        if (value) result += value.join(separator); // tslint:disable-line:no-unsafe-any\n        if (hasSeparator) result += separator;\n      }\n      value = LOAD<T>(buffer, lastIndex);\n      if (value) result += value.join(separator); // tslint:disable-line:no-unsafe-any\n      return result;\n    } else if (isReference<T>()) { // References\n      if (!lastIndex) return \"[object Object]\";\n      const valueLen = 15; // max possible length of element len(\"[object Object]\")\n      let estLen = (valueLen + sepLen) * lastIndex + valueLen;\n      let result = allocateUnsafeString(estLen);\n      let offset = 0;\n      for (let i = 0; i < lastIndex; ++i) {\n        value = LOAD<T>(buffer, i);\n        if (value) {\n          copyUnsafeString(result, offset, changetype<String>(\"[object Object]\"), 0, valueLen);\n          offset += valueLen;\n        }\n        if (hasSeparator) {\n          copyUnsafeString(result, offset, changetype<String>(separator), 0, sepLen);\n          offset += sepLen;\n        }\n      }\n      if (LOAD<T>(buffer, lastIndex)) {\n        copyUnsafeString(result, offset, changetype<String>(\"[object Object]\"), 0, valueLen);\n        offset += valueLen;\n      }\n      let out = result;\n      if (estLen > offset) {\n        out = result.substring(0, offset);\n        freeUnsafeString(result);\n      }\n      return out;\n    } else {\n      assert(false); // Unsupported generic typename\n    }\n  }\n\n  @inline\n  toString(): string {\n    return this.join();\n  }\n\n  private __gc(): void {\n    var buffer = this.buffer_;\n    __gc_mark(changetype<usize>(buffer)); // tslint:disable-line\n    if (isManaged<T>()) {\n      let offset: usize = 0;\n      let end = <usize>this.length_ << alignof<usize>();\n      while (offset < end) {\n        __gc_mark(load<usize>(changetype<usize>(buffer) + offset, HEADER_SIZE)); // tslint:disable-line\n        offset += sizeof<usize>();\n      }\n    }\n  }\n}\n","import \"allocator/tlsf\";\r\n\r\nimport { CanvasRenderingContext2D, CanvasRenderingContext2DSerializer } from \"./renderer\";\r\nimport { ImageBitmap, createImageBitmap } from \"./primitives\";\r\nimport { log } from \"./linked/util\";\r\n\r\nvar ctx: CanvasRenderingContext2D;\r\nvar img: ImageBitmap;\r\nexport function init(): void {\r\n  ctx = new CanvasRenderingContext2D();\r\n  ctx.init();\r\n  img = createImageBitmap(\"http://placekitten.com/400/300\");\r\n}\r\n\r\nvar frame: i32 = 0;\r\nexport function draw(): ArrayBuffer {\r\n  ++frame;\r\n  if (frame >= 360) frame -= 360;\r\n  ctx.clearRect(0.0, 0.0, 800.0, 600.0);\r\n  ctx.save();\r\n  if (img._loaded) {\r\n    ctx.translate(200.0, 200.0);\r\n    ctx.rotate(Math.PI / 180.0 * frame * 2);\r\n    ctx.translate(-200.0, -200.0);\r\n    ctx.drawImagePosition(img, 0.0, 0.0);\r\n  }\r\n  ctx.restore();\r\n\r\n  return ctx.commit();\r\n}\r\n\r\nexport function check(): void {\r\n  log(<f64>img._loaded);\r\n  log(<f64>img.width);\r\n  log(<f64>img.height);\r\n}\r\n","export enum Direction {\r\n  ltr = 0,\r\n  rtl = 1,\r\n  inherit = 2,\r\n}\r\n","export enum GlobalCompositeOperation {\r\n  source_over = 0,\r\n  source_in = 1,\r\n  source_out = 2,\r\n  source_atop = 3,\r\n  destination_over = 4,\r\n  destination_in = 5,\r\n  destination_out = 6,\r\n  destination_atop = 7,\r\n  lighter = 8,\r\n  copy = 9,\r\n  xor = 10,\r\n  multiply = 11,\r\n  screen = 12,\r\n  overlay = 13,\r\n  darken = 14,\r\n  lighten = 15,\r\n  color_dodge = 16,\r\n  color_burn = 17,\r\n  hard_light = 18,\r\n  soft_light = 19,\r\n  difference = 20,\r\n  exclusion = 21,\r\n  hue = 22,\r\n  saturation = 23,\r\n  color = 24,\r\n  luminosity = 25,\r\n}\r\n","export enum ImageSmoothingQuality {\r\n  low = 0,\r\n  medium = 1,\r\n  high = 2,\r\n}\r\n","export enum LineCap {\r\n  butt = 0,\r\n  round = 1,\r\n  square = 2,\r\n}\r\n","export enum LineJoin {\r\n  bevel = 0,\r\n  round = 1,\r\n  miter = 2,\r\n}\r\n","export enum TextAlign {\r\n  left = 0,\r\n  right = 1,\r\n  center = 2,\r\n  start = 3,\r\n  end = 4,\r\n}\r\n","export enum TextBaseline {\r\n  top = 0,\r\n  hanging = 1,\r\n  middle = 2,\r\n  alphabetic = 3,\r\n  ideographic = 4,\r\n  bottom = 5,\r\n}\r\n","/* tslint:disable */\n\n@builtin @inline export const NaN: f64 = 0 / 0;\n@builtin @inline export const Infinity: f64 = 1 / 0;\n\n@builtin export declare function isInteger<T>(value?: T): bool;\n@builtin export declare function isFloat<T>(value?: T): bool;\n@builtin export declare function isSigned<T>(value?: T): bool;\n@builtin export declare function isReference<T>(value?: T): bool;\n@builtin export declare function isString<T>(value?: T): bool;\n@builtin export declare function isArray<T>(value?: T): bool;\n@builtin export declare function isDefined(expression: void): bool;\n@builtin export declare function isConstant(expression: void): bool;\n@builtin export declare function isManaged<T>(value?: T): bool;\n@inline export function isNaN<T>(value: T): bool { return value != value; }\n@inline export function isFinite<T>(value: T): bool { return value - value == 0; }\n\n@builtin export declare function clz<T>(value: T): T;\n@builtin export declare function ctz<T>(value: T): T;\n@builtin export declare function popcnt<T>(value: T): T;\n@builtin export declare function rotl<T>(value: T, shift: T): T;\n@builtin export declare function rotr<T>(value: T, shift: T): T;\n@builtin export declare function abs<T>(value: T): T;\n@builtin export declare function max<T>(left: T, right: T): T;\n@builtin export declare function min<T>(left: T, right: T): T;\n@builtin export declare function ceil<T>(value: T): T;\n@builtin export declare function floor<T>(value: T): T;\n@builtin export declare function copysign<T>(left: T, right: T): T;\n@builtin export declare function nearest<T>(value: T): T;\n@builtin export declare function reinterpret<T>(value: void): T;\n@builtin export declare function sqrt<T>(value: T): T;\n@builtin export declare function trunc<T>(value: T): T;\n@builtin export declare function load<T>(offset: usize, constantOffset?: usize): T;\n@builtin export declare function store<T>(offset: usize, value: void, constantOffset?: usize): void;\n@builtin export declare function sizeof<T>(): usize; // | u32 / u64\n@builtin export declare function alignof<T>(): usize; // | u32 / u64\n@builtin export declare function offsetof<T>(fieldName?: string): usize; // | u32 / u64\n@builtin export declare function select<T>(ifTrue: T, ifFalse: T, condition: bool): T;\n@builtin export declare function unreachable(): void;\n@builtin export declare function changetype<T>(value: void): T;\n@builtin export declare function assert<T>(isTrueish: T, message?: string): T;\n@builtin export declare function unchecked<T>(expr: T): T;\n@builtin export declare function call_indirect<T>(target: void, ...args: void[]): T;\n@builtin export declare function instantiate<T>(...args: void[]): T;\n\n@builtin export declare function i8(value: void): i8;\nexport namespace i8 {\n  export const MIN_VALUE: i8 = -128;\n  export const MAX_VALUE: i8 =  127;\n  @inline export function parseInt(value: string, radix: i32 = 0): i8 { return <i8>parseI32(value, radix) }\n  @inline export function parseFloat(value: string): i8 { return <i8>parseFloat(value) }\n}\n\n@builtin export declare function i16(value: void): i16;\nexport namespace i16 {\n  export const MIN_VALUE: i16 = -32768;\n  export const MAX_VALUE: i16 =  32767;\n  @inline export function parseInt(value: string, radix: i32 = 0): i16 { return <i16>parseI32(value, radix) }\n  @inline export function parseFloat(value: string): i16 { return <i16>parseFloat(value) }\n}\n\n@builtin export declare function i32(value: void): i32;\nexport namespace i32 {\n  export const MIN_VALUE: i32 = -2147483648;\n  export const MAX_VALUE: i32 =  2147483647;\n  @builtin export declare function clz(value: i32): i32;\n  @builtin export declare function ctz(value: i32): i32;\n  @builtin export declare function popcnt(value: i32): i32;\n  @builtin export declare function rotl(value: i32, shift: i32): i32;\n  @builtin export declare function rotr(value: i32, shift: i32): i32;\n  @builtin export declare function reinterpret_f32(value: f32): i32;\n  @builtin export declare function load8_s(offset: usize, constantOffset?: usize): i32;\n  @builtin export declare function load8_u(offset: usize, constantOffset?: usize): i32;\n  @builtin export declare function load16_s(offset: usize, constantOffset?: usize): i32;\n  @builtin export declare function load16_u(offset: usize, constantOffset?: usize): i32;\n  @builtin export declare function load(offset: usize, constantOffset?: usize): i32;\n  @builtin export declare function store8(offset: usize, value: i32, constantOffset?: usize): void;\n  @builtin export declare function store16(offset: usize, value: i32, constantOffset?: usize): void;\n  @builtin export declare function store(offset: usize, value: i32, constantOffset?: usize): void;\n  @inline export function parseInt(value: string, radix: i32 = 0): i32 { return <i32>parseI32(value, radix) }\n  @inline export function parseFloat(value: string): i32 { return <i32>parseFloat(value) }\n}\n\n@builtin export declare function i64(value: void): i64;\nexport namespace i64 {\n  export const MIN_VALUE: i64 = -9223372036854775808;\n  export const MAX_VALUE: i64 =  9223372036854775807;\n  @builtin export declare function clz(value: i64): i64;\n  @builtin export declare function ctz(value: i64): i64;\n  @builtin export declare function load8_s(offset: usize, constantOffset?: usize): i64;\n  @builtin export declare function load8_u(offset: usize, constantOffset?: usize): u64;\n  @builtin export declare function load16_s(offset: usize, constantOffset?: usize): i64;\n  @builtin export declare function load16_u(offset: usize, constantOffset?: usize): u64;\n  @builtin export declare function load32_s(offset: usize, constantOffset?: usize): i64;\n  @builtin export declare function load32_u(offset: usize, constantOffset?: usize): u64;\n  @builtin export declare function load(offset: usize, constantOffset?: usize): i64;\n  @builtin export declare function popcnt(value: i64): i64;\n  @builtin export declare function rotl(value: i64, shift: i64): i64;\n  @builtin export declare function rotr(value: i64, shift: i64): i64;\n  @builtin export declare function reinterpret_f64(value: f64): i64;\n  @builtin export declare function store8(offset: usize, value: i64, constantOffset?: usize): void;\n  @builtin export declare function store16(offset: usize, value: i64, constantOffset?: usize): void;\n  @builtin export declare function store32(offset: usize, value: i64, constantOffset?: usize): void;\n  @builtin export declare function store(offset: usize, value: i64, constantOffset?: usize): void;\n  @inline export function parseInt(value: string, radix: i32 = 0): i64 { return <i64>parseI64(value, radix) }\n  @inline export function parseFloat(value: string): i64 { return <i64>parseFloat(value) }\n}\n\n@builtin export declare function isize(value: void): isize;\nexport namespace isize {\n  export const MIN_VALUE: isize = sizeof<i32>() == sizeof<isize>()\n    ? -2147483648\n    : <isize>-9223372036854775808;\n  export const MAX_VALUE: isize = sizeof<i32>() == sizeof<isize>()\n    ? 2147483647\n    : <isize>9223372036854775807;\n  @inline export function parseInt(value: string, radix: i32 = 0): isize { return <isize>parseI64(value, radix) }\n  @inline export function parseFloat(value: string): isize { return <isize>parseFloat(value) }\n}\n\n@builtin export declare function u8(value: void): u8;\nexport namespace u8 {\n  export const MIN_VALUE: u8 = 0;\n  export const MAX_VALUE: u8 = 255;\n  @inline export function parseInt(value: string, radix: i32 = 0): u8 { return <u8>parseI32(value, radix) }\n  @inline export function parseFloat(value: string): u8 { return <u8>parseFloat(value) }\n}\n\n@builtin export declare function u16(value: void): u16;\nexport namespace u16 {\n  export const MIN_VALUE: u16 = 0;\n  export const MAX_VALUE: u16 = 65535;\n  @inline export function parseInt(value: string, radix: i32 = 0): u16 { return <u16>parseI32(value, radix) }\n  @inline export function parseFloat(value: string): u16 { return <u16>parseFloat(value) }\n}\n\n@builtin export declare function u32(value: void): u32;\nexport namespace u32 {\n  export const MIN_VALUE: u32 = 0;\n  export const MAX_VALUE: u32 = 4294967295;\n  @inline export function parseInt(value: string, radix: i32 = 0): u32 { return <u32>parseI32(value, radix) }\n  @inline export function parseFloat(value: string): u32 { return <u32>parseFloat(value) }\n}\n\n@builtin export declare function u64(value: void): u64;\nexport namespace u64 {\n  export const MIN_VALUE: u64 = 0;\n  export const MAX_VALUE: u64 = 18446744073709551615;\n  @inline export function parseInt(value: string, radix: i32 = 0): u64 { return <u64>parseI64(value, radix) }\n  @inline export function parseFloat(value: string): u64 { return <u64>parseFloat(value) }\n}\n\n@builtin export declare function usize(value: void): usize;\nexport namespace usize {\n  export const MIN_VALUE: usize = 0;\n  export const MAX_VALUE: usize = sizeof<u32>() == sizeof<usize>()\n    ? 4294967295\n    : <usize>18446744073709551615;\n  @inline export function parseInt(value: string, radix: i32 = 0): usize { return <usize>parseI64(value, radix) }\n  @inline export function parseFloat(value: string): usize { return <usize>parseFloat(value) }\n}\n\n@builtin export declare function bool(value: void): bool;\nexport namespace bool {\n  export const MIN_VALUE: bool = false;\n  export const MAX_VALUE: bool = true;\n}\n\n@builtin export declare function f32(value: void): f32;\nexport namespace f32 {\n  export const EPSILON = reinterpret<f32>(0x34000000); // 0x1p-23f\n  export const MIN_VALUE = reinterpret<f32>(0x00000001); // 0x0.000001p+0f\n  export const MAX_VALUE = reinterpret<f32>(0x7F7FFFFF); // 0x1.fffffep+127f\n  export const MIN_NORMAL_VALUE = reinterpret<f32>(0x00800000); // 0x1p-126f\n  export const MIN_SAFE_INTEGER: f32 = -16777215;\n  export const MAX_SAFE_INTEGER: f32 =  16777215;\n  export const POSITIVE_INFINITY: f32 =  Infinity;\n  export const NEGATIVE_INFINITY: f32 = -Infinity;\n  export const NaN: f32 = NaN;\n  @builtin export declare function abs(value: f32): f32;\n  @builtin export declare function ceil(value: f32): f32;\n  @builtin export declare function copysign(x: f32, y: f32): f32;\n  @builtin export declare function floor(value: f32): f32;\n  @builtin export declare function load(offset: usize, constantOffset?: usize): f32;\n  @builtin export declare function max(left: f32, right: f32): f32;\n  @builtin export declare function min(left: f32, right: f32): f32;\n  @builtin export declare function nearest(value: f32): f32;\n  @builtin export declare function reinterpret_i32(value: i32): f32;\n  @builtin export declare function sqrt(value: f32): f32;\n  @builtin export declare function store(offset: usize, value: f32, constantOffset?: usize): void;\n  @builtin export declare function trunc(value: f32): f32;\n  @inline  export function isNaN(value: f32): bool { return isNaN<f32>(value) }\n  @inline  export function isFinite(value: f32): bool { return isFinite<f32>(value) }\n  @inline  export function isSafeInteger(value: f32): bool { return abs<f32>(value) <= f32.MAX_SAFE_INTEGER && trunc<f32>(value) == value }\n  @inline  export function isInteger(value: f32): bool { return isFinite<f32>(value) && trunc<f32>(value) == value }\n  @inline  export function parseInt(value: string, radix: i32 = 0): f32 { return <f32>parseI64(value, radix) }\n  @inline  export function parseFloat(value: string): f32 { return <f32>parseFloat(value) }\n}\n\n@builtin export declare function f64(value: void): f64;\nexport namespace f64 {\n  export const EPSILON = reinterpret<f64>(0x3CB0000000000000); // 0x1p-52\n  export const MIN_VALUE = reinterpret<f64>(0x0000000000000001); // 0x0.0000000000001p+0\n  export const MAX_VALUE = reinterpret<f64>(0x7FEFFFFFFFFFFFFF); // 0x1.fffffffffffffp+1023\n  export const MIN_NORMAL_VALUE = reinterpret<f64>(0x0010000000000000); // 0x1p-1022\n  export const MIN_SAFE_INTEGER: f64 = -9007199254740991;\n  export const MAX_SAFE_INTEGER: f64 =  9007199254740991;\n  export const POSITIVE_INFINITY: f64 =  Infinity;\n  export const NEGATIVE_INFINITY: f64 = -Infinity;\n  export const NaN: f64 = NaN;\n  @builtin export declare function abs(value: f64): f64;\n  @builtin export declare function ceil(value: f64): f64;\n  @builtin export declare function copysign(x: f64, y: f64): f64;\n  @builtin export declare function floor(value: f64): f64;\n  @builtin export declare function load(offset: usize, constantOffset?: usize): f64;\n  @builtin export declare function max(left: f64, right: f64): f64;\n  @builtin export declare function min(left: f64, right: f64): f64;\n  @builtin export declare function nearest(value: f64): f64;\n  @builtin export declare function reinterpret_i64(value: i64): f64;\n  @builtin export declare function sqrt(value: f64): f64;\n  @builtin export declare function store(offset: usize, value: f64, constantOffset?: usize): void;\n  @builtin export declare function trunc(value: f64): f64;\n  @inline  export function isNaN(value: f64): bool { return isNaN<f64>(value) }\n  @inline  export function isFinite(value: f64): bool { return isFinite<f64>(value) }\n  @inline  export function isSafeInteger(value: f64): bool { return abs<f64>(value) <= f64.MAX_SAFE_INTEGER && trunc<f64>(value) == value }\n  @inline  export function isInteger(value: f64): bool { return isFinite<f64>(value) && trunc<f64>(value) == value }\n  @inline  export function parseInt(value: string, radix: i32 = 0): f64 { return <f64>parseI64(value, radix) }\n  @inline  export function parseFloat(value: string): f64 { return parseFloat(value) }\n}\n\n@builtin export declare function start(): void;\n"]}